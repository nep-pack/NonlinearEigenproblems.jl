<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Getting-started-1">Getting started</a></li><li class="toplevel"><a class="toctext" href="#Accessing-more-complicated-applications-1">Accessing more complicated applications</a></li><li class="toplevel"><a class="toctext" href="#A-model-of-a-neuron-1">A model of a neuron</a></li><li class="toplevel"><a class="toctext" href="#The-&quot;gun&quot;-benchmark-problem-1">The &quot;gun&quot; benchmark problem</a></li><li class="toplevel"><a class="toctext" href="#Your-own-NEP-nonlinearity-1">Your own NEP nonlinearity</a></li><li class="toplevel"><a class="toctext" href="#What-now?-1">What now?</a></li></ul></li><li><a class="toctext" href="methods/">NEP Methods</a></li><li><a class="toctext" href="types/">NEP Types</a></li><li><a class="toctext" href="linsolvers/">LinSolver</a></li><li><a class="toctext" href="errmeasure/">Error measure</a></li><li><a class="toctext" href="logger/">Logger</a></li><li><a class="toctext" href="transformations/">NEP Transformations</a></li><li><a class="toctext" href="gallery/">NEP Gallery</a></li><li><a class="toctext" href="movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="toctext" href="tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="toctext" href="bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="toctext" href="deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="toctext" href="tutorial_call_python/">Tutorial 5 (Python NEP)</a></li><li><a class="toctext" href="tutorial_matlab1/">Tutorial 6 (MATLAB 1)</a></li><li><a class="toctext" href="tutorial_fortran1/">Tutorial 7 (FORTRAN 1)</a></li><li><a class="toctext" href="tutorial_nano1/">Tutorial 8 (gmsh + nanophotonics)</a></li><li><a class="toctext" href="tutorial_newmethod/">Tutorial 9 (New solver)</a></li><li><a class="toctext" href="tutorial_linsolve/">Tutorial 10 (Linear solvers)</a></li><li><a class="toctext" href="hydrotutorial/">Tutorial 11 (Orr-Somerfeld)</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="NEP-PACK-1" href="#NEP-PACK-1">NEP-PACK</a></h1><p>NEP-PACK is a package with implementations of methods to solve nonlinear eigenvalue problems of the type: Find <span>$(λ,v)\in\mathbb{C}\times\mathbb{C}^n$</span> such that</p><div>\[M(λ)v=0\]</div><p>and <span>$v\neq 0$</span>.</p><h1><a class="nav-anchor" id="Getting-started-1" href="#Getting-started-1">Getting started</a></h1><p>Install it as a registered  package in Julia&#39;s REPL package mode by typing <code>] add Nonline...</code>:</p><pre><code class="language-none">julia&gt; ]
(v1.0) pkg&gt; add NonlinearEigenproblems</code></pre><p>Then we can start to load the NEP-PACK package</p><pre><code class="language-julia-repl">julia&gt; using NonlinearEigenproblems</code></pre><p>As a first example we will solve the NEP associated with the matrix polynomial</p><div>\[M(λ)=\begin{bmatrix}1&amp;3\newline5&amp;6\end{bmatrix}+
λ\begin{bmatrix}3&amp;4\newline6&amp;6\end{bmatrix}+
λ^2\begin{bmatrix}1&amp;0\newline0&amp;1\end{bmatrix}\]</div><p>The following code creates this NEP, by constructing an object called <a href="types/#PEP-1"><code>PEP</code></a>, an abbreviation for polynomial eigenvalue problem. It subsequencly solves it using the NEP solution method implemented in <a href="methods/#NonlinearEigenproblems.NEPSolver.polyeig"><code>polyeig()</code></a>:</p><pre><code class="language-julia-repl">julia&gt; A0=[1.0 3; 5 6]; A1=[3.0 4; 6 6]; A2=[1.0 0; 0 1.0];
julia&gt; nep=PEP([A0,A1,A2])
PEP(2, Array{Float64,2}[[1.0 3.0; 5.0 6.0], [3.0 4.0; 6.0 6.0], [1.0 0.0; 0.0 1.0]])
julia&gt; λ,v=polyeig(nep)
(Complex{Float64}[1.36267+0.0im, -0.824084+0.280682im, -0.824084-0.280682im, -8.7145+0.0im], Complex{Float64}[-1.0+0.0im 0.739183-0.196401im 0.739183+0.196401im 0.627138+0.0im; 0.821812+0.0im -0.501408-0.375337im -0.501408+0.375337im 1.0+0.0im])</code></pre><p>You have now solved your first nonlinear eigenvalue problem with NEP-PACK.</p><p>In order to verify that we have a solution, we can check that  <span>$M(λ)$</span> is singular, with a singular vector <span>$v$</span> such that <span>$M(λ)v=0$</span>:</p><pre><code class="language-julia-repl">julia&gt; λ1=λ[1]; v1=v[:,1];
julia&gt; using LinearAlgebra # the norm-function is in this Julia package
julia&gt; norm(A0*v1+λ1*A1*v1+λ1^2*v1)/norm(v1)
1.1502634749464687e-14</code></pre><h1><a class="nav-anchor" id="Accessing-more-complicated-applications-1" href="#Accessing-more-complicated-applications-1">Accessing more complicated applications</a></h1><p>We have made benchmark examples available through the function <a href="gallery/#NonlinearEigenproblems.nep_gallery"><code>nep_gallery</code></a>:</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; size(nep)
(100, 100)
julia&gt; λ,v=mslp(nep,tol=1e-10);
julia&gt; λ
0.23169217667341738 - 2.1866254654451488e-16im
julia&gt; size(v)
(100,)
julia&gt; resnorm=norm(compute_Mlincomb(nep,λ,v))
3.124042808475689e-14</code></pre><p>Information about the gallery can be found by typing <code>?nep_gallery</code>. The second arument in the call to <code>nep_gallery</code> is a problem parameter, in this case specifying that the  size of the problem should be <code>100</code>. The example solves the problem with the NEP-algorithm <a href="methods/#NonlinearEigenproblems.NEPSolver.mslp"><code>MSLP</code></a>. The parameter <code>tol</code> specifies the tolerance for iteration termination.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>All the NEP-solvers have considerble documentation easily available. Every NEP-solver has documentation accompanied with at least one example, and references to corresponding research papers, which we strongly recommend you to cite if you use the method. This is available to you in Julia&#39;s repl-prompt. Type <code>?mslp</code> and you will see an example how to use <code>mslp</code> and that citation credit should go to <em>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</em>. This documentation is the same as the online documentation under the tab <a href="methods/">NEP Methods</a>.</p></div></div><h1><a class="nav-anchor" id="A-model-of-a-neuron-1" href="#A-model-of-a-neuron-1">A model of a neuron</a></h1><p>The following (delay) differential equation models a neuron</p><div>\[\dot{x}_1(t)=-\kappa x_1(t)+\beta\tanh(x_1(t-\tau_3))+a_1\tanh(x_2(t-\tau_2))\]</div><div>\[\dot{x}_2(t)=-\kappa x_2(t)+\beta\tanh(x_2(t-\tau_3))+a_2\tanh(x_1(t-\tau_1))\]</div><p>See <a href="https://www.jstor.org/stable/3061744?seq=1#page_scan_tab_contents">L. P. Shayer and S. A. Campbell.  Stability, bifurcation and multistability in a system of two coupled neurons with multiple time delays. SIAM J. Applied Mathematics , 61(2):673–700, 2000</a>. It is also available as a first demo in <a href="https://sourceforge.net/projects/ddebiftool/">DDE-BIFTOOL</a>. The linear stability analysis of this problem requires the solution of a nonlinear eigenvalue problem</p><div>\[M(λ)=-λI+A_0+A_1e^{-\tau_1λ}+A_2e^{-\tau_2λ}+A_3e^{-\tau_3λ}\]</div><p>where the matrices are the Jacobian at the stationary solution. For the zero stationary solution, the matrices are</p><pre><code class="language-julia-repl">kappa=0.5; a2=2.34; a1=1; beta=-1;
A0=-kappa*[1 0; 0 1];
A1=a2*[0 0; 1 0];
A2=a1*[0 1; 0 0];
A3=beta*[1 0; 0 1];</code></pre><p>We can now create the nonlinear eigenvalue problem and compute the stability by first creating the problem</p><pre><code class="language-julia-repl">julia&gt; tauv=[0;0.2;0.2;1.5];
julia&gt; dep=DEP([A0, A1,   A2, A3],tauv);</code></pre><p>The constructor  <a href="types/#DEP-1"><code>DEP</code></a> is an abbreviation for a delay eigenvalue problem, which is a NEP with exponential terms stemming from the stability analysis of a delay-differential equation. See <a href="types/"><code>types</code></a> for other NEP-types. You can now solve this NEP, for instance, with the <a href="methods/#NonlinearEigenproblems.NEPSolver.iar_chebyshev">infinite Arnoldi method</a>:</p><pre><code class="language-julia-repl">julia&gt; λ,V=iar_chebyshev(dep,maxit=100); # This takes some time the first time is run due to JIT-compiler</code></pre><p>The figure in a demo of DDE-BIFTOOL <a href="http://ddebiftool.sourceforge.net/demos/neuron/html/demo1_stst.html#3">http://ddebiftool.sourceforge.net/demos/neuron/html/demo1_stst.html#3</a> can be directly generated by</p><pre><code class="language-julia">using PyPlot
plot(real(λ),imag(λ),&quot;*&quot;);
xlabel(&quot;real(λ)&quot;); ylabel(&quot;imag(λ)&quot;);</code></pre><pre><code class="language-none">┌ Warning: No working GUI backend found for matplotlib
└ @ PyPlot ~/.julia/packages/PyPlot/cdCMF/src/init.jl:155</code></pre><p><img src="neuron_eigvals.svg" alt/></p><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>This problem is also available in the <code>Gallery</code> by calling <code>dep=nep_gallery(&quot;neuron0&quot;)</code>. Most of the NEPs constructed in the tutorials are also available in corresponding gallery problems. See all gallery problems under <a href="gallery/">NEP Gallery</a>. In particular, note that the problems in the Berlin-Manchester collection of problems NLEVP are also <a href="gallery/#Berlin-Manchester-collection-1">directly available</a>.</p></div></div><h1><a class="nav-anchor" id="The-&quot;gun&quot;-benchmark-problem-1" href="#The-&quot;gun&quot;-benchmark-problem-1">The &quot;gun&quot; benchmark problem</a></h1><p>One of the most common benchmark problems for NEPs is the so-called &quot;gun&quot;-problem. It models an electromagnetic cavity, and it is directly available in the NEP-PACK gallery. (See <a href="gallery/#NonlinearEigenproblems.Gallery.nep_gallery">gallery</a> references or type <code>?nep_gallery</code> at the repl-prompt.) This is how you can set it up and solve it with the <a href="methods/#NonlinearEigenproblems.NEPSolver.blocknewton">block Newton method</a>:</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;nlevp_native_gun&quot;);
julia&gt; n=size(nep,1)
julia&gt; S=150^2*[1.0 0; 0 1]; V=[[1 0; 0 1]; zeros(n-2,2)];
julia&gt; (Z,X)=blocknewton(nep,S=S,X=V,logger=1,armijo_factor=0.5,maxit=20)
Iteration 1: Error: 6.081316e+03
Iteration 2: Error: 1.701970e-02 Armijo scaling=0.031250
Iteration 3: Error: 1.814887e-02 Armijo scaling=0.250000
...
Iteration 13: Error: 6.257442e-09
Iteration 14: Error: 2.525942e-15</code></pre><p>This algorithm returns a partial Schur factorization of the NEP, and therefore the eigenvalues of the small matrix <code>Z</code> are eigenvalues of the problem. An eigenpair of the NEP can be extracted by diagonalizing:</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra
julia&gt; (Λ,P)=eigen(Z);
julia&gt; VV=X*P;  # Construct the eigenvector matrix
julia&gt; v=VV[:,1]; λ=Λ[1]
61330.208714730004 + 63185.15983933589im
julia&gt; norm(compute_Mlincomb(nep,λ,v)) # Very small residual
1.8270553408452648e-16</code></pre><p>If you use the NEP-algorithms for research, please give the author of the algorithm credit by citiation. The recommended citation can be found in the function documentation, e.g., <code>?blocknewton</code>.</p><h1><a class="nav-anchor" id="Your-own-NEP-nonlinearity-1" href="#Your-own-NEP-nonlinearity-1">Your own NEP nonlinearity</a></h1><p>As an application researcher, we recommend that you first try to express your problem in the following form since it gives access to several efficient routines associated with the NEP, in turn making it possible to use many NEP-solvers. A problem that can be expressed as a (short) <strong>S</strong>um of <strong>P</strong>roducts of <strong>M</strong>atrices and <strong>F</strong>unctions can be represented with the objects of type <a href="types/#SPMF-1"><code>SPMF</code></a> in NEP-PACK. For instance, a problem with three terms</p><div>\[M(λ) = A+λB+e^{\sin(λ/2)}C\]</div><p>can be created by</p><pre><code class="language-julia-repl">julia&gt; A=(1:4)*(1:4)&#39;+I; B=diagm(1 =&gt; [1,2,3]); C=ones(4,4);
julia&gt; f1= λ-&gt; one(λ);
julia&gt; f2= λ-&gt; λ;
julia&gt; f3= λ-&gt; exp(sin(λ/2))
julia&gt; nep=SPMF_NEP([A,B,C],[f1,f2,f3]);</code></pre><p>The NEP can now be solved with many algorithms, e.g.,</p><pre><code class="language-julia-repl">julia&gt; λ,v=quasinewton(nep,λ=3)
(3.176099007141426 + 0.0im, Complex{Float64}[37.1759+0.0im, -21.3016+0.0im, 0.0937992+0.0im, -1.15711+0.0im])</code></pre><p>Note that the functions <code>f1</code>,<code>f2</code> and <code>f3</code> have to be defined for scalar values and for matrices (in the matrix function sense, not elementwise sense). This is the reason <code>f1</code> needs to be defined as <code>one(λ)</code>, instead of just <code>1</code>.</p><p>As usual, you can check that we computed a sensible solution:</p><pre><code class="language-julia-repl">julia&gt; (A+B*λ+C*exp(sin(λ/2)))*v
4-element Array{Complex{Float64},1}:
  -6.586145128765412e-14 + 0.0im
  2.8285461200559146e-14 + 0.0im
 -4.1550357082583515e-14 + 0.0im
  -8.815768150428286e-15 + 0.0im</code></pre><h1><a class="nav-anchor" id="What-now?-1" href="#What-now?-1">What now?</a></h1><p>Now you are ready to try out <a href="movebc_tutorial/">the tutorial on artificial boundary conditions</a> or on <a href="bemtutorial/">the boundary element method</a> or have a look at the examples in <a href="methods/">NEP methods</a> and  <a href="gallery/">NEP Gallery</a>.</p><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC" alt="To the top"/></p><footer><hr/><a class="next" href="methods/"><span class="direction">Next</span><span class="title">NEP Methods</span></a></footer></article></body></html>
