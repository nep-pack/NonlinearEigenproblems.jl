<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>NEP-Solvers · NEP-PACK</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NEP-PACK</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>NEP-Solvers</a><ul class="internal"><li><a class="tocitem" href="#Newton-type-methods"><span>Newton type methods</span></a></li><li><a class="tocitem" href="#Projection-methods"><span>Projection methods</span></a></li><li><a class="tocitem" href="#Contour-integral-methods"><span>Contour integral methods</span></a></li><li><a class="tocitem" href="#Arnoldi-and-Krylov-based-methods"><span>Arnoldi and Krylov based methods</span></a></li><li><a class="tocitem" href="#Class-specific-methods"><span>Class specific methods</span></a></li></ul></li><li><a class="tocitem" href="../types/">Types &amp; Data structures</a></li><li><a class="tocitem" href="../compute_functions/">Compute functions</a></li><li><a class="tocitem" href="../linsolvers/">Linear solvers</a></li><li><a class="tocitem" href="../innersolvers/">Projection</a></li><li><a class="tocitem" href="../errmeasure/">Measuring the error</a></li><li><a class="tocitem" href="../logger/">Logger</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../deflation/">Deflation</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="tocitem" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="tocitem" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="tocitem" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="tocitem" href="../tutorial_call_python/">Tutorial 5 (Python 1)</a></li><li><a class="tocitem" href="../tutorial_python_call/">Tutorial 6 (Python 2)</a></li><li><a class="tocitem" href="../tutorial_matlab1/">Tutorial 7 (MATLAB)</a></li><li><a class="tocitem" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="tocitem" href="../tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="tocitem" href="../tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li><a class="tocitem" href="../tutorial_linsolve/">Tutorial 11 (Linear solvers)</a></li><li><a class="tocitem" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>NEP-Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>NEP-Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="NEP-Solvers"><a class="docs-heading-anchor" href="#NEP-Solvers">NEP-Solvers</a><a id="NEP-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#NEP-Solvers" title="Permalink"></a></h1><p>The NEP solver methods implemented in NEP-PACK, are accessed by the functions below. The functions all return <span>$λ,v$</span> where <span>$λ$</span> is either a number (eigenvalue) a vector of eigenvalues <span>$v$</span> is either a vector containing an eigenvector or a matrix whose columns corresponding to the eigenvectors. Two-sided methods may return <span>$λ,v,w$</span> where <span>$w$</span> are the left eigenvectors.</p><p>The first optional parameter in all NEP solver methods is a type. This type specifies which arithmetic should be used for the algorithm.</p><p>Example:</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; λ,v=augnewton(ComplexF64,nep,v=ones(5))
(-0.15955391823299256 + 0.0im, Complex{Float64}[0.12505315954062152 + 0.0im, 0.8475907515488971 + 0.0im, -0.10910413290558324 + 0.0im, 0.027714719799174125 + 0.0im, 0.10874550201689052 + 0.0im])
julia&gt; typeof(λ)
Complex{Float64}
julia&gt; λ,v=augnewton(Float16,nep,v=ones(5))
(Float16(-0.718), Float16[0.435, 0.6606, -0.205, -0.1445, 0.254])
julia&gt; typeof(λ)
Float16</code></pre><p>The NEP-solvers can be separated into the following types (with some overlap):</p><ul><li><a href="#Newton-type-methods-1">Newton type methods</a></li><li><a href="#Projection-methods-1">Projection methods</a></li><li><a href="#Contour-integral-methods-1">Contour integral methods</a></li><li><a href="#Arnoldi-and-Krylov-based-methods-1">Arnoldi and Krylov based methods</a></li><li><a href="#Class-specific-methods-1">Class specific methods</a></li></ul><h2 id="Newton-type-methods"><a class="docs-heading-anchor" href="#Newton-type-methods">Newton type methods</a><a id="Newton-type-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Newton-type-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.newton" href="#NonlinearEigenproblems.NEPSolver.newton"><code>NonlinearEigenproblems.NEPSolver.newton</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">λ,v = newton([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][logger,][armijo_factor=1,][armijo_max])</code></pre><p>Applies Newton-Raphsons method on the system of nonlinear equations with <code>n+1</code> unknowns:</p><p class="math-container">\[M(λ)v=0\]</p><p class="math-container">\[c^Hv-1=0\]</p><p>The vector <code>c</code> is the orthogonalization vector.  If <code>c=0</code> the current approximation will be used for the orthogonalization. See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra
julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; λ,v=newton(nep);
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
1.9997125567227177e-16</code></pre><p><strong>References</strong></p><ul><li>Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.</li><li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_newton.jl#L17-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.augnewton" href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>NonlinearEigenproblems.NEPSolver.augnewton</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">augnewton([eltype], nep::NEP; [errmeasure,][tol,][maxit,][λ,][v,][c,][logger,][linsolvercreator,][armijo_factor,][armijo_max])</code></pre><p>Run the augmented Newton method. The method is equivalent to <code>newton()</code> in exact arithmetic,  but works only with operations on vectors of length <code>n</code>.</p><p>The following keyword arguments are in common for many NEP-solvers:</p><ul><li><p><code>logger</code> is either a <a href="../logger/#NonlinearEigenproblems.NEPCore.Logger"><code>Logger</code></a> object or an <code>Int</code>. If it is an <code>Int</code>, a <code>PrintLogger(logger)</code> will be instantiated. <code>logger=0</code> prints nothing, <code>logger=1</code> prints more, etc.</p></li><li><p><code>errmeasure</code> determines how error is measured. It is either a function handle or an object of the type <code>Errmeasure</code>.  If it is a function handle, it should take <code>(λ,v)</code> as input and return a real scalar (the error). See <a href="../errmeasure/#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a> and <a href="../errmeasure/#NonlinearEigenproblems.NEPTypes.ErrmeasureType"><code>ErrmeasureType</code></a> for further description.</p></li><li><p><code>tol</code> is a scalar which determines termination. If <code>errmeasure</code> is less than <code>tol</code> the eigenpair is marked as converged.</p></li><li><p>The scalar <code>λ</code> and the vector <code>v</code> are starting approximations.</p></li><li><p><code>maxit</code> determines the maximum number of iterations. The error <code>NoConvergenceException</code> is thrown if this is exceeded.</p></li><li><p>The <code>linsolvecreator</code> specifies how the linear system should be solved. See <a href="../linsolvers/#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a> for further information.</p></li><li><p><code>armijo_factor</code> specifies if an Armijo rule should be applied, and its value specifies the scaling factor of the step length (per reduction step). The variable <code>armijo_max</code> specifies the maximum number of step length reductions.</p></li></ul><p><strong>Example</strong></p><p>This illustrates the equivalence between <code>newton</code> and <code>augnewton</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep1&quot;)
julia&gt; λ1,v1=newton(nep,maxit=20,v=ones(size(nep,1)),λ=0)
julia&gt; λ2,v2=augnewton(nep,maxit=20,v=ones(size(nep,1)),λ=0)
julia&gt; λ1-λ2
0.0 + 0.0im</code></pre><p><strong>References</strong></p><ul><li>Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.</li><li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_newton.jl#L233-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.resinv" href="#NonlinearEigenproblems.NEPSolver.resinv"><code>NonlinearEigenproblems.NEPSolver.resinv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">λ,v = resinv([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][logger,][armijo_factor=1,][armijo_max,][linsolvecreator])</code></pre><p>Applies residual inverse iteration method for nonlinear eigenvalue problems. The kwarg <code>linsolvecreator</code> is a function which specifies how the linear system is created. The function calls <code>compute_rf</code> for the computation of the Rayleigh functional. See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><p>The example shows how to specify if the method should run in real or complex mode (or any other <code>Number</code> type).</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; λ,v=resinv(nep,λ=-2,v=ones(size(nep,1)))
julia&gt; typeof(λ)
Complex{Float64}
julia&gt; norm(compute_Mlincomb(nep,λ,v))
6.688224435370382e-12
julia&gt; λ,v=resinv(Float64,nep,λ=-2,v=ones(size(nep,1)))
julia&gt; typeof(λ)
Float64
julia&gt; norm(compute_Mlincomb(nep,λ,v))
5.939894690000396e-12</code></pre><p><strong>References</strong></p><ul><li>A. Neumaier, Residual inverse iteration for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 22 (1985) 914-923</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_newton.jl#L110-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.quasinewton" href="#NonlinearEigenproblems.NEPSolver.quasinewton"><code>NonlinearEigenproblems.NEPSolver.quasinewton</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quasinewton([T=ComplexF64],nep,[errmeasure,][tol,][maxit,][λ,][v][ws][logger][linsolvercreator,][armijo_factor,][armijo_max])</code></pre><p>An implementation of the quasi-Newton approach referred to as quasi-Newton 2 in the reference. The method involves one linear system solve per iteration corresponding with the matrix <span>$M(λ)$</span>, where <span>$λ$</span> is constant. The vector <code>ws</code> is a representation of the normalization, in the sense that <span>$c^T=w_s^TM(λ)$</span>, where all iterates satisfy <span>$c^Tx_i=1$</span>. See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; λ,v=quasinewton(nep,λ=1.0,v=ones(size(nep,1)));
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v)
5.448264607410413e-12</code></pre><p><strong>References</strong></p><ul><li>Jarlebring, Koskela, Mele, Disguised and new Quasi-Newton methods for nonlinear eigenvalue problems, Numer. Algorithms, 79:311-335, 2018. <a href="https://arxiv.org/abs/1702.08492">preprint</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_newton.jl#L351-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.mslp" href="#NonlinearEigenproblems.NEPSolver.mslp"><code>NonlinearEigenproblems.NEPSolver.mslp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> mslp([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][logger,][eigsolvertype::Type])</code></pre><p>Runs the method of successive linear problems. The  method requires the solution of a generalized eigenvalue problem in every iteration. The method used for the eigenvalue computation is specified in eigsolvertype. See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><p>Create a rational NEP using a <a href="../types/#NonlinearEigenproblems.NEPTypes.SPMF_NEP"><code>SPMF_NEP</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; eye=Matrix{Float64}(I,3,3);
julia&gt; Av=[ones(3,3),eye,triu(ones(3,3))];
julia&gt; fv=[S-&gt; S, S -&gt; S^2, S-&gt;inv(S-one(S)*10)];
julia&gt; nep=SPMF_NEP(Av,fv);
julia&gt; (λ,v)=mslp(nep);
julia&gt; compute_Mlincomb(nep,λ,v)
3-element Array{Complex{Float64},1}:
 -1.38778e-17+1.65715e-18im
 -5.55112e-17+1.30633e-17im
 -4.16334e-17-1.54436e-17im</code></pre><p><strong>References</strong></p><ul><li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_mslp.jl#L7-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.sgiter" href="#NonlinearEigenproblems.NEPSolver.sgiter"><code>NonlinearEigenproblems.NEPSolver.sgiter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">λ,v = sgiter([eltype],nep::NEP,j::Integer;[λ_min,][λ_max,][λ,][errmeasure,][tol,][maxit,][logger,][eigsolvertype::Type,])</code></pre><p>Finds the <code>j</code>-th eigenvalue of the NEP using safeguarded iteration, with eigenvalue numbering according to min-max theory. The method only works for Hermitian problems, and the eigenvalues are assumed to be real. If an interval [<code>λ_min</code>,<code>λ_max</code>] is given, then the Rayleigh functional is assumed to be unique on the interval. If no interval is given, then the minimum solution is always taken. The method requires the computation of (all) eigenvalues of a matrix. The <code>eigsolvertype</code> is a <code>Type</code> that specifies which eigevalue solver is used inside the algorithm.</p><p>See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep = nep_gallery(&quot;real_quadratic&quot;);
julia&gt; λ,v = sgiter(nep, 1, λ_min = -10, λ_max = 0,  λ = -10, maxit = 100);
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
0.0
julia&gt; norm(v)
1.0</code></pre><p><strong>References</strong></p><ul><li>V. Mehrmann and H. Voss, Nonlinear eigenvalue problems: a challenge for modern eigenvalue methods, GAMM‐Mitteilungen 27.2 (2004): 121-152.</li><li>H. Voss and B. Werner, Solving sparse nonlinear eigenvalue problems. Technical Report 82/4, Inst. f. Angew. Mathematik, Universität Hamburg, 1982.</li><li>B. Werner. Das Spektrum von Operatorenscharen mit verallgemeinerten Rayleighquotienten. PhD thesis, Fachbereich Mathematik, Universität Hamburg, 1970</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_sgiter.jl#L3-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.rfi" href="#NonlinearEigenproblems.NEPSolver.rfi"><code>NonlinearEigenproblems.NEPSolver.rfi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rfi(nep,nept,[λ=0,][errmeasure,][tol=eps()*100,][maxit=100,][v=randn,][u=randn,][logger=0,][linsolvecreator=DefaultLinSolverCreator(),])</code></pre><p>This is an implementation of the two-sided Rayleigh functional Iteration (RFI) to compute an eigentriplet of the problem specified by <code>nep</code>. This method requires the transpose of the NEP, specified in <code>nept</code>. <code>λ</code>, <code>u</code> and <code>v</code> are initial guesses for the eigenvalue, the right eigenvector and the left eigenvector respectively. See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; nept=DEP([nep.A[1]&#39;,nep.A[2]&#39;])
julia&gt; λ,v,u=rfi(nep,nept)
julia&gt; compute_resnorm(nep,λ,v) # v is a right eigenvector
3.0171586304599647e-16
julia&gt; compute_resnorm(nept,λ,u) # u is a right eigenvector
7.145081514857076e-17</code></pre><p><strong>Reference</strong></p><ul><li>Algorithm 4 in  Schreiber, Nonlinear Eigenvalue Problems: Newton-type Methods and Nonlinear Rayleigh Functionals, PhD thesis, TU Berlin, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_rfi.jl#L7-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.rfi_b" href="#NonlinearEigenproblems.NEPSolver.rfi_b"><code>NonlinearEigenproblems.NEPSolver.rfi_b</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rfi_b(nep,nept,[λ=0,][errmeasure,][tol=eps()*100,][maxit=100,][v=randn,][u=randn,][logger=0,][linsolvecreator=DefaultLinSolverCreator(),])</code></pre><p>This is an implementation of the two-sided Rayleigh functional Iteration(RFI)-Bordered version to compute an eigentriplet of the problem specified by <code>nep</code>. This method requires the transpose of the NEP, specified in <code>nept</code>. <code>λ</code>, <code>u</code> and <code>v</code> are initial guesses for the eigenvalue, the right eigenvector and the left eigenvector respectively. See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; nept=DEP([nep.A[1]&#39;,nep.A[2]&#39;])
julia&gt; λ,v,u=rfi_b(nep,nept,v=ones(ComplexF64,size(nep,1)))
julia&gt; compute_resnorm(nep,λ,v) # v is a right eigenvector
5.343670589284583e-15</code></pre><p><strong>Reference</strong></p><ul><li>Algorithm 5 in  Schreiber, Nonlinear Eigenvalue Problems: Newton-type Methods and Nonlinear Rayleigh Functionals, PhD thesis, TU Berlin, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_rfi.jl#L79-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.blocknewton" href="#NonlinearEigenproblems.NEPSolver.blocknewton"><code>NonlinearEigenproblems.NEPSolver.blocknewton</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(S,X)=blocknewton(nep [S,] [X,] [errmeasure,] [tol,] [maxit,] [armijo_factor,] [armijo_max,] [logger])</code></pre><p>Applies the block Newton method to <code>nep::AbstractSPMF</code>. The method computes an invariant pair <code>(S,X)</code> using the block Newton approach of Kressner. The variables <code>S</code>,<code>X</code> correspond to starting approximations. The function <code>errmeasure</code> shoule be defined for errmeasure(S,X) and meausures the error in the pair <code>(S,X)</code>. See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><p>The example shows that <code>compute_MM()</code> becomes zero when a solution has been computed.</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;,3);
julia&gt; (S,X)= blocknewton(nep)
julia&gt; compute_MM(nep,S,X)
3×2 Array{Complex{Float64},2}:
 -1.11022e-16+0.0im  1.11022e-16+0.0im
          0.0+0.0im          0.0+0.0im
  1.38778e-17+0.0im  2.77556e-17+0.0im</code></pre><p>This example solves the <code>gun</code> problem from the Berlin-Manchester collection</p><pre><code class="language-julia-repl hljs">julia&gt; using NonlinearEigenproblems.Gallery
julia&gt; nep=nep_gallery(&quot;nlevp_native_gun&quot;);
julia&gt; II=[1.0 0; 0 1]; S=150^2*II; V=[II;zeros(size(nep,1)-2,2)];
julia&gt; (Z,X)=blocknewton(nep,S=S,X=V,logger=1,armijo_factor=0.5,maxit=20)
Iteration 1: Error: 6.081316e+03
Iteration 2: Error: 1.701970e-02 Armijo scaling=0.031250
Iteration 3: Error: 1.814887e-02 Armijo scaling=0.250000
...
Iteration 13: Error: 6.257442e-09
Iteration 14: Error: 2.525942e-15</code></pre><p><strong>References</strong></p><ul><li>D. Kressner A block Newton method for nonlinear eigenvalue problems, Numer. Math., 114 (2) (2009), pp. 355-372</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_blocknewton.jl#L7-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.newtonqr" href="#NonlinearEigenproblems.NEPSolver.newtonqr"><code>NonlinearEigenproblems.NEPSolver.newtonqr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">λ,v = newtonqr([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][logger])</code></pre><p>This function implements the Newton-QR method as formulated in the reference. The method involves the computation of a rank-revealing QR factorization of <span>$M(λ)$</span>, with the idea that on convergence the the last diagonal element <span>$R[n,n]$</span> of the upper-triangular matrix <span>$R$</span> becomes zero as a result of <span>$M(λ)$</span> becoming singular. Since the computation of a QR factorization is expensive, it is advisable to use this method for problems of small size or problems with a certain structure that makes the QR computation less expensive. See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; λ,v=newtonqr(nep,v=ones(size(nep,1)));
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v)
8.440206093655014e-15</code></pre><p><strong>References</strong></p><ul><li>Kublanovskaya, V. N., (1970).  On an approach to the solution of the generalized latent value problem for λ-matrices, SIAM J. Numer. Anal. 7, 532–537</li><li>Güttel, S., &amp; Tisseur, F. (2017). The nonlinear eigenvalue problem. Acta Numerica, 26, 1-94. doi:10.1017/S0962492917000034</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_newton.jl#L448-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.implicitdet" href="#NonlinearEigenproblems.NEPSolver.implicitdet"><code>NonlinearEigenproblems.NEPSolver.implicitdet</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">λ,v = implicitdet([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][logger])</code></pre><p>This function implements the Implicit determinant method as formulated Algorithm 4.3 in the reference. The method applies Newton-Raphson to the equation <span>$det(M(λ))/det(G(λ)) = 0$</span>, where <span>$G(λ)$</span> is a saddle point matrix with <span>$M(λ)$</span> in the (1,1) block. The (2,1) and (1,2) blocks of <span>$G(λ)$</span> are set to <span>$c^H$</span> and <span>$c$</span> respectively. Note that <span>$G(λ)$</span> can be non-singular even when <span>$M(λ)$</span> is singular. See reference for more information. See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; λ,v=implicitdet(nep,v=ones(size(nep,1)));
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v)
2.566371972986362e-14</code></pre><p><strong>References</strong></p><ul><li>Spence, A., &amp; Poulton, C. (2005). Photonic band structure calculations using nonlinear eigenvalue techniques, J. Comput. Phys., 204 (2005), pp. 65–8</li><li>Güttel, S., &amp; Tisseur, F. (2017). The nonlinear eigenvalue problem. Acta Numerica, 26, 1-94. doi:10.1017/S0962492917000034</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_newton.jl#L527-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.broyden" href="#NonlinearEigenproblems.NEPSolver.broyden"><code>NonlinearEigenproblems.NEPSolver.broyden</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">S,V = broyden([eltype,]nep::NEP[,approxnep];kwargs)</code></pre><p>Runs Broydens method (with deflation) for the nonlinear eigenvalue problem defined by nep. An approximate nep can be provided which is used as an initialization of starting matrix/vectors. The optional argument <code>approxnep</code> determines how  to initiate the algorithm. It can be an <code>NEP</code>, the symbol <code>:eye</code> corresponding to starting with an identity matrix, and a <code>Matrix</code> (of size <span>$n	imes n$</span>). Beside most of the standard kwargs as described in <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a>, it supports <code>pmax</code> which is subspace used in deflation, essentially the number of eigenvalues, <code>add_nans::Bool</code>  which determines if <code>NaNs</code> should be added in book keeping. <code>eigmethod</code> which can be <code>:eig</code>, <code>:eigs</code> or <code>:invpow</code>. The <code>:invpow</code> is an implementation of the power method, which is slow but works well e.g. for <code>BigFloat</code>. The kwarg <code>recompute_U</code> determines if the <code>U</code>-matrix should be recomputed in every deflation (which can be more robust). The implementation has two loggers <code>logger</code> and <code>inner_logger</code>. The <code>logger</code> corresponds to outer iterations (deflation) and  <code>inner_logger</code> is the iterates in Broydens method. The kwarg <code>check_error_every</code> and <code>print_error_every</code>   detemine how often errors should be check and how often they should be printed. For real problems with complex conjugate symmetry, you may want to set the kwarg <code>addconj=true</code> in order to reduce computation by automatically adding the complex conjugate vectors.</p><p>The method computes an invariant pair and can therefore find several eigenvalues. The retured value is (S,V) is an invariant pair and the eigenvalues are on the diagonal of S. Eigenpairs can be directly extracted with <a href="../deflation/#NonlinearEigenproblems.NEPTypes.get_deflated_eigpairs"><code>get_deflated_eigpairs</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; S,V=broyden(nep);
julia&gt; λ=S[1,1]
-0.15955391823299253 - 3.874865266487398e-19im
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
1.6293996560844023e-16
julia&gt; λ=S[2,2]
-0.5032087003825461 + 1.1969823800738464im
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
1.1073470346550144e-15
julia&gt; λ=S[3,3]
1.2699713558173726 + 5.342786996459857e-16im
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
5.905315846211231e-16
julia&gt; broyden(nep,logger=2,check_error_every=1);  # Prints out a lot more convergence info</code></pre><p>In order to extract eigenpairs you can use the following:</p><pre><code class="language-julia-repl hljs">julia&gt; (D,X)=get_deflated_eigpairs(S,V,size(nep,1));
julia&gt; for i=1:3; @show norm(compute_Mlincomb(nep,D[i],X[:,i])); end
norm(compute_Mlincomb(nep, D[i], X[:, i])) = 8.459878994614521e-13
norm(compute_Mlincomb(nep, D[i], X[:, i])) = 1.2102336671048442e-13
norm(compute_Mlincomb(nep, D[i], X[:, i])) = 2.1012363973403225e-16</code></pre><p><strong>References</strong></p><ul><li>Jarlebring, Broyden’s method for nonlinear eigenproblems, SIAM J. Sci. Comput., 41:A989–A1012, 2019, https://arxiv.org/pdf/1802.07322</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_broyden.jl#L158-L231">source</a></section></article><h2 id="Projection-methods"><a class="docs-heading-anchor" href="#Projection-methods">Projection methods</a><a id="Projection-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Projection-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.nlar" href="#NonlinearEigenproblems.NEPSolver.nlar"><code>NonlinearEigenproblems.NEPSolver.nlar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function nlar([eltype],nep::ProjectableNEP,[orthmethod=ModifiedGramSchmidt()],[neigs=10],[errmeasure],[tol=eps(real(T))*100],[maxit=100],[0=0],[v=randn(T,size(nep,1))],[logger=0],[linsolvercreator=DefaultLinSolverCreator()],[R=0.01],[eigval_sorter=residual_eigval_sorter],[qrfact_orth=false],[max_subspace=100],[num_restart_ritz_vecs=8],[inner_solver_method=DefaultInnerSolver(),][inner_logger=0])</code></pre><p>The function implements the Nonlinear Arnoldi method, which finds <code>neigs</code> eigenpairs (or throws a <code>NoConvergenceException</code>) by projecting the problem to a subspace that is expanded in the course  of the algorithm. The basis is orthogonalized either by using the QR method if <code>qrfact_orth</code> is <code>true</code> or else by an orthogonalization method <code>orthmethod</code>). This entails solving a smaller projected problem using a method specified by <code>inner_solver_method</code>. The logging of the inner solvers are descided by <code>inner_logger</code>, which works in the same way as <code>logger</code>. (<code>λ</code>,<code>v</code>) is the initial guess for the eigenpair. <code>linsolvercreator</code> specifies how the linear system is created and solved. <code>R</code> is a parameter used by the function specified by <code>eigval_sorter</code> to reject those ritz values that are within a distance <code>R</code> from any of the converged eigenvalues, so that repeated convergence to the same eigenpair can be avoided. <code>max_subspace</code> is the maximum allowable size of the basis befor the algorithm restarts using a basis made of <code>num_restart_ritz_vecs</code> ritz vectors and the eigenvectors that the algorithm has converged to.</p><p>See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0_tridiag&quot;);
julia&gt; λ,v=nlar(nep,tol=1e-7,neigs=1,maxit=100,v=ones(size(nep,1)));
julia&gt; norm(compute_Mlincomb(nep,λ[1],v))
8.00192341259751e-7</code></pre><p><strong>References</strong></p><ul><li>H. Voss, An Arnoldi method for nonlinear eigenvalue problems. BIT. Numer. Math. 44: 387-401, 2004.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_nlar.jl#L12-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.jd_betcke" href="#NonlinearEigenproblems.NEPSolver.jd_betcke"><code>NonlinearEigenproblems.NEPSolver.jd_betcke</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jd_betcke([eltype]], nep::ProjectableNEP; [neigs=1], [tol=eps(real(T))*100], [maxit=100], [λ=zero(T)], [orthmethod=DGKS],  [errmeasure], [linsolvercreator=DefaultLinSolverCreator()], [v = randn(size(nep,1))], [logger=0], [inner_logger=0], [inner_solver_method=DefaultInnerSolver()], [projtype=:PetrovGalerkin], [target=zero(T)])</code></pre><p>The function computes eigenvalues using Jacobi-Davidson method, which is a projection method. The projected problems are solved using a solver spcified through the type <code>inner_solver_method</code>. The logging of the inner solvers are descided by <code>inner_logger</code>, which works in the same way as <code>logger</code>. For numerical stability the basis is kept orthogonal, and the method for orthogonalization is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The function tries to compute <code>neigs</code> number of eigenvalues, and throws a <code>NoConvergenceException</code> if it cannot. The value <code>λ</code> and the vector <code>v</code> are initial guesses for an eigenpair. <code>linsolvercreator</code> is a function which specifies how the linear system is created and solved. The <code>target</code> is the center around which eiganvlues are computed. By default the method uses a Petrov-Galerkin framework, with a trial (left) and test (right) space, hence <span>$W^H T(λ) V$</span> is the projection considered. By specifying  <code>projtype</code> to be <code>:Galerkin</code> then <code>W=V</code>.</p><p>See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;,50);
julia&gt; λ,v=jd_betcke(nep,tol=1e-8,maxit=20);
julia&gt; norm(compute_Mlincomb(nep,λ[1],v[:,1]))
1.9570222439914163e-10</code></pre><p><strong>References</strong></p><ul><li>T. Betcke and H. Voss, A Jacobi-Davidson-type projection method for nonlinear eigenvalue problems. Future Gener. Comput. Syst. 20, 3 (2004), pp. 363-372.</li><li>H. Voss, A Jacobi–Davidson method for nonlinear eigenproblems. In: International Conference on Computational Science. Springer, Berlin, Heidelberg, 2004. pp. 34-41.</li></ul><p>See also</p><ul><li>C. Effenberger, Robust successive computation of eigenpairs for nonlinear eigenvalue problems. SIAM J. Matrix Anal. Appl. 34, 3 (2013), pp. 1231-1256.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_jd.jl#L23-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.jd_effenberger" href="#NonlinearEigenproblems.NEPSolver.jd_effenberger"><code>NonlinearEigenproblems.NEPSolver.jd_effenberger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jd_effenberger([eltype]], nep::ProjectableNEP; [maxit=100], [neigs=1], [inner_solver_method=DefaultInnerSolver()], [orthmethod=DGKS()], [linsolvercreator=DefaultLinSolverCreator()], [tol=eps(real(T))*100], [λ=zero(T)], [v = rand(T,size(nep,1))], [target=zero(T)],  [logger=0], [inner_logger=0])</code></pre><p>The function computes eigenvalues using the Jacobi-Davidson method, which is a projection method. Repreated eigenvalues are avoided by using deflation, as presented in the reference by Effenberger. The projected problems are solved using a solver spcified through the type <code>inner_solver_method</code>. The logging of the inner solvers are descided by <code>inner_logger</code>, which works in the same way as <code>logger</code>. For numerical stability the basis is kept orthogonal, and the method for orthogonalization is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The function tries to compute <code>neigs</code> number of eigenvalues, and throws a <code>NoConvergenceException</code> if it cannot. The value <code>λ</code> and the vector <code>v</code> are initial guesses for an eigenpair. <code>linsolvercreator</code> is a function which specifies how the linear system is created and solved. The <code>target</code> is the center around which eiganvalues are computed. For further specifications on the <code>deflation_mode</code>, see the function <code>deflate_eigpair</code>.</p><p>See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; λ,v=jd_effenberger(nep,maxit=30,v=ones(size(nep,1)),λ=0);
julia&gt; norm(compute_Mlincomb(nep,λ[1],v[:,1]))
9.577305772525487e-15</code></pre><p><strong>References</strong></p><ul><li>C. Effenberger, Robust successive computation of eigenpairs for nonlinear eigenvalue problems. SIAM J. Matrix Anal. Appl. 34, 3 (2013), pp. 1231-1256.</li></ul><p>See also</p><ul><li>T. Betcke and H. Voss, A Jacobi-Davidson-type projection method for nonlinear eigenvalue problems. Future Gener. Comput. Syst. 20, 3 (2004), pp. 363-372.</li><li>H. Voss, A Jacobi–Davidson method for nonlinear eigenproblems. In: International Conference on Computational Science. Springer, Berlin, Heidelberg, 2004. pp. 34-41.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_jd.jl#L187-L214">source</a></section></article><p>The following NEP-solvers can also be seen as projection methods:</p><ul><li><a href="#NonlinearEigenproblems.NEPSolver.iar"><code>iar</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.tiar"><code>tiar</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a>,</li><li><a href="#NonlinearEigenproblems.NEPSolver.nleigs"><code>nleigs</code></a>.</li></ul><h2 id="Contour-integral-methods"><a class="docs-heading-anchor" href="#Contour-integral-methods">Contour integral methods</a><a id="Contour-integral-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Contour-integral-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.contour_beyn" href="#NonlinearEigenproblems.NEPSolver.contour_beyn"><code>NonlinearEigenproblems.NEPSolver.contour_beyn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">λv,V=contour_beyn([eltype,] nep [,mintegrator];[tol,][logger,][σ,][radius,][linsolvercreator,][N,][neigs,][k])</code></pre><p>The function computes eigenvalues using Beyn&#39;s contour integral approach, using an ellipse centered at <code>σ</code> with radii given in <code>radius</code>, or if only one <code>radius</code> is given, the contour is a circle. The numerical quadrature method is specified in <code>mintegrator</code>, which is a type inheriting from <code>MatrixIntegrator</code>, by default <code>MatrixTrapezoidal</code>. For a parallell implementation of the integrator use <code>MatrixTrapezoidalParallel</code>.  The integer <code>k</code> specifies size of the probe subspace. <code>N</code> corresponds to the number of quadrature points. Ellipses are the only supported contours. The <code>linsolvercreator</code> must create a linsolver that can handle (rectangular) matrices as right-hand sides, not only vectors. We integrate in complex arithmetic so <code>eltype</code> must be complex type.</p><p>The kwargs <code>neigs</code> specifies the number of wanted eigvals, and <code>k</code> is the number of columns in the matrix to be integrated (default <code>k=neigs+1</code>). If you give the <code>k</code> parameter and set <code>neigs=typemax(Int)</code> all found eigenvalues will be returned. The kwarg <code>sanity_check</code> decides if sorting and checking (and removal) of eigpairs should be done. If disabled, the method returns <code>k</code> (potentially inaccurate) eigpairs. The parameters <code>errmeasure</code> and <code>tol</code> and <code>rank_drop_tol</code> are used for the sanity check, to extract accurate eigenvalues.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra
julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; # Look for two eigvals in unit disk
julia&gt; λv,V=contour_beyn(nep,radius=1.1,neigs=3);
julia&gt; norm(compute_Mlincomb(nep,λv[1],V[:,1])) # Eigenpair 1
1.7462847531404259e-15
julia&gt; norm(compute_Mlincomb(nep,λv[2],V[:,2])) # Eigenpair 2
7.69695692032292e-15</code></pre><p><strong>References</strong></p><ul><li>Wolf-Jürgen Beyn, An integral method for solving nonlinear eigenvalue problems, Linear Algebra and its Applications 436 (2012) 3839–3863</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_beyncontour.jl#L10-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.contour_block_SS" href="#NonlinearEigenproblems.NEPSolver.contour_block_SS"><code>NonlinearEigenproblems.NEPSolver.contour_block_SS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contour_block_SS([eltype,] nep [,mintegrator];[tol,][logger,][σ,][radius,][linsolvercreator,][N,][neigs,][k,][L])</code></pre><p>This is an implementation of the block_SS contour integral method which is based on the computation of higher order moments. The contour is an ellipse centered at <code>σ</code> with radii given in <code>radius</code>, or if only one <code>radius</code> is given, the contour is a circle. The numerical quadrature method is specified in <code>mintegrator</code>, which is a type inheriting from <code>MatrixIntegrator</code>, by default <code>MatrixTrapezoidal</code>. For a parallell implementation of the integrator use <code>MatrixTrapezoidalParallel</code>.  The integer <code>k</code> specifies size of the probe subspace. <code>N</code> corresponds to the number of quadrature points. The integer L specifies the number of moments. Ellipses are the only supported contours. The <code>linsolvercreator</code> must create a linsolver that can handle (rectangular) matrices as right-hand sides, not only vectors. We integrate in complex arithmetic so <code>eltype</code> must be complex type.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep=SPMF_NEP([[0 1 ; 1 1.0], [1 0 ; 0 0]], [s-&gt;one(s),s-&gt;exp(1im*s^2)]);
julia&gt; λ,V=contour_assu(nep,radius=3,neigs=6)
julia&gt; @show λ
6-element Array{Complex{Float64},1}:
  4.496403249731884e-15 + 2.506628274630998im
        -2.506628274631 - 2.8727020762175925e-15im
  3.219972424519104e-16 - 2.5066282746310034im
     2.5066282746310096 - 1.1438072192922029e-15im
 -2.3814273710772784e-7 - 7.748469160458366e-8im
   2.381427350935646e-7 + 7.748467479992284e-8im</code></pre><p><strong>References</strong></p><ul><li>Asakura, Sakurai, Tadano, Ikegami, Kimura, A numerical method for nonlinear eigenvalue problems using contour integrals, JSIAM Letters, 2009 Volume 1 Pages 52-55</li><li>Van Beeumen,  Meerbergen, Michiels. Connections between contour integration and rational Krylov methods for eigenvalue problems, 2016, TW673, https://lirias.kuleuven.be/retrieve/415487/</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_block_SS.jl#L6-L44">source</a></section></article><h2 id="Arnoldi-and-Krylov-based-methods"><a class="docs-heading-anchor" href="#Arnoldi-and-Krylov-based-methods">Arnoldi and Krylov based methods</a><a id="Arnoldi-and-Krylov-based-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Arnoldi-and-Krylov-based-methods" title="Permalink"></a></h2><h3 id="IAR"><a class="docs-heading-anchor" href="#IAR">IAR</a><a id="IAR-1"></a><a class="docs-heading-anchor-permalink" href="#IAR" title="Permalink"></a></h3><p>The Infinite ARnoldi method.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.iar" href="#NonlinearEigenproblems.NEPSolver.iar"><code>NonlinearEigenproblems.NEPSolver.iar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iar(nep,[maxit=30,][σ=0,][γ=1,][linsolvecreator=DefaultLinSolverCreator(),][tol=eps()*10000,][neigs=6,][errmeasure,][v=rand(size(nep,1),1),][logger=0,][check_error_every=1,][orthmethod=DGKS,][proj_solve=false,][inner_solver_method=DefaultInnerSolver(),][inner_logger=0])</code></pre><p>Run the infinite Arnoldi method on the nonlinear eigenvalue problem stored in <code>nep</code>.</p><p>The target <code>σ</code> is the center around which eiganvalues are computed. The value <code>γ</code> corresponds to scaling and specifying a shift and scaling is effectively the same as the transformation <code>λ=γs+σ</code> where <code>s</code> is now the eigenvalue parameter. If you want eigenvalues in a disk centered, select <code>σ</code> as the center of the disk and <code>γ</code> as the radius. The vector <code>v</code> is the starting vector for constructing the Krylov space. The orthogonalization method, used in contructing the orthogonal basis of the Krylov space, is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The iteration is continued until <code>neigs</code> Ritz pairs have converged. This function throws a <code>NoConvergenceException</code> if the wanted eigenpairs are not computed after <code>maxit</code> iterations. However, if <code>neigs</code> is set to <code>Inf</code> the iteration is continued until <code>maxit</code> iterations without an error being thrown. The parameter <code>proj_solve</code> determines if the Ritz pairs are extracted using the Hessenberg matrix (false), or as the solution to a projected problem (true). If <code>true</code>, the method is descided by <code>inner_solver_method</code>, and the logging of the inner solvers are descided by <code>inner_logger</code>, which works in the same way as <code>logger</code>.</p><p>See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NonlinearEigenproblems, LinearAlgebra
julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; v0=ones(size(nep,1));
julia&gt; λ,v=iar(nep;v=v0,tol=1e-5,neigs=3);
julia&gt; norm(compute_Mlincomb!(nep,λ[1],v[:,1])) # Is it an eigenvalue?
julia&gt; λ    # print the computed eigenvalues
3-element Array{Complex{Float64},1}:
 -0.15606211475666945 - 0.12273439802763578im
 -0.15606211475666862 + 0.12273439802763489im
  0.23169243065648365 - 9.464790582509696e-17im</code></pre><p><strong>References</strong></p><ul><li>Algorithm 2 in Jarlebring, Michiels Meerbergen, A linear eigenvalue algorithm for the nonlinear eigenvalue problem, Numer. Math, 2012</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_iar.jl#L8-L45">source</a></section></article><h3 id="IAR-Chebyshev"><a class="docs-heading-anchor" href="#IAR-Chebyshev">IAR Chebyshev</a><a id="IAR-Chebyshev-1"></a><a class="docs-heading-anchor-permalink" href="#IAR-Chebyshev" title="Permalink"></a></h3><p>A Chebyshev version of the IAR method.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.iar_chebyshev" href="#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>NonlinearEigenproblems.NEPSolver.iar_chebyshev</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iar_chebyshev(nep,[maxit=30,][σ=0,][γ=1,][linsolvecreator=DefaultLinSolverCreator(),][tolerance=eps()*10000,][neigs=6,][errmeasure,][v=rand(size(nep,1),1),][logger=0,][check_error_every=1,][orthmethod=DGKS][a=-1,][b=1,][compute_y0_method=ComputeY0ChebAuto])</code></pre><p>Run the infinite Arnoldi method (Chebyshev version) on the nonlinear eigenvalue problem stored in <code>nep</code>.</p><p>The target <code>σ</code> is the center around which eiganvalues are computed. A Ritz pair <code>λ</code> and <code>v</code> is flagged a as converged (to an eigenpair) if <code>errmeasure</code> is less than <code>tol</code>. The vector <code>v</code> is the starting vector for constructing the Krylov space. The orthogonalization method, used in contructing the orthogonal basis of the Krylov space, is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The iteration is continued until <code>neigs</code> Ritz pairs converge. This function throws a <code>NoConvergenceException</code> if the wanted eigenpairs are not computed after <code>maxit</code> iterations. However, if <code>neigs</code> is set to <code>Inf</code> the iteration is continued until <code>maxit</code> iterations without an error being thrown. The kwarg <code>compute_y0_method</code> specifying how the next vector of the Krylov space (in Chebyshev format) can be computed. See <a href="#NonlinearEigenproblems.NEPSolver.compute_y0_cheb"><code>compute_y0_cheb</code></a> in the module NEPSolver with the command <code>?NEPSolver.compute_y0_cheb</code>.</p><p>See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NonlinearEigenproblems, LinearAlgebra
julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; v0=ones(size(nep,1));
julia&gt; λ,v=iar_chebyshev(nep;v=v0,tol=1e-5,neigs=3);
julia&gt; norm(compute_Mlincomb!(nep,λ[1],v[:,1])) # Is it an eigenvalue?
julia&gt; λ    # print the computed eigenvalues
3-element Array{Complex{Float64},1}:
julia&gt; norm(compute_Mlincomb(nep,λ[1],v[:,1]))
 0.050462487848960284 - 1.4289626573515395e-18im
 -0.07708779190301127 + 7.703053374113074e-18im
   0.1503856540695659 - 1.662582577182149e-17im</code></pre><p><strong>References</strong></p><ul><li>Algorithm 2 in Jarlebring, Michiels Meerbergen, A linear eigenvalue algorithm for the nonlinear eigenvalue problem, Numer. Math, 2012</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_iar_chebyshev.jl#L33-L64">source</a></section></article><p>For the <code>iar_chebyshev</code> the following <code>compute_y0_cheb</code> method is needed, in order to avoid explicit conversions between the Chebyshev basis and the monimial basis.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.compute_y0_cheb" href="#NonlinearEigenproblems.NEPSolver.compute_y0_cheb"><code>NonlinearEigenproblems.NEPSolver.compute_y0_cheb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y0 = compute_y0_cheb([eltype],nep::NEPTypes.DEP,::Type{ComputeY0ChebPEP},X,Y,M0inv,precomp::AbstractPrecomputeData)</code></pre><p>Computes the vector y0 used in <a href="#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> given by</p><p class="math-container">\[ y_0 = \sum_{i=1}^N T_{i-1}(γ) x_i - \sum_{j=1}^m A_j \left( \sum_{i=1}^{N+1} T_{i-1}(-ρ \tau_j+γ) y_i \right )\]</p><p>where T(c) is the vector containing <span>$T_i(c)$</span> as coefficients, where <span>$T_i$</span> is the i-th Chebyshev polynomial of the first kind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_iar_chebyshev.jl#L300-L308">source</a></section><section><div><pre><code class="nohighlight hljs">y0 = compute_y0_cheb([eltype],nep::NEPTypes.PEP,::Type{ComputeY0ChebPEP},X,Y,M0inv,precomp::AbstractPrecomputeData)</code></pre><p>Computes the vector y0 used in <a href="#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> given by</p><p class="math-container">\[ y_0 = \sum_{j=0}^{d-1} A_{j+1} x D^j T(c) - y T(c)\]</p><p>where T(c) is the vector containing <span>$T_i(c)$</span> as coefficients, where <span>$T_i$</span> is the i-th Chebyshev polynomial of the first kind and <span>$D$</span> is the derivation matrix in Chebyshev basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_iar_chebyshev.jl#L322-L330">source</a></section><section><div><pre><code class="nohighlight hljs">y0 = compute_y0_cheb([eltype],nep::NEPTypes.SPMF_NEP,::Type{ComputeY0ChebPEP},X,Y,M0inv,precomp::AbstractPrecomputeData)</code></pre><p>Computes the vector y0 used in <a href="#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> given by</p><p class="math-container">\[ y_0= \sum_{j=0}^{m} M^{(j)}(\mu) X b_j \left( D_N \right) T_N(c) - Y T_N(c)\]</p><p>where T(c) is the vector containing <span>$T_i(c)$</span> as coefficients, where <span>$T_i$</span> is the i-th Chebyshev polynomial of the first kind and <span>$b_j(\lambda)=(f_j(0)-f_j(\lambda))/\lambda=f[\lambda,0]$</span> are divided differences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_iar_chebyshev.jl#L346-L354">source</a></section><section><div><pre><code class="nohighlight hljs">y0 = compute_y0_cheb([eltype],nep::NEPTypes.NEP,::Type{ComputeY0ChebNEP},X,Y,M0inv,precomp::AbstractPrecomputeData)</code></pre><p>Computes the vector y0 used in <a href="#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> defined as</p><p class="math-container">\[ y_0 =\left( \sum_{i=0}^{N-1} B \left( \frac{d}{d \theta} \right) \hat T_i(\theta) x_i \right)(0) - \sum_{i=0}^{N} T_i(c) y_i\]</p><p>where <span>$T_i$</span> is the i-th Chebyshev polynomial of the first kind, $ \ hat T_i$ is the i-th Chebyshev polynomial of the first kind for the interval [a,b]. For a generic <code>nep</code>, this quantity is computed by converting polynomials in monomial basis. This procedure may be numerical unstable if many iterations are required. If for the specific <code>nep</code> a closed formula is available, we suggest to overload this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_iar_chebyshev.jl#L368-L376">source</a></section></article><h3 id="TIAR"><a class="docs-heading-anchor" href="#TIAR">TIAR</a><a id="TIAR-1"></a><a class="docs-heading-anchor-permalink" href="#TIAR" title="Permalink"></a></h3><p>The Tensor Infinite ARnoldi method.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.tiar" href="#NonlinearEigenproblems.NEPSolver.tiar"><code>NonlinearEigenproblems.NEPSolver.tiar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tiar(nep,[maxit=30,][σ=0,][γ=1,][linsolvecreator=DefaultLinSolverCreator(),][tolerance=eps()*10000,][neigs=6,][errmeasure,][v=rand(size(nep,1),1),][logger=0,][check_error_every=1,][orthmethod=DGKS(),][proj_solve=false,][inner_solver_method=DefaultInnerSolver(),][inner_logger=0])</code></pre><p>Run the tensor infinite Arnoldi method on the nonlinear eigenvalue problem stored in <code>nep</code>. This is equivalent to <code>iar</code>, but handles orthogonalization with a tensor representation.</p><p>The target <code>σ</code> is the center around which eiganvalues are computed. The value <code>γ</code> corresponds to scaling and specifying a shift and scaling is effectively the same as the transformation <code>λ=γs+σ</code> where <code>s</code> is now the eigenvalue parameter. If you want eigenvalues in a disk centered, select <code>σ</code> as the center of the disk and <code>γ</code> as the radius. The vector <code>v</code> is the starting vector for constructing the Krylov space. The orthogonalization method, used in contructing the orthogonal basis of the Krylov space, is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The iteration is continued until <code>neigs</code> Ritz pairs have converged. This function throws a <code>NoConvergenceException</code> if the wanted eigenpairs are not computed after <code>maxit</code> iterations. However, if <code>neigs</code> is set to <code>Inf</code> the iteration is continued until <code>maxit</code> iterations without an error being thrown. The parameter <code>proj_solve</code> determines if the Ritz paris are extracted using the Hessenberg matrix (false), or as the solution to a projected problem (true). If true, the method is descided by <code>inner_solver_method</code>, and the logging of the inner solvers are descided by <code>inner_logger</code>, which works in the same way as <code>logger</code>.</p><p>See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NonlinearEigenproblems, LinearAlgebra
julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; v0=ones(size(nep,1));
julia&gt; λ,v=tiar(nep;v=v0,tol=1e-5,neigs=3);
julia&gt; norm(compute_Mlincomb!(nep,λ[1],v[:,1])) # Is it an eigenvalue?
julia&gt; λ    # print the computed eigenvalues
3-element Array{Complex{Float64},1}:
 0.050462487743188206 - 3.4059600538119376e-18im
 -0.07708769561361105 + 8.611006691570004e-19im
   0.1503916927814904 + 9.388210527944734e-18im</code></pre><p><strong>References</strong></p><ul><li>Algorithm 2 in Jarlebring, Mele, Runborg, The Waveguide Eigenvalue Problem and the Tensor Infinite Arnoldi Method, SIAM J. Scient. computing, 39 (3), A1062-A1088, 2017</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_tiar.jl#L7-L51">source</a></section></article><h3 id="Infinite-Lanczos-based-methods"><a class="docs-heading-anchor" href="#Infinite-Lanczos-based-methods">Infinite Lanczos based methods</a><a id="Infinite-Lanczos-based-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Infinite-Lanczos-based-methods" title="Permalink"></a></h3><p>The Infinite Bi-Lanczos method.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.infbilanczos" href="#NonlinearEigenproblems.NEPSolver.infbilanczos"><code>NonlinearEigenproblems.NEPSolver.infbilanczos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">λv,V,U=infbilanczos([eltype],nep, nept,[linsolvecreator,][linsolvertcreator,][v,][u,][σ,][γ,][tol,][neigs,][errmeasure,][logger,][maxit,][check_error_every])</code></pre><p>Executes the Infinite Bi-Lanczos method on the problem defined by <code>nep::NEP</code> and <code>nept::NEP</code>. <code>nep:NEP</code> is the original nonlinear eigenvalue problem and <code>nept::NEP</code> is its (hermitian) transpose: <span>$M(λ^*)^H$</span>.  <code>v</code> and <code>u</code> are starting vectors, <code>σ</code> is the shift and <code>γ</code> the scaling. The iteration is continued until <code>neigs</code> Ritz pairs have converged. This function throws a <code>NoConvergenceException</code> if the wanted eigenpairs are not computed after <code>maxit</code> iterations. However, if <code>neigs</code> is set to <code>Inf</code> the iteration is continued until <code>maxit</code> iterations without an error being thrown. See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; A=get_Av(nep); fv=get_fv(nep);
julia&gt; At=[copy(A[1]&#39;),copy(A[2]&#39;),copy(A[3]&#39;)]
julia&gt; nept=SPMF_NEP(At,fv); # Create the transposed NEP
julia&gt; λv,V=infbilanczos(nep,nept,neigs=3,v=ones(size(nep,1)))
julia&gt; norm(compute_Mlincomb(nep,λv[1],V[:,1]))
9.907299130783851e-15</code></pre><p><strong>References:</strong></p><ul><li>The infinite bi-Lanczos method for nonlinear eigenvalue problems, S. W. Gaaf and E. Jarlebring, SIAM J. Sci. Comput. 39:S898-S919, 2017, <a href="https://arxiv.org/abs/1607.03454">preprint</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_infbilanczos.jl#L5-L31">source</a></section></article><p>The Infinite Lanczos method, for symmetric NEPs</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.ilan" href="#NonlinearEigenproblems.NEPSolver.ilan"><code>NonlinearEigenproblems.NEPSolver.ilan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ilan(nep,[maxit=30,][σ=0,][γ=1,][linsolvecreator=DefaultLinSolverCreator(),][tolerance=eps()*10000,][neigs=6,][errmeasure,][v=rand(size(nep,1),1),][logger=0,][check_error_every=30,][orthmethod=DGKS])</code></pre><p>Run the infinite Lanczos method on the symmetric nonlinear eigenvalue problem stored in <code>nep</code>. The current implementation supports only <code>nep</code>s in <code>SPMF</code> format.</p><p>The target <code>σ</code> is the center around which eiganvalues are computed. The kwarg <code>errmeasure</code> is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). A Ritz pair <code>λ</code> and <code>v</code> is flagged a as converged (to an eigenpair) if <code>errmeasure</code> is less than <code>tol</code>. The vector <code>v</code> is the starting vector for constructing the Krylov space. The orthogonalization method, used in contructing the orthogonal basis of the Krylov space, is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The iteration is continued until <code>neigs</code> Ritz pairs have converged. This function throws a <code>NoConvergenceException</code> if the wanted eigenpairs are not computed after <code>maxit</code> iterations. However, if <code>neigs</code> is set to <code>Inf</code> the iteration is continued until <code>maxit</code> iterations without an error being thrown.</p><p>See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NonlinearEigenproblems, LinearAlgebra
julia&gt; nep=nep_gallery(&quot;dep_symm_double&quot;,10);
julia&gt; v0=ones(size(nep,1));
julia&gt; λ,v=ilan(nep;v=v0,tol=1e-5,neigs=3);
julia&gt; norm(compute_Mlincomb!(nep,λ[1],v[:,1])) # Is it an eigenvalue?
julia&gt; λ    # print the computed eigenvalues
3-element Array{Complex{Float64},1}:
  0.03409997385842267 - 1.425205509434608e-19im
 -0.03100798730589012 + 5.66201058098364e-20im
  -0.0367653644764646 - 1.607494907684445e-19im</code></pre><p><strong>References</strong></p><ul><li>Algorithm 2 in Mele, The infinite Lanczos method for symmetric nonlinear eigenvalue problems, https://arxiv.org/abs/1812.07557, 2018</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_ilan.jl#L28-L55">source</a></section></article><h3 id="NLEIGS"><a class="docs-heading-anchor" href="#NLEIGS">NLEIGS</a><a id="NLEIGS-1"></a><a class="docs-heading-anchor-permalink" href="#NLEIGS" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.nleigs" href="#NonlinearEigenproblems.NEPSolver.nleigs"><code>NonlinearEigenproblems.NEPSolver.nleigs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nleigs(nep::NEP, Σ::AbstractVector{Complex{T}})</code></pre><p>Find a few eigenvalues and eigenvectors of a nonlinear eigenvalue problem, using the <code>nleigs</code> algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>nep</code>: An instance of a nonlinear eigenvalue problem.</li><li><code>Σ</code>: A vector containing the points of a polygonal target set in the complex plane.</li><li><code>Ξ</code>: A vector containing a discretization of the singularity set.</li><li><code>logger</code>: Level of display (0, 1, 2).</li><li><code>maxdgr</code>: Max degree of approximation.</li><li><code>minit</code>: Min number of iterations after linearization is converged.</li><li><code>maxit</code>: Max number of total iterations.</li><li><code>tol</code>: Tolerance for residual.</li><li><code>tollin</code>: Tolerance for convergence of linearization.</li><li><code>v</code>: Starting vector.</li><li><code>errmeasure</code>: Function for error measure (residual norm). Called with arguments (λ,v).</li><li><code>isfunm</code> : Whether to use matrix functions.</li><li><code>static</code>: Whether to use static version of NLEIGS.</li><li><code>leja</code>: Use of Leja-Bagby points (0 = no, 1 = only in expansion phase, 2 = always).</li><li><code>nodes</code>: Prefixed interpolation nodes (only when leja is 0 or 1).</li><li><code>reusefact</code>: Reuse of matrix factorizations (0 = no, 1 = only after converged linearization, 2 = always).</li><li><code>blksize</code>: Block size for pre-allocation.</li><li><code>return_details</code>: Whether to return solution details (see NleigsSolutionDetails).</li><li><code>check_error_every</code>: Check for convergence / termination every this number of iterations.</li></ul><p>See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Return values</strong></p><ul><li><code>λ</code>: Vector of eigenvalues of the nonlinear eigenvalue problem NLEP inside the target set Σ.</li><li><code>X</code>: Corresponding matrix of eigenvectors.</li><li><code>res</code>: Corresponding residuals.</li><li><code>details</code>: Solution details, if requested (see NleigsSolutionDetails).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; unit_square = float([1+1im, 1-1im, -1-1im,-1+1im])
julia&gt; (λ,v)=nleigs(nep,unit_square);
julia&gt; norm(compute_Mlincomb(nep,λ[1],v[:,1]))
5.028313023882492e-14
julia&gt; norm(compute_Mlincomb(nep,λ[2],v[:,2]))
1.1937025845487509e-13</code></pre><p><strong>References</strong></p><ul><li>S. Guettel, R. Van Beeumen, K. Meerbergen, and W. Michiels. NLEIGS: A class of fully rational Krylov methods for nonlinear eigenvalue problems. SIAM J. Sci. Comput., 36(6), A2842-A2864, 2014.</li><li><a href="http://twr.cs.kuleuven.be/research/software/nleps/nleigs.php">NLEIGS Matlab toolbox</a> (GPL License)</li><li><a href="https://bitbucket.org/roelvb/nleigs">NLEIGS Matlab toolbox</a> (MIT License)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_nleigs.jl#L7-L58">source</a></section></article><h3 id="AAA-EIGS"><a class="docs-heading-anchor" href="#AAA-EIGS">AAA-EIGS</a><a id="AAA-EIGS-1"></a><a class="docs-heading-anchor-permalink" href="#AAA-EIGS" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.AAAeigs" href="#NonlinearEigenproblems.NEPSolver.AAAeigs"><code>NonlinearEigenproblems.NEPSolver.AAAeigs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AAAeigs([eltype,] nep::NEP, Z::AbstractArray{T}; [logger=0,][mmax=100,][neigs=6,][maxit=min(max(10*neigs,30),100),][shifts=Vector{T}(),][linsolvercreator=FactorizeLinSolverCreator(max_factorizations=min(length(unique(shifts)),10)),][tol=eps(real(T))*1e6,][tol_appr=eps(real(T))*1e3,][v0=Vector{T}(),][errmeasure=ResidualErrmeasure(nep),][weighted=false,][cleanup_appr=true,][tol_cln=min(eps(real(T)),tol_appr),][return_details=false,][check_error_every=10,][inner_logger=0])</code></pre><p>Find a few eigenvalues and eigenvectors of a nonlinear eigenvalue problem, using the <code>AAAeigs</code> algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>nep</code>: An instance of a nonlinear eigenvalue problem has to be of type <code>AbstractSPMF</code></li><li><code>Z</code>: An array containing the sample domain of the nep, given as a series of points.</li><li><code>mmax</code>: Max degree of AAA-approximation.</li><li><code>neigs</code>: Number of eigenvalues to find.</li><li><code>maxit</code>: Max number of total iterations.</li><li><code>shifts</code>: L vector of shifts used during the Krylov routine (empty -&gt; shift=0)</li><li><code>tol</code>: Tolerance for residual.</li><li><code>tol_appr</code>: Tolerance for convergence of AAA-approximation.</li><li><code>v0</code>: Starting vector.</li><li><code>weighted</code>: Wether to use Weighted or Set-Valued AAA.</li><li><code>cleanup_appr</code>: Whether to detect spurious poles in AAA.</li><li><code>tol_cln</code>: Tolerance for cleanup of spurious poles.</li><li><code>return_details</code>: Whether to return solution details (see <code>AAASolutionDetails</code>).</li><li><code>check_error_every</code>: Check for convergence / termination every this number of iterations.</li><li><code>inner_logger</code>: Works in the same way as logger but for the AAA rational approximation (see <code>svAAA</code>)</li></ul><p>See <a href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a> for other parameters.</p><p><strong>Return values</strong></p><ul><li><code>Λ</code>: Vector of eigenvalues of the nonlinear eigenvalue problem inside the sample set Z.</li><li><code>X</code>: Corresponding matrix of eigenvectors.</li><li><code>res</code>: Corresponding residuals.</li><li><code>details</code>: Solution details, if requested (see AAASolutionDetails).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Random.seed!(2022);
julia&gt; nep=nep_gallery(&quot;nlevp_native_gun&quot;);
julia&gt; m=250^2; r=300^2-200^2;
julia&gt; Z=m-r.+2*r*rand(1000)+im*(rand(1000)*r.+sqrt(1e-13));
julia&gt; Z=Z[(~).(imag.(Z).&gt;sin.(acos.((real.(Z).-m)/r))*r.-sqrt(1e-13))];
julia&gt; Z=[transpose([LinRange(m-r+1e-2,m+r-1e-2,250)&#39; m-r.+2*r*(exp.(im*LinRange(0,pi,250)&#39;)/2 .+.5)]); Z[1:500]];
julia&gt; shifts=r*[2/3,(1+im)/3,0,(-1+im)/3,-2/3].+m;
julia&gt; λ,X=AAAeigs(nep,Z,shifts=shifts);
julia&gt; [norm(compute_Mlincomb(nep,λ[i],X[:,i]))/norm(X[:,i]) for i=1:length(λ)]
6-element Vector{Float64}:
 5.282105614825289e-12
 1.675900913610527e-11
 4.971723316733914e-11
 9.437128735632508e-11
 1.2277986011104446e-10
 1.4546362158344052e-10</code></pre><p><strong>References</strong></p><ul><li>P. Lietaert, J. Pérez, B. Vandereycken, and K. Meerbergen. Automatic rational approximation and linearization of nonlinear eigenvalue problems. IMA journal of numerical analysis, 2018.</li><li>R. Van Beeumen, K. Meerbergen, and W. Michiels. Compact rational Krylov methods for nonlinear eigenvalue problems. SIAM Journal on Matrix Analysis and Applications, 36(2):820-838, 2015.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_AAAeigs.jl#L123-L180">source</a></section></article><h2 id="Class-specific-methods"><a class="docs-heading-anchor" href="#Class-specific-methods">Class specific methods</a><a id="Class-specific-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Class-specific-methods" title="Permalink"></a></h2><h3 id="Companion-linearizations"><a class="docs-heading-anchor" href="#Companion-linearizations">Companion linearizations</a><a id="Companion-linearizations-1"></a><a class="docs-heading-anchor-permalink" href="#Companion-linearizations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.companion" href="#NonlinearEigenproblems.NEPSolver.companion"><code>NonlinearEigenproblems.NEPSolver.companion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">E,A = companion(nep::PEP);</code></pre><p>Linearizes a  polynomial eigenvalue problem (PEP) a to the companion form, as in the paper by Mehrmann and Voss. More precisely, for a k-th degree PEP with n-by-n coefficient matrices, this returns matrices E and A, both kn-by-kn, corresponding to the linearized problem</p><p class="math-container">\[Ax = λEx\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pep = nep_gallery(&quot;pep0&quot;);
julia&gt; E,A = companion(pep);
julia&gt; λ, V = eigen(A,E);
julia&gt; minimum(svd(compute_Mder(pep,λ[1])).S)
2.4845217786736996e-12</code></pre><p><strong>References</strong></p><ul><li>V. Mehrmann and H. Voss, Non-linear eigenvalue problems, a challenge for modern eigenvalue methods, GAMM‐Mitteilungen (2004)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_companion.jl#L8-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.polyeig" href="#NonlinearEigenproblems.NEPSolver.polyeig"><code>NonlinearEigenproblems.NEPSolver.polyeig</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">λ,v = polyeig([eltype],nep::PEP,[eigsolvertype,])</code></pre><p>Linearizes a  polynomial eigenvalue problem (PEP) a to the companion form and solves the corresponding linear eigenvalue problem; see <a href="#NonlinearEigenproblems.NEPSolver.companion"><code>companion</code></a>. The <code>eigsolvertype</code> is optinal can be used to specify how the linear problem is solved; see <a href="../linsolvers/#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a>, and <a href="../linsolvers/#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pep = nep_gallery(&quot;pep0&quot;);
julia&gt; λ,V = polyeig(pep);
julia&gt; minimum(svd(compute_Mder(pep,λ[1])).S)
1.2050763381899922e-14
julia&gt; norm(compute_Mlincomb(pep,λ[2],vec(V[:,2])))
1.0245470569036458e-12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_companion.jl#L68-L85">source</a></section><section><div><pre><code class="nohighlight hljs">λ,v = polyeig([eltype],nep::ChebPEP)</code></pre><p>Computes a companion linearization for the NEP represented in a Chebyshev basis, and returns eigenpairs.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using LinearAlgebra
julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; chebpep=ChebPEP(nep,9,-3,1,cosine_formula_cutoff=5);
julia&gt; (λv,V)=polyeig(chebpep);
julia&gt; ii=argmin(abs.(λv));
julia&gt; λ=λv[ii];
julia&gt; v=V[:,ii];
julia&gt; norm(compute_Mlincomb(chebpep,λ,v))
1.3543968603949142e-14
julia&gt; # Actually, it&#39;s not a bad approx to the original NEP either
julia&gt; norm(compute_Mlincomb(nep,λ,v))
4.326355966047557e-6</code></pre><p>See also <a href="../types/#NonlinearEigenproblems.NEPTypes.ChebPEP"><code>ChebPEP</code></a>.</p><p><strong>References:</strong></p><ul><li>Amiraslani, A., Corless, R. M. &amp; Lancaster, P. &quot;Linearization of matrix polynomials expressed in poly-nomial bases&quot; IMA J. Numer. Anal.,29 (2009): 141–157.</li><li>Effenberger and Kressner. &quot;Chebyshev interpolation for nonlinear eigenvalue problems.&quot; BIT Numerical Mathematics 52.4 (2012): 933-951.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/f3e350be4efe5fbbe217dc164cc81087b3d2077b/src/method_companion.jl#L103-L132">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../types/">Types &amp; Data structures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 29 June 2023 05:53">Thursday 29 June 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
