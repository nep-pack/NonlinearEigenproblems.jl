<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Measuring the error · NEP-PACK</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NEP-PACK</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../methods/">NEP-Solvers</a></li><li><a class="tocitem" href="../types/">Types &amp; Data structures</a></li><li><a class="tocitem" href="../compute_functions/">Compute functions</a></li><li><a class="tocitem" href="../linsolvers/">Linear solvers</a></li><li><a class="tocitem" href="../innersolvers/">Projection</a></li><li class="is-active"><a class="tocitem" href>Measuring the error</a><ul class="internal"><li><a class="tocitem" href="#Standard-usage"><span>Standard usage</span></a></li><li><a class="tocitem" href="#User-defined-error-measure"><span>User defined error measure</span></a></li><li><a class="tocitem" href="#As-a-NEP-solver-developer"><span>As a NEP-solver developer</span></a></li><li><a class="tocitem" href="#Methods-and-types"><span>Methods and types</span></a></li></ul></li><li><a class="tocitem" href="../logger/">Logger</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../deflation/">Deflation</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="tocitem" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="tocitem" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="tocitem" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="tocitem" href="../tutorial_call_python/">Tutorial 5 (Python 1)</a></li><li><a class="tocitem" href="../tutorial_python_call/">Tutorial 6 (Python 2)</a></li><li><a class="tocitem" href="../tutorial_matlab1/">Tutorial 7 (MATLAB)</a></li><li><a class="tocitem" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="tocitem" href="../tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="tocitem" href="../tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li><a class="tocitem" href="../tutorial_linsolve/">Tutorial 11 (Linear solvers)</a></li><li><a class="tocitem" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Measuring the error</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Measuring the error</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/errmeasure.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Measuring-the-error"><a class="docs-heading-anchor" href="#Measuring-the-error">Measuring the error</a><a id="Measuring-the-error-1"></a><a class="docs-heading-anchor-permalink" href="#Measuring-the-error" title="Permalink"></a></h1><p>All iterative algorithms need some form of termination criteria. In NEP-PACK, all NEP-solvers provide the possibility to specify the desired tolerance, as well as how the error is measured or estimated. The tolerance is specified in the kwarg  <code>tol</code> (which is a real number) and the way to measure the error is given in <code>errmeasure</code>.</p><h2 id="Standard-usage"><a class="docs-heading-anchor" href="#Standard-usage">Standard usage</a><a id="Standard-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-usage" title="Permalink"></a></h2><p>NEP-PACK comes with several ways to measure errors for many NEP-types.</p><ul><li><code>errmeasure=</code><a href="#NonlinearEigenproblems.NEPTypes.ResidualErrmeasure"><code>ResidualErrmeasure</code></a><code>(nep)</code>: The error is estimated by the use of the residual norm:</li></ul><p class="math-container">\[\mathrm{err}=\frac{\|M(λ)v\|}{\|v\|}.\]</p><ul><li><p><code>errmeasure=</code><a href="#NonlinearEigenproblems.NEPTypes.StandardSPMFErrmeasure"><code>StandardSPMFErrmeasure</code></a><code>(nep)</code>: The error is estimated by using backward error theory. This error measure will not work for all NEPs. An implementation is provided for any <code>AbstractSPMF</code>. If your NEP is an <code>AbstractSPMF</code> with terms:</p><p class="math-container">\[M(λ)=A_1f_1(λ)+\cdots+A_mf_m(λ)\]</p><p>the error will be estimated by</p><p class="math-container">\[\mathrm{err}=\frac{\|M(λ)v\|}{\|v\|}\frac{1}{\|A_1\|_F|f_1(λ)|+\cdots+\|A_m\|_F|f_m(λ)|}.\]</p><p>In other words, the <code>StandardSPMFErrmeasure</code> is a weighting of the <code>ResidualErrmeasure</code>.</p></li><li><p><code>errmeasure=</code><a href="#NonlinearEigenproblems.NEPTypes.DefaultErrmeasure"><code>DefaultErrmeasure</code></a><code>(nep)</code>: When this <code>errmeasure</code> is specified, NEP-PACK tries to determine a error measure for you. In general, <code>StandardSPMFErrmeasure</code> will be preferred if possible. This behavior may change in future versions of NEP-PACK.</p></li><li><p><code>errmeasure=</code><a href="#NonlinearEigenproblems.NEPTypes.EigvalReferenceErrmeasure"><code>EigvalReferenceErrmeasure</code></a><code>(nep,λref)</code>: This errmeasure is used when an exact (or very accurate) eigenvalue is already known. Typically, if you wish to visualize the eigenvalue error of a specific method, you run the method twice and use the result of the first run as to instantiate this error measure and get real eigenvalue errors as output.</p></li><li><p><code>errmeasure=(λ,v)-&gt; compute_error(λ,v)</code>: A user defined error measure can be specified using a function. The function should be take an eigenpair as input, and return a real value. See <a href="#NonlinearEigenproblems.NEPTypes.ErrmeasureType"><code>ErrmeasureType</code></a> for an example.</p></li></ul><p>Example: Most NEP-solvers take the <code>errmeasure</code> as an kwarg.</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; # Solve the problem to residual norm 1e-8
julia&gt; (λ,v)=mslp(nep,errmeasure=ResidualErrmeasure(nep),tol=1e-8);
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v) # It&#39;s smaller than tol?
3.503700738108789e-9
julia&gt; nep isa AbstractSPMF # Is it an AbstractSPMF so we can use StandardSPMFErrmeasure?
true
julia&gt; (λ,v)=mslp(nep,errmeasure=StandardSPMFErrmeasure(nep),tol=1e-10);
julia&gt; fv = get_fv(nep); Av = get_Av(nep);
julia&gt; factor=abs(fv[1](λ))*norm(Av[1])+
     abs(fv[2](λ))*norm(Av[2])+abs(fv[3](λ))*norm(Av[3]);
julia&gt; norm(compute_Mlincomb(nep,λ,v))/(norm(v)*factor)
1.6591695084414612e-11</code></pre><h2 id="User-defined-error-measure"><a class="docs-heading-anchor" href="#User-defined-error-measure">User defined error measure</a><a id="User-defined-error-measure-1"></a><a class="docs-heading-anchor-permalink" href="#User-defined-error-measure" title="Permalink"></a></h2><p>A common situation is that you want to report the error (as a function of iteration) with a reference solution. We take this situation as an example and show how a relative error of the eigenvalue estimate, compared to a reference solution, can be computed. Compare with type <a href="#NonlinearEigenproblems.NEPTypes.EigvalReferenceErrmeasure"><code>EigvalReferenceErrmeasure</code></a> which measures an absolute error relative a reference solution.</p><p>There are two ways that a user can specify how to measure the error.</p><h3 id="User-defined-error-1:-Function-handle"><a class="docs-heading-anchor" href="#User-defined-error-1:-Function-handle">User defined error 1: Function handle</a><a id="User-defined-error-1:-Function-handle-1"></a><a class="docs-heading-anchor-permalink" href="#User-defined-error-1:-Function-handle" title="Permalink"></a></h3><p>The user can provide a function handle which is called to obtain the error. The <code>errmeasure</code> can be a function, which takes two parameters as input <code>(λ,v)</code> and returns the error (or estimate thereof).</p><p>If we want to get a very accurate approximation of the true error, we can run the algorithm twice, and the second time we run the algorithm we use the result of the first run as a reference.</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; v0=ones(size(nep,1));
julia&gt; (λref,_)=resinv(nep,v=v0,λ=-0.1,logger=0);
julia&gt; myerrmeasure = (λ,v) -&gt; abs(λ-λref)/abs(λ);
julia&gt; (λ,v)=resinv(nep,v=v0,λ=-0.1,logger=1,tol=1e-10,errmeasure=myerrmeasure);
Precomputing linsolver
iter 1 err:0.02854168838549373 λ=-0.1 + 0.0im
iter 2 err:0.8397508140476416 λ=-0.6418389474323298 + 0.0im
iter 3 err:0.17336372619725743 λ=-0.08765753239354723 + 0.0im
iter 4 err:0.0005771170619943501 λ=-0.1029135620110966 + 0.0im
iter 5 err:4.762006833879597e-7 λ=-0.10285411985934721 + 0.0im
iter 6 err:4.074039107701665e-7 λ=-0.10285421074175707 + 0.0im
iter 7 err:2.6448037288912206e-8 λ=-0.10285417155884034 + 0.0im
iter 8 err:1.3926542408883378e-9 λ=-0.10285416898178967 + 0.0im
iter 9 err:6.324560618281378e-11 λ=-0.10285416884505445 + 0.0im</code></pre><h3 id="User-defined-error-2:-A-user-defined-type"><a class="docs-heading-anchor" href="#User-defined-error-2:-A-user-defined-type">User defined error 2: A user defined type</a><a id="User-defined-error-2:-A-user-defined-type-1"></a><a class="docs-heading-anchor-permalink" href="#User-defined-error-2:-A-user-defined-type" title="Permalink"></a></h3><p>Due to the multiple dispatch and handling of types in Julia, code may run faster if one uses types instead of function handles. It is possible to do the same simulation as above with a user defined type.</p><p>You first need to define a new type</p><pre><code class="language-julia-repl hljs">julia&gt; struct RefErrmeasure &lt;: Errmeasure; end</code></pre><p>The error measure should then provided in the function <code>estimate_error</code> which we now define as the relative eigenvalue error:</p><pre><code class="language-julia-repl hljs">julia&gt; function NonlinearEigenproblems.estimate_error(e::RefErrmeasure,λ,v)
         return abs(λ-λref)/abs(λ);
       end
julia&gt; (λ,v)=resinv(nep,v=v0,λ=0.1,logger=1,tol=1e-10,errmeasure=RefErrmeasure());
Precomputing linsolver
iter 1 err:0.02854168838549373 λ=-0.1 + 0.0im
iter 2 err:0.8397508140476416 λ=-0.6418389474323298 + 0.0im
iter 3 err:0.17336372619725743 λ=-0.08765753239354723 + 0.0im
iter 4 err:0.0005771170619943501 λ=-0.1029135620110966 + 0.0im
iter 5 err:4.762006833879597e-7 λ=-0.10285411985934721 + 0.0im
iter 6 err:4.074039107701665e-7 λ=-0.10285421074175707 + 0.0im
iter 7 err:2.6448037288912206e-8 λ=-0.10285417155884034 + 0.0im
iter 8 err:1.3926542408883378e-9 λ=-0.10285416898178967 + 0.0im
iter 9 err:6.324560618281378e-11 λ=-0.10285416884505445 + 0.0im</code></pre><h2 id="As-a-NEP-solver-developer"><a class="docs-heading-anchor" href="#As-a-NEP-solver-developer">As a NEP-solver developer</a><a id="As-a-NEP-solver-developer-1"></a><a class="docs-heading-anchor-permalink" href="#As-a-NEP-solver-developer" title="Permalink"></a></h2><p>NEP-solvers should use the <code>Errmeasure</code> as follows. The NEP-solver should take as input an object of the type <code>Errmeasure</code>  or function. The fact that it can be different types, is transparent and a NEP-solver developer does not have to do anything to take care of that if the following procedure is followed.</p><p>Suppose your solver is defined in a function with this signature:</p><pre><code class="language-julia hljs">function mysolver(nep::NEP; errmeasure::ErrmeasureType=DefaultErrmeasure(nep), tol::Real=eps()*100)</code></pre><p>In the main for loop you want to call the <a href="#NonlinearEigenproblems.NEPTypes.estimate_error"><code>estimate_error</code></a> function:</p><pre><code class="language-julia hljs">for k=1:maxit
    err=estimate_error(errmeasure,λ,v)
    if (err &lt; tol)
       return (λ,v)
    end
    ....

end</code></pre><h2 id="Methods-and-types"><a class="docs-heading-anchor" href="#Methods-and-types">Methods and types</a><a id="Methods-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-and-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.Errmeasure" href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>NonlinearEigenproblems.NEPTypes.Errmeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Errmeasure; end</code></pre><p>Concrete subtypes of <code>Errmeasure</code> represent specific ways of measuring the error of an eigenpair. NEP-solvers take such an object as input. As a NEP-solver user, you use the type as follows</p><pre><code class="language-julia hljs">julia&gt; quasinewton(nep,errmeasure=ResidualErrmeasure(nep))</code></pre><p>User-specified ways of measuring error can be given by creating a new subtype of <code>Errmeasure</code> and using it as a <code>errmeasure</code> keyword. You need to specify the way to measure the error in the method <code>estimate_error</code>.</p><p>Note that in practice a <code>Function</code> can essentially be used instead of a <code>Errmeasure</code>-object, which is a simple way to have user-defined error measures. See <a href="#NonlinearEigenproblems.NEPTypes.ErrmeasureType"><code>ErrmeasureType</code></a>.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.ErrmeasureType"><code>ErrmeasureType</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.DefaultErrmeasure"><code>DefaultErrmeasure</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.ResidualErrmeasure"><code>ResidualErrmeasure</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.StandardSPMFErrmeasure"><code>StandardSPMFErrmeasure</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.estimate_error"><code>estimate_error</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.EigvalReferenceErrmeasure"><code>EigvalReferenceErrmeasure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/04630f19cf0f592bb43392689666916f5f4433f1/src/errmeasure.jl#L11-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.DefaultErrmeasure" href="#NonlinearEigenproblems.NEPTypes.DefaultErrmeasure"><code>NonlinearEigenproblems.NEPTypes.DefaultErrmeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DefaultErrmeasure &lt;: Errmeasure
function DefaultErrmeasure(nep::NEP)</code></pre><p>When you specify this <code>Errmeasure</code>, NEP-PACK tries to determine a suitable <code>Errmeasure</code> based on the type of the <code>NEP</code>. Note that this behavior may change in future versions.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/04630f19cf0f592bb43392689666916f5f4433f1/src/errmeasure.jl#L80-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.StandardSPMFErrmeasure" href="#NonlinearEigenproblems.NEPTypes.StandardSPMFErrmeasure"><code>NonlinearEigenproblems.NEPTypes.StandardSPMFErrmeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct StandardSPMFErrmeasure &lt;: Errmeasure
function StandardSPMFErrmeasure(nep::AbstractSPMF)</code></pre><p>This <code>Errmeasure</code> provides a way to compute the backward error. The backward error estimate are only given for NEPs which are subtypes of  <code>AbstractSPMF</code>. We use the Frobenius norm as the matrix norm, since it is much cheaper to compute than the spectral norm.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; (λ,v)=quasinewton(nep,λ=-1,v=ones(size(nep,1)),errmeasure=StandardSPMFErrmeasure(nep),tol=1e-10,logger=1);
Precomputing linsolver
iter 1 err:0.022010375110869937 λ=-1.0 + 0.0im
iter 2 err:0.002515422247048546 λ=-0.7063330111559607 + 0.0im
iter 3 err:0.000892354247568813 λ=-0.8919579082730457 + 0.0im
iter 4 err:5.445678793151584e-5 λ=-1.0097584042560848 + 0.0im
iter 5 err:6.649967517409105e-7 λ=-1.0023823873044 + 0.0im
iter 6 err:1.0557281809769784e-8 λ=-1.0024660870524031 + 0.0im
iter 7 err:6.420125566431444e-9 λ=-1.0024677891861997 + 0.0im
iter 8 err:3.181093707909799e-10 λ=-1.0024669496893164 + 0.0im
iter 9 err:2.6368050026394416e-11 λ=-1.0024669918249076 + 0.0im
</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/04630f19cf0f592bb43392689666916f5f4433f1/src/errmeasure.jl#L145-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.ResidualErrmeasure" href="#NonlinearEigenproblems.NEPTypes.ResidualErrmeasure"><code>NonlinearEigenproblems.NEPTypes.ResidualErrmeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ResidualErrmeasure &lt;: Errmeasure
function ResidualErrmeasure(nep::NEP)</code></pre><p>This <code>Errmeasure</code> species that the residual norm should be used to measure the error.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/04630f19cf0f592bb43392689666916f5f4433f1/src/errmeasure.jl#L104-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.EigvalReferenceErrmeasure" href="#NonlinearEigenproblems.NEPTypes.EigvalReferenceErrmeasure"><code>NonlinearEigenproblems.NEPTypes.EigvalReferenceErrmeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EigvalReferenceErrmeasure{X&lt;:Number} &lt;: Errmeasure
function EigvalReferenceErrmeasure(nep,λref)</code></pre><p>Use the difference between a precomputed λ-value (reference solution) and the eigenvalue estimate as the error measure.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using LinearAlgebra
julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; (λref,vref)=quasinewton(nep,λ=-1,v=ones(size(nep,1)));
julia&gt; (λ,v)=quasinewton(nep,errmeasure=EigvalReferenceErrmeasure(nep,λref),λ=-1.0 ,logger=1,tol=5e-13,v=ones(size(nep,1)));
Precomputing linsolver
iter 1 err:0.002466988585763996 λ=-1.0 + 0.0im
iter 2 err:0.2961339774298033 λ=-0.7063330111559607 + 0.0im
iter 3 err:0.11050908031271833 λ=-0.8919579082730457 + 0.0im
iter 4 err:0.007291415670320767 λ=-1.0097584042560848 + 0.0im
iter 5 err:8.460128136400513e-5 λ=-1.0023823873044 + 0.0im
iter 6 err:9.015333608530796e-7 λ=-1.0024660870524031 + 0.0im
iter 7 err:8.006004357241636e-7 λ=-1.0024677891861997 + 0.0im
iter 8 err:3.889644761834177e-8 λ=-1.0024669496893164 + 0.0im
iter 9 err:3.2391436199930013e-9 λ=-1.0024669918249076 + 0.0im
iter 10 err:2.418474309706653e-10 λ=-1.0024669883439166 + 0.0im
iter 11 err:2.0230705999324528e-11 λ=-1.0024669886059947 + 0.0im
iter 12 err:0.0 λ=-1.002466988585764 + 0.0im</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/04630f19cf0f592bb43392689666916f5f4433f1/src/errmeasure.jl#L195-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.estimate_error" href="#NonlinearEigenproblems.NEPTypes.estimate_error"><code>NonlinearEigenproblems.NEPTypes.estimate_error</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function estimate_error(E::ErrmeasureType,λ,v)</code></pre><p>Returns the error estimate for the eigenpair <code>(λ,v)</code>. The way to measure the error is specified in <code>E</code>, which can be an <code>Errmeasure</code> or a <code>Function</code>.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.ErrmeasureType"><code>ErrmeasureType</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/04630f19cf0f592bb43392689666916f5f4433f1/src/errmeasure.jl#L119-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.ErrmeasureType" href="#NonlinearEigenproblems.NEPTypes.ErrmeasureType"><code>NonlinearEigenproblems.NEPTypes.ErrmeasureType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ErrmeasureType = Union{Type{&lt;:Errmeasure}, Function}</code></pre><p>The <code>ErrmeasureType</code> represents (essentially) what you can insert in the <code>errmeasure</code> keyword argument for most NEP-solvers. It can be a function or an  <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a> object. If it is a <code>Function</code> this function will be used to obtain error estimate.</p><p><strong>Example</strong></p><p>This shows how to compute a reference solution and then use this as a reference solution. The error in the second run will be effectively the eigenvector error (appropriately normalized).</p><pre><code class="language-julia hljs">julia&gt; using LinearAlgebra
julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; (λref,vref)=quasinewton(nep,λ=-1,v=ones(size(nep,1)));
julia&gt; myerrmeasure=(λ,v) -&gt; norm(vref/vref[1]-v/v[1]);
julia&gt; (λ,v)=quasinewton(nep,errmeasure=myerrmeasure,λ=-1.0 ,logger=1,tol=5e-13,v=ones(size(nep,1)));
Precomputing linsolver
iter 1 err:46.40296482739195 λ=-1.0 + 0.0im
iter 2 err:2.1592671533657883 λ=-0.7063330111559607 + 0.0im
iter 3 err:0.17079231439255405 λ=-0.8919579082730457 + 0.0im
iter 4 err:0.1633846991066227 λ=-1.0097584042560848 + 0.0im
iter 5 err:0.003434042059262583 λ=-1.0023823873044 + 0.0im
iter 6 err:0.0003182517281689052 λ=-1.0024660870524031 + 0.0im
iter 7 err:2.0105257231740345e-5 λ=-1.0024677891861997 + 0.0im
iter 8 err:1.618661190265619e-6 λ=-1.0024669496893164 + 0.0im
iter 9 err:1.233489068442819e-7 λ=-1.0024669918249076 + 0.0im
iter 10 err:9.44707811957546e-9 λ=-1.0024669883439166 + 0.0im
iter 11 err:7.867601351698812e-10 λ=-1.0024669886059947 + 0.0im
iter 12 err:0.0 λ=-1.002466988585764 + 0.0im
</code></pre><p>The eigenvalue error can be measured with the <a href="#NonlinearEigenproblems.NEPTypes.EigvalReferenceErrmeasure"><code>EigvalReferenceErrmeasure</code></a>.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.Errmeasure"><code>Errmeasure</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/04630f19cf0f592bb43392689666916f5f4433f1/src/errmeasure.jl#L38-L77">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../innersolvers/">« Projection</a><a class="docs-footer-nextpage" href="../logger/">Logger »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 28 June 2023 09:13">Wednesday 28 June 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
