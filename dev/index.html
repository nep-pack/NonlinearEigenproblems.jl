<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · NEP-PACK</title><meta name="title" content="Introduction · NEP-PACK"/><meta property="og:title" content="Introduction · NEP-PACK"/><meta property="twitter:title" content="Introduction · NEP-PACK"/><meta name="description" content="Documentation for NEP-PACK."/><meta property="og:description" content="Documentation for NEP-PACK."/><meta property="twitter:description" content="Documentation for NEP-PACK."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>NEP-PACK</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Accessing-more-complicated-applications"><span>Accessing more complicated applications</span></a></li><li><a class="tocitem" href="#A-model-of-a-neuron"><span>A model of a neuron</span></a></li><li><a class="tocitem" href="#The-&quot;gun&quot;-benchmark-problem"><span>The &quot;gun&quot; benchmark problem</span></a></li><li><a class="tocitem" href="#Your-own-NEP-nonlinearity"><span>Your own NEP nonlinearity</span></a></li><li><a class="tocitem" href="#Chebyshev-interpolation"><span>Chebyshev interpolation</span></a></li><li><a class="tocitem" href="#What-now?"><span>What now?</span></a></li><li><a class="tocitem" href="#How-do-I-cite-it?"><span>How do I cite it?</span></a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="methods/">NEP-Solvers</a></li><li><a class="tocitem" href="types/">Types &amp; Data structures</a></li><li><a class="tocitem" href="compute_functions/">Compute functions</a></li><li><a class="tocitem" href="linsolvers/">Linear solvers</a></li><li><a class="tocitem" href="innersolvers/">Projection</a></li><li><a class="tocitem" href="errmeasure/">Measuring the error</a></li><li><a class="tocitem" href="logger/">Logger</a></li><li><a class="tocitem" href="transformations/">Transformations</a></li><li><a class="tocitem" href="deflation/">Deflation</a></li><li><a class="tocitem" href="gallery/">Gallery</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="tocitem" href="tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="tocitem" href="bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="tocitem" href="deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="tocitem" href="tutorial_call_python/">Tutorial 5 (Python 1)</a></li><li><a class="tocitem" href="tutorial_python_call/">Tutorial 6 (Python 2)</a></li><li><a class="tocitem" href="tutorial_matlab1/">Tutorial 7 (MATLAB)</a></li><li><a class="tocitem" href="tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="tocitem" href="tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="tocitem" href="tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li><a class="tocitem" href="tutorial_linsolve/">Tutorial 11 (Linear solvers)</a></li><li><a class="tocitem" href="hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="NEP-PACK"><a class="docs-heading-anchor" href="#NEP-PACK">NEP-PACK</a><a id="NEP-PACK-1"></a><a class="docs-heading-anchor-permalink" href="#NEP-PACK" title="Permalink"></a></h1><p>NEP-PACK is a package with implementations of methods to solve and to manipulate nonlinear eigenvalue problems of the type: Find <span>$(λ,v)\in\mathbb{C}\times\mathbb{C}^n$</span> such that</p><p class="math-container">\[M(λ)v=0\]</p><p>and <span>$v\neq 0$</span>.</p><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>Install it as a registered  package in Julia&#39;s REPL package mode by typing <code>] add Nonline...</code>:</p><pre><code class="nohighlight hljs">julia&gt; ]
(v1.0) pkg&gt; add NonlinearEigenproblems</code></pre><p>Then we can start to load the NEP-PACK package</p><pre><code class="language-julia-repl hljs">julia&gt; using NonlinearEigenproblems</code></pre><p>As a first example we will solve the NEP associated with the matrix polynomial</p><p class="math-container">\[M(λ)=\begin{bmatrix}1&amp;3\newline5&amp;6\end{bmatrix}+
λ\begin{bmatrix}3&amp;4\newline6&amp;6\end{bmatrix}+
λ^2\begin{bmatrix}1&amp;0\newline0&amp;1\end{bmatrix}\]</p><p>The following code creates this NEP, by constructing an object called <a href="types/#NonlinearEigenproblems.NEPTypes.PEP"><code>PEP</code></a>, an abbreviation for polynomial eigenvalue problem. It subsequently solves it using the NEP solution method implemented in the NEP-solver <a href="methods/#NonlinearEigenproblems.NEPSolver.polyeig"><code>polyeig</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; A0=[1.0 3; 5 6]; A1=[3.0 4; 6 6]; A2=[1.0 0; 0 1.0];
julia&gt; nep=PEP([A0,A1,A2])
PEP(2, Array{Float64,2}[[1.0 3.0; 5.0 6.0], [3.0 4.0; 6.0 6.0], [1.0 0.0; 0.0 1.0]])
julia&gt; λ,v=polyeig(nep)
(Complex{Float64}[1.36267+0.0im, -0.824084+0.280682im, -0.824084-0.280682im, -8.7145+0.0im], Complex{Float64}[-1.0+0.0im 0.739183-0.196401im 0.739183+0.196401im 0.627138+0.0im; 0.821812+0.0im -0.501408-0.375337im -0.501408+0.375337im 1.0+0.0im])</code></pre><p>You have now solved your first nonlinear eigenvalue problem with NEP-PACK.</p><p>In order to verify that we have a solution, we can check that  <span>$M(λ)$</span> is singular, with a singular vector <span>$v$</span> such that <span>$M(λ)v=0$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; λ1=λ[1]; v1=v[:,1];
julia&gt; using LinearAlgebra # the norm-function is in this Julia package
julia&gt; norm(A0*v1+λ1*A1*v1+λ1^2*v1)/norm(v1)
1.1502634749464687e-14</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>MATLAB users: Do you have a NEP defined in MATLAB? You can solve MATLAB-defined NEPs with this package.  See <a href="tutorial_matlab1/">the MATLAB tutorial</a>. We also have some MATLAB implementations of the solvers in NEP-PACK in a <a href="https://github.com/nep-pack/NEP-PACK-matlab-reference">separate repository</a>.</p></div></div><h2 id="Accessing-more-complicated-applications"><a class="docs-heading-anchor" href="#Accessing-more-complicated-applications">Accessing more complicated applications</a><a id="Accessing-more-complicated-applications-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-more-complicated-applications" title="Permalink"></a></h2><p>We have made benchmark examples available through the function <a href="gallery/#NonlinearEigenproblems.nep_gallery"><code>nep_gallery</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; size(nep)
(100, 100)
julia&gt; λ,v=mslp(nep,tol=1e-10);
julia&gt; λ
0.05046248970129549 - 7.60684247532422e-16im
julia&gt; size(v)
(100,)
julia&gt; resnorm=norm(compute_Mlincomb(nep,λ,v))
5.178780131881974e-13</code></pre><p>Information about the gallery can be found by typing <code>?nep_gallery</code>. The second argument in the call to <code>nep_gallery</code> is a problem parameter, in this case specifying that the  size of the problem should be <code>100</code>. The example solves the problem with the NEP-algorithm <a href="methods/#NonlinearEigenproblems.NEPSolver.mslp"><code>MSLP</code></a>. The parameter <code>tol</code> specifies the tolerance for iteration termination.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All the NEP-solvers have considerble documentation easily available. Every NEP-solver has documentation accompanied with at least one example, and references to corresponding research papers, which we strongly recommend you to cite if you use the method. This is available to you in Julia&#39;s repl-prompt. Type <code>?mslp</code> and you will see an example how to use <code>mslp</code> and that citation credit should go to <em>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</em>. This documentation is the same as the online documentation under the tab <a href="methods/">NEP-solvers</a>.</p></div></div><h2 id="A-model-of-a-neuron"><a class="docs-heading-anchor" href="#A-model-of-a-neuron">A model of a neuron</a><a id="A-model-of-a-neuron-1"></a><a class="docs-heading-anchor-permalink" href="#A-model-of-a-neuron" title="Permalink"></a></h2><p>The following (delay) differential equation models the interaction of two neurons</p><p class="math-container">\[\dot{x}_1(t)=-\kappa x_1(t)+\beta\tanh(x_1(t-\tau_3))+a_1\tanh(x_2(t-\tau_2))\]</p><p class="math-container">\[\dot{x}_2(t)=-\kappa x_2(t)+\beta\tanh(x_2(t-\tau_3))+a_2\tanh(x_1(t-\tau_1))\]</p><p>See <a href="https://www.jstor.org/stable/3061744?seq=1#page_scan_tab_contents">L. P. Shayer and S. A. Campbell.  Stability, bifurcation and multistability in a system of two coupled neurons with multiple time delays. SIAM J. Applied Mathematics , 61(2):673–700, 2000</a>. It is also available as a first demo in <a href="https://sourceforge.net/projects/ddebiftool/">DDE-BIFTOOL</a>. The linear stability analysis of this problem requires the solution of a nonlinear eigenvalue problem</p><p class="math-container">\[M(λ)=-λI+A_0+A_1e^{-\tau_1λ}+A_2e^{-\tau_2λ}+A_3e^{-\tau_3λ}\]</p><p>where the matrices are the Jacobian at the stationary solution. For the zero stationary solution, the matrices are</p><pre><code class="language-julia-repl hljs">kappa=0.5; a2=2.34; a1=1; beta=-1;
A0=-kappa*[1 0; 0 1];
A1=a2*[0 0; 1 0];
A2=a1*[0 1; 0 0];
A3=beta*[1 0; 0 1];</code></pre><p>We can now create the nonlinear eigenvalue problem and determine the stability by first creating the problem</p><pre><code class="language-julia-repl hljs">julia&gt; tauv=[0;0.2;0.2;1.5];
julia&gt; dep=DEP([A0, A1,   A2, A3],tauv);</code></pre><p>The constructor  <a href="types/#NonlinearEigenproblems.NEPTypes.DEP"><code>DEP</code></a> is an abbreviation for a delay eigenvalue problem, which is a NEP with exponential terms stemming from the stability analysis of a delay-differential equation. See <a href="types/">Types and data-structures</a> for other NEP-types. You can now solve this NEP, for instance, with the <a href="methods/#NonlinearEigenproblems.NEPSolver.iar_chebyshev">infinite Arnoldi method</a>:</p><pre><code class="language-julia-repl hljs">julia&gt; λ,V=iar_chebyshev(dep,maxit=100); # This takes some time the first time is run due to JIT-compiler</code></pre><p>The figure in a demo of DDE-BIFTOOL <a href="http://ddebiftool.sourceforge.net/demos/neuron/html/demo1_stst.html#3">http://ddebiftool.sourceforge.net/demos/neuron/html/demo1_stst.html#3</a> can be directly generated by</p><pre><code class="language-julia hljs">using Gadfly
plot(x=real.(λ),y=imag.(λ), Guide.xlabel(&quot;real(λ)&quot;), Guide.ylabel(&quot;imag(λ)&quot;))</code></pre><img src="index-847f8d2a.svg" alt="Example block output"/><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>This problem is also available in the <code>Gallery</code> by calling <code>dep=nep_gallery(&quot;neuron0&quot;)</code>. Most of the NEPs constructed in the tutorials are also available in corresponding gallery problems. See all gallery problems under <a href="gallery/">NEP Gallery</a>. In particular, note that the problems in the Berlin-Manchester collection of problems NLEVP are also <a href="gallery/#Berlin-Manchester-collection-1">directly available</a>.</p></div></div><h2 id="The-&quot;gun&quot;-benchmark-problem"><a class="docs-heading-anchor" href="#The-&quot;gun&quot;-benchmark-problem">The &quot;gun&quot; benchmark problem</a><a id="The-&quot;gun&quot;-benchmark-problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-&quot;gun&quot;-benchmark-problem" title="Permalink"></a></h2><p>One of the most common benchmark problems for NEPs is the so-called &quot;gun&quot;-problem. It models an electromagnetic cavity, and it is directly available in the NEP-PACK gallery. (See <a href="gallery/#NonlinearEigenproblems.Gallery.nep_gallery">gallery</a> references or type <code>?nep_gallery</code> at the repl-prompt.) This is how you can set it up and solve it with the <a href="methods/#NonlinearEigenproblems.NEPSolver.blocknewton">block Newton method</a>:</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;nlevp_native_gun&quot;);
julia&gt; n=size(nep,1)
julia&gt; S=150^2*[1.0 0; 0 1]; V=[[1 0; 0 1]; zeros(n-2,2)];
julia&gt; (Z,X)=blocknewton(nep,S=S,X=V,logger=1,armijo_factor=0.5,maxit=20)
Iteration 1: Error: 6.081316e+03
Iteration 2: Error: 1.701970e-02 Armijo scaling=0.031250
Iteration 3: Error: 1.814887e-02 Armijo scaling=0.250000
...
Iteration 13: Error: 6.257442e-09
Iteration 14: Error: 2.525942e-15</code></pre><p>This algorithm returns a partial Schur factorization of the NEP, and therefore the eigenvalues of the small matrix <code>Z</code> are eigenvalues of the problem. An eigenpair of the NEP can be extracted by diagonalizing:</p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra
julia&gt; (Λ,P)=eigen(Z);
julia&gt; VV=X*P;  # Construct the eigenvector matrix
julia&gt; v=VV[:,1]; λ=Λ[1]
61330.208714730004 + 63185.15983933589im
julia&gt; norm(compute_Mlincomb(nep,λ,v)) # Very small residual
1.8270553408452648e-16</code></pre><p>If you use the NEP-algorithms for research, please give the author of the algorithm credit by citiation. The recommended citation can be found in the function documentation, e.g., <code>?blocknewton</code>.</p><h2 id="Your-own-NEP-nonlinearity"><a class="docs-heading-anchor" href="#Your-own-NEP-nonlinearity">Your own NEP nonlinearity</a><a id="Your-own-NEP-nonlinearity-1"></a><a class="docs-heading-anchor-permalink" href="#Your-own-NEP-nonlinearity" title="Permalink"></a></h2><p>As an application researcher, we recommend that you first try to express your problem in the following form since it gives access to several efficient routines associated with the NEP, in turn making it possible to use many NEP-solvers. A problem that can be expressed as a (short) <strong>S</strong> um of <strong>P</strong> roducts of <strong>M</strong> atrices and <strong>F</strong> unctions can be represented with the objects of type <a href="types/#NonlinearEigenproblems.NEPTypes.SPMF_NEP"><code>SPMF_NEP</code></a> in NEP-PACK. For instance, a problem with three terms</p><p class="math-container">\[M(λ) = A+λB+e^{\sin(λ/2)}C\]</p><p>can be created by</p><pre><code class="language-julia-repl hljs">julia&gt; A=(1:4)*(1:4)&#39;+I; B=diagm(1 =&gt; [1,2,3]); C=ones(4,4);
julia&gt; f1= λ-&gt; one(λ);
julia&gt; f2= λ-&gt; λ;
julia&gt; f3= λ-&gt; exp(sin(λ/2));
julia&gt; nep=SPMF_NEP([A,B,C],[f1,f2,f3]);</code></pre><p>The NEP is solved by using the NEP-object as a parameter in a call to an algorithm, e.g.,</p><pre><code class="language-julia-repl hljs">julia&gt; v0 = 0.1*[1,-1,1,-1];
julia&gt; λ,v=quasinewton(nep,λ=4,v=v0)
(3.1760990071435193 + 0.0im, Complex{Float64}[2.892363187499394 + 0.0im, -1.6573097795628646 + 0.0im, 0.00729776922332883 + 0.0im, -0.09002519738673213 + 0.0im])</code></pre><p>As usual, you can check that we computed a sensible solution:</p><pre><code class="language-julia-repl hljs">julia&gt; (A+B*λ+C*exp(sin(λ/2)))*v
4-element Array{Complex{Float64},1}:
  -3.489601657766542e-12 + 0.0im
 -1.0118303586944344e-12 + 0.0im
  -9.480334553029193e-13 + 0.0im
  -5.912084880273861e-13 + 0.0im</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The functions <code>f1</code>,<code>f2</code> and <code>f3</code> in the example above have to be defined for scalar values and for matrices (in the <a href="https://en.wikipedia.org/wiki/Matrix_function">matrix function</a> sense, not elementwise sense). This is the reason <code>f1</code> needs to be defined as <code>one(λ)</code>, instead of just <code>1</code>. Fortunately, many elementary functions in Julia already have matrix function implementations, e.g., <code>exp([1 2 ; 3 4])</code> will return the matrix exponential of the given matrix.</p></div></div><h2 id="Chebyshev-interpolation"><a class="docs-heading-anchor" href="#Chebyshev-interpolation">Chebyshev interpolation</a><a id="Chebyshev-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Chebyshev-interpolation" title="Permalink"></a></h2><p>In applications, NEP-nonlinearities may be complicated to implement. Directly using the SPMF-functionality where every function needs to be defined in a matrix function sense may require too much work. In this case you may want to use an approximation method to create a new different NEP object for which the matrix functions are easy to implement (or directly available in the package). We illustrate this property with NEP-PACKs Chebyshev interpolation feature.</p><p>Suppose you have the following NEP, which requires a Bessel function. The Bessel function is analytic, but its matrix function is not easily available.</p><pre><code class="language-julia-repl hljs">julia&gt; using SpecialFunctions; # for the besselj
julia&gt; fv=Vector{Function}(undef,m);
julia&gt; Av=Vector{Matrix{Float64}}(undef,3)
julia&gt; fv[1]=s-&gt;one(s);
julia&gt; Av[1]=[ -2.0  -1.0   8.0; -1.0  0  -1.0;   -2.0   -1.0  -2.0];
julia&gt; fv[2]=s-&gt;s;
julia&gt; Av[2]=[4.0 -7.0  14.0; 8.0  9.0 -13.0; -1.0 -1.0    10.0];
julia&gt; fv[3]=s-&gt;besselj(0, s);
julia&gt; Av[3]=[-7.0 -0.0 -9.0; 8.0  3.0 -3.0;  0.0 13.0  2.0]</code></pre><p>We use <code>SPMF_NEP</code> again, but in order to suppress a warning message indicating that evaluation with a  matrix function is not available we use the keyword <code>check_consistency=false</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; nep=SPMF_NEP(Av,fv,check_consistency=false);</code></pre><p>Note that we cannot directly use the <code>nep</code> object with most NEP-solvers, since we did not provide a matrix function implementation for <code>besselj</code>. Any method requiring a derivative will just throw an error message that a matrix function is not defined. Let us now construct an interpolating Chebyshev polynomial, which we can use instead (since its matrix functions are trivial). The command <a href="types/#NonlinearEigenproblems.NEPTypes.ChebPEP"><code>ChebPEP</code></a>, by default  interpolates a NEP in the interval <code>[-1,1]</code> using Chebyshev points and represent the approximation in a Chebyshev basis:</p><pre><code class="language-julia-repl hljs">julia&gt; cheb=ChebPEP(nep,9,cosine_formula_cutoff=9);</code></pre><p>We can now use an arbitrary method to try to solve this problem, e.g., the <a href="methods/#NonlinearEigenproblems.NEPSolver.newtonqr"><code>newtonqr</code></a> method.</p><pre><code class="language-julia-repl hljs">julia&gt; (λ,v)=newtonqr(cheb,λ=0.0,logger=1)
iter 1 err:0.20552458291903797 λ=0.0 + 0.0im
iter 2 err:0.10317368136012978 λ=-3.1180031985377803 + 0.0im
iter 3 err:0.03898166871714645 λ=-0.5814386400379581 + 0.0im
iter 4 err:0.001421286693333467 λ=-0.4572312118506711 + 0.0im
iter 5 err:1.599526685190599e-6 λ=-0.46101438033594805 + 0.0im
iter 6 err:1.9383172515233692e-12 λ=-0.4610101105535983 + 0.0im
iter 7 err:2.1034235144362163e-17 λ=-0.4610101105484241 + 0.0im
(-0.4610101105484241 + 0.0im, Complex{Float64}[-0.597958+0.0im, 0.322148+0.0im, 1.0+0.0im], Complex{Float64}[-0.257712+0.0im, -0.964465+0.0im, -0.0582387+0.0im])</code></pre><p>This solved the interpolated problem quite accurately, which turns out to be a reasonable approximation of the original problem:</p><pre><code class="language-julia-repl hljs">julia&gt; norm(compute_Mlincomb(nep,λ,v))
1.148749763351579e-9</code></pre><p>The function <code>compute_Mlincomb</code> returns the evaluation of <code>M(λ)*v</code>; see <a href="compute_functions/">the manual section for compute functions</a>.</p><h2 id="What-now?"><a class="docs-heading-anchor" href="#What-now?">What now?</a><a id="What-now?-1"></a><a class="docs-heading-anchor-permalink" href="#What-now?" title="Permalink"></a></h2><p>Now you are ready to try out one of our tutorials <a href="movebc_tutorial/">on artificial boundary conditions</a>, <a href="bemtutorial/">boundary element method</a>, <a href="tutorial_contour/">contour integration</a>, or <a href="deflate_tutorial/">deflation</a>. See also the other tutorials (in the side-bar), or have a look at the examples in <a href="methods/">NEP-solvers</a> and  <a href="gallery/">NEP Gallery</a>.</p><h2 id="How-do-I-cite-it?"><a class="docs-heading-anchor" href="#How-do-I-cite-it?">How do I cite it?</a><a id="How-do-I-cite-it?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-cite-it?" title="Permalink"></a></h2><p>We have a <a href="https://arxiv.org/abs/1811.09592">preprint for this work</a>. If you find this software useful please cite this preprint by using this citation data:</p><pre><code class="language-bibtex hljs">@Misc{,
  author = 	 {E. Jarlebring and M. Bennedich and G. Mele and E. Ringh and P. Upadhyaya},
  title = 	 {{NEP-PACK}: A {Julia} package for nonlinear eigenproblems},
  year = 	 {2018},
  note = 	 {https://github.com/nep-pack},
  eprint = 	 {arXiv:1811.09592},
}</code></pre><p>If you use a specific NEP-solver, please also give credit to the algorithm researcher. Reference to a corresponding algorithm paper can be found by in, e.g., by writing <code>?resinv</code>.</p><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC" alt="To the top"/></p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="methods/">NEP-Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 26 February 2024 06:50">Monday 26 February 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
