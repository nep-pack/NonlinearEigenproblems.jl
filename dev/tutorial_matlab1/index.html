<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 7 (MATLAB) · NEP-PACK</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NEP-PACK</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../methods/">NEP-Solvers</a></li><li><a class="tocitem" href="../types/">Types &amp; Data structures</a></li><li><a class="tocitem" href="../compute_functions/">Compute functions</a></li><li><a class="tocitem" href="../linsolvers/">Linear solvers</a></li><li><a class="tocitem" href="../innersolvers/">Projection</a></li><li><a class="tocitem" href="../errmeasure/">Measuring the error</a></li><li><a class="tocitem" href="../logger/">Logger</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../deflation/">Deflation</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="tocitem" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="tocitem" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="tocitem" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="tocitem" href="../tutorial_call_python/">Tutorial 5 (Python 1)</a></li><li><a class="tocitem" href="../tutorial_python_call/">Tutorial 6 (Python 2)</a></li><li class="is-active"><a class="tocitem" href>Tutorial 7 (MATLAB)</a><ul class="internal"><li><a class="tocitem" href="#A-problem-defined-in-MATLAB"><span>A problem defined in MATLAB</span></a></li><li><a class="tocitem" href="#Approach-1:-Implementation-in-NEP-PACK-(using-Mder_NEP)"><span>Approach 1: Implementation in NEP-PACK (using <code>Mder_NEP</code>)</span></a></li><li><a class="tocitem" href="#Approach-2:-Implementation-in-NEP-PACK-(using-new-type)"><span>Approach 2: Implementation in NEP-PACK (using new type)</span></a></li></ul></li><li><a class="tocitem" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="tocitem" href="../tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="tocitem" href="../tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li><a class="tocitem" href="../tutorial_linsolve/">Tutorial 11 (Linear solvers)</a></li><li><a class="tocitem" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Tutorial 7 (MATLAB)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial 7 (MATLAB)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/tutorial_matlab1.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial:-Solving-NEP-defined-in-MATLAB"><a class="docs-heading-anchor" href="#Tutorial:-Solving-NEP-defined-in-MATLAB">Tutorial: Solving NEP defined in MATLAB</a><a id="Tutorial:-Solving-NEP-defined-in-MATLAB-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial:-Solving-NEP-defined-in-MATLAB" title="Permalink"></a></h1><h2 id="A-problem-defined-in-MATLAB"><a class="docs-heading-anchor" href="#A-problem-defined-in-MATLAB">A problem defined in MATLAB</a><a id="A-problem-defined-in-MATLAB-1"></a><a class="docs-heading-anchor-permalink" href="#A-problem-defined-in-MATLAB" title="Permalink"></a></h2><p>MATLAB is the de-facto standard language for many tasks in scientific computing. If you have a NEP defined in MATLAB, you can quite easily use the NEP-solvers of this package. Below is a description of two ways to solve nonlinear eigenvalue problems defined in MATLAB. There is a cost in terms of efficiency to define your problem in MATLAB, due to overhead associated with communication between the MATLAB and Julia processes. Very large scale problems are recommended to be defined directly in Julia.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To work with NEPs defined in MATLAB you need to have MATLAB installed on your computer. We use the <a href="https://github.com/JuliaInterop/MATLAB.jl">MATLAB interoperability package</a> to link Julia execution with MATLAB execution.</p></div></div><p>Suppose you have the following NEP in MATLAB</p><p class="math-container">\[M(\lambda)=A_0+\lambda A_1+\exp(\lambda A_2),\]</p><p>where <span>$A_1,A_2,A_3$</span> are martices and <span>$\exp$</span> the matrix exponential. The problem can be defined in MATLAB as follows. This is the contents of the file <code>compute_derivative_k.m</code>:</p><pre><code class="language-matlab hljs">function Z=compute_derivative_k(s,k)
     randn(&#39;seed&#39;,0);
     n=10;
     A0=randn(n,n); A1=randn(n,n);
     Z=zeros(n,n);
     if (k==0)
         Z=A0+s*A1;
     end
     if (k==1)
         Z=A1;
     end
     Z=Z+(A1^k)*expm(s*A1);
end</code></pre><p>The function which computes derivative <code>k</code> evaluted in the point <code>s</code>. We assume in the following that the file <code>compute_derivative_k.m</code> is located in the current directory.</p><h2 id="Approach-1:-Implementation-in-NEP-PACK-(using-Mder_NEP)"><a class="docs-heading-anchor" href="#Approach-1:-Implementation-in-NEP-PACK-(using-Mder_NEP)">Approach 1: Implementation in NEP-PACK (using <code>Mder_NEP</code>)</a><a id="Approach-1:-Implementation-in-NEP-PACK-(using-Mder_NEP)-1"></a><a class="docs-heading-anchor-permalink" href="#Approach-1:-Implementation-in-NEP-PACK-(using-Mder_NEP)" title="Permalink"></a></h2><p>The easiest way to create a NEP which is only defined by its derivative computation is by the helper type <a href="../compute_functions/#NonlinearEigenproblems.NEPTypes.Mder_NEP"><code>Mder_NEP</code></a>.</p><pre><code class="language-julia hljs">using NonlinearEigenproblems, MATLAB
nep=Mder_NEP(10,(s,der) -&gt; mat&quot;compute_derivative_k($s,double($der))&quot;);</code></pre><p>The NEP can now be approached with many of the methods in the package, e.g., with a contour integral method (<a href="../methods/#NonlinearEigenproblems.NEPSolver.contour_beyn"><code>contour_beyn</code></a>):</p><pre><code class="language-julia-repl hljs">julia&gt; (λ,V)=contour_beyn(nep, radius=0.6, k=8);
julia&gt; λ
2-element Array{Complex{Float64},1}:
 0.1711954796771912 - 6.401495587242332e-15im
 0.1547216302712358 - 0.16631220583083045im   </code></pre><p>The first argument of the <code>Mder_NEP</code> instantiation is the size of the NEP. The instantiation of the <code>Mder_NEP</code> creates a NEP-object only defined by its matrix derivative functions, given in the call-back function specified by the second argument. In this case, the the function calls a MATLAB process (running in the background completely hidden from the Julia user) and requests a execution of <code>compute_derivate_k</code> with the given arguments. After executing the MATLAB-call, the MATLAB-process sends the matrix back to Julia. In other words, we have coupled the derivative computation of the NEP with a call to MATLAB. More precisely, every call to the <a href="../compute_functions/#NonlinearEigenproblems.NEPCore.compute_Mder"><code>compute_Mder</code></a> function leads to a call to the created MATLAB function. Compare:</p><pre><code class="language-julia-repl hljs">julia&gt; compute_Mder(nep,0.1+0.2im)
10×10 Array{Complex{Float64},2}:
   2.15543-0.101289im     -1.4933-0.0817057im  …    0.220658-0.313894im    0.371533+0.544535im
  0.751339+0.213974im    0.532557+0.359256im         0.58971-0.135805im    -2.65352-0.308557im
 -0.177809-0.383021im     1.46944+0.374974im        0.965219+0.140168im    0.979515-0.603281im
  0.204312-0.300014im   -0.576669+0.630099im         1.94032+0.43922im    -0.803364+0.652243im
 -0.378807+0.511258im    0.590185+0.0812181im      -0.381726-0.138047im     1.30005+0.562022im
   1.58041-0.266624im   -0.347895+0.292268im   …  -0.0826327+0.155039im   -0.691359+0.340299im
  0.105255+0.0940046im  -0.338352-0.443379im        0.546516-0.062307im    0.445814-0.648929im
   1.47467-0.646341im    -1.36607-0.195403im         1.02226-0.0228401im    1.14153+0.576545im
  0.182295-0.143594im    -1.06099+0.492347im        -0.41297-0.409332im   -0.322912-0.219094im
  0.658504-0.190844im     1.21896+0.280606im       -0.563413-0.073228im     1.25092-0.418521im</code></pre><p>with the MATLAB call:</p><pre><code class="language-matlab hljs">&gt;&gt; M=compute_derivative_k(0.1+0.2i,0);
&gt;&gt; M(1:3,1:3) % I don&#39;t want to see the whole matrix
ans =
   2.1554 - 0.1013i  -1.4933 - 0.0817i   0.1131 + 0.0836i
   0.7513 + 0.2140i   0.5326 + 0.3593i  -1.0211 - 0.5134i
  -0.1778 - 0.3830i   1.4694 + 0.3750i   0.2180 + 0.1720i</code></pre><p>You can verify that the output of the call to the <a href="../methods/#NonlinearEigenproblems.NEPSolver.contour_beyn"><code>contour_beyn</code></a>-method is a solution directly in MATLAB:</p><pre><code class="language-matlab hljs">&gt;&gt; s = 0.1547216302712358 - 0.16631220583083045i; % copied from the output above (remember: 1im -&gt; 1i)
&gt;&gt; M=compute_derivative_k(s,0);
&gt;&gt; min(svd(M)) % Matrix is singular if s is a solution
ans =
   1.5239e-15</code></pre><p>NEP-objects in NEP-PACK are defined from compute-functions (as we describe in <a href="../types/">NEPTypes</a>) and in this case we only defined the derivative computation function <code>compute_Mder</code>. Note that the <code>Mder_NEP</code>-type provides default implementations of <a href="../compute_functions/#NonlinearEigenproblems.NEPCore.compute_Mlincomb"><code>compute_Mlincomb</code></a> as well as <a href="../compute_functions/#NonlinearEigenproblems.NEPCore.compute_MM"><code>compute_MM</code></a> (by wrapping calls to <code>compute_Mder</code>) in a way that is hidden from the user, such that we can still use algorithms based on those compute functions. More efficiency can be obtained if these compute functions are also implemented, e.g., by a different MATLAB-function.</p><h2 id="Approach-2:-Implementation-in-NEP-PACK-(using-new-type)"><a class="docs-heading-anchor" href="#Approach-2:-Implementation-in-NEP-PACK-(using-new-type)">Approach 2: Implementation in NEP-PACK (using new type)</a><a id="Approach-2:-Implementation-in-NEP-PACK-(using-new-type)-1"></a><a class="docs-heading-anchor-permalink" href="#Approach-2:-Implementation-in-NEP-PACK-(using-new-type)" title="Permalink"></a></h2><p>We illustrate the extendability of the package by defining our own type, which again uses the MATLAB-package in the background.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The process is also described in the <a href="../bemtutorial/#Implementation-in-NEP-PACK-using-the-Mder_NEP-type-1">BEM tutorial</a>.</p></div></div><p>The size is hardcoded in this example, so we can define a new type of the specific size:</p><pre><code class="language-julia hljs">struct MATLABNEP &lt;: NEP
end
Base.size(nep::MATLABNEP) = (10,10)
Base.size(nep::MATLABNEP,::Int) = 10</code></pre><p>Initiate the MATLAB package and prepare to integrate with NEP-PACK:</p><pre><code class="language-julia hljs">using MATLAB; # requires MATLAB to be installed
mat&quot;addpath(&#39;.&#39;)&quot; # Add path to your m-file
import NonlinearEigenproblems.compute_Mder;
import NonlinearEigenproblems.compute_Mlincomb;
import NonlinearEigenproblems.compute_Mlincomb_from_Mder;</code></pre><p>In this example, the problem is only provided by a function to compute derivatives of <code>M</code>, which we specify by defining a  <code>compute_Mder</code> function. We also specify that linear combinations of derivatives should be computed by calling <code>compute_Mder</code> in the naive way:</p><pre><code class="language-julia hljs">function compute_Mder(::MATLABNEP,s::Number,der::Integer=0)
    return mat&quot;compute_derivative_k(double($s),double($der))&quot;
end
compute_Mlincomb(nep::MATLABNEP,λ::Number,V::AbstractVecOrMat, a::Vector) = compute_Mlincomb_from_Mder(nep,λ,V,a)
compute_Mlincomb(nep::MATLABNEP,λ::Number,V::AbstractVecOrMat) = compute_Mlincomb(nep,λ,V, ones(eltype(V),size(V,2)))</code></pre><p>Now you can instantiate the NEP and use your favorite NEP-solver, in this case we use <a href="../methods/#NonlinearEigenproblems.NEPSolver.newtonqr"><code>newtonqr</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; nep=MATLABNEP();
julia&gt; (λ,v)=newtonqr(nep,λ=-3,logger=1,maxit=30,v=ones(10));
iter 1 err:1.033593309412195 λ=-3.0 + 0.0im
iter 2 err:0.3059246224011592 λ=0.83641207310996 + 0.0im
iter 3 err:0.6000405834026614 λ=-1.7728647881500432 + 0.0im
iter 4 err:0.07375061614602237 λ=-0.7800560594951582 + 0.0im
iter 5 err:0.0093516562758152 λ=-0.8707521093182906 + 0.0im
iter 6 err:8.954564848847882e-5 λ=-0.8840785307305598 + 0.0im
iter 7 err:7.446596609664408e-9 λ=-0.88420751056806 + 0.0im
iter 8 err:1.0942739518352825e-15 λ=-0.884207521294992 + 0.0im</code></pre><p>The residual is small and we have a solution</p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v)
1.0942739518352825e-15</code></pre><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_MATLAB1" alt="To the top"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial_python_call/">« Tutorial 6 (Python 2)</a><a class="docs-footer-nextpage" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Wednesday 6 July 2022 07:44">Wednesday 6 July 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
