<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 5 (Python 1) · NEP-PACK</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NEP-PACK</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../methods/">NEP-Solvers</a></li><li><a class="tocitem" href="../types/">Types &amp; Data structures</a></li><li><a class="tocitem" href="../compute_functions/">Compute functions</a></li><li><a class="tocitem" href="../linsolvers/">Linear solvers</a></li><li><a class="tocitem" href="../innersolvers/">Projection</a></li><li><a class="tocitem" href="../errmeasure/">Measuring the error</a></li><li><a class="tocitem" href="../logger/">Logger</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../deflation/">Deflation</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="tocitem" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="tocitem" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="tocitem" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li class="is-active"><a class="tocitem" href>Tutorial 5 (Python 1)</a><ul class="internal"><li><a class="tocitem" href="#A-problem-defined-in-Python"><span>A problem defined in Python</span></a></li><li><a class="tocitem" href="#Interfacing-Python-code"><span>Interfacing Python code</span></a></li><li><a class="tocitem" href="#Implementation-in-NEP-PACK-(using-Mder_Mlincomb_NEP)"><span>Implementation in NEP-PACK (using <code>Mder_Mlincomb_NEP</code>)</span></a></li><li><a class="tocitem" href="#Implementation-in-NEP-PACK-(using-new-type)"><span>Implementation in NEP-PACK  (using new type)</span></a></li></ul></li><li><a class="tocitem" href="../tutorial_python_call/">Tutorial 6 (Python 2)</a></li><li><a class="tocitem" href="../tutorial_matlab1/">Tutorial 7 (MATLAB)</a></li><li><a class="tocitem" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="tocitem" href="../tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="tocitem" href="../tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li><a class="tocitem" href="../tutorial_linsolve/">Tutorial 11 (Linear solvers)</a></li><li><a class="tocitem" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Tutorial 5 (Python 1)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial 5 (Python 1)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/tutorial_call_python.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial:-Solving-NEP-defined-in-Python"><a class="docs-heading-anchor" href="#Tutorial:-Solving-NEP-defined-in-Python">Tutorial: Solving NEP defined in Python</a><a id="Tutorial:-Solving-NEP-defined-in-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial:-Solving-NEP-defined-in-Python" title="Permalink"></a></h1><h2 id="A-problem-defined-in-Python"><a class="docs-heading-anchor" href="#A-problem-defined-in-Python">A problem defined in Python</a><a id="A-problem-defined-in-Python-1"></a><a class="docs-heading-anchor-permalink" href="#A-problem-defined-in-Python" title="Permalink"></a></h2><p>Julia is a great programming language, but your problem may not be easy to define in Julia code, e.g., for legacy reasons. Don&#39;t let that prevent you from using the package. We now show how a problem defined in Python can be solved with NEP-PACK.</p><p>One of the advantages of the Julia language is that it is reasonably easy to interface with code written in other languages. In this tutorial we work with Python, and the two following tutorials we interface <a href="../tutorial_matlab1/">MATLAB</a> and <a href="../tutorial_fortran1/">fortran</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To work with NEPs defined in <a href="https://www.python.org/">Python</a> you need to have Python installed on your computer. With the package <a href="https://github.com/JuliaPy/PyCall.jl">PyCall</a> it is possible to let Julia control execution of Python code.</p></div></div><p>The following python code correspond to the NEP</p><p class="math-container">\[M(λ)=\begin{bmatrix}1&amp;2\newline3&amp;4\end{bmatrix}+
λ\begin{bmatrix}0&amp;0\newline0&amp;1\end{bmatrix}+
e^λ\begin{bmatrix}1&amp;1\newline1&amp;1\end{bmatrix}\]</p><p>The code has two functions: one that can compute an evaluation of <span>$M(λ)$</span> and one that can form a linear combination of derivatives</p><p class="math-container">\[  \sum_{i=1}^kM^{(k)}(λ)x_i.\]</p><p>Put a file  <code>mynep.py</code>  in your current directory with the following contents:</p><pre><code class="language-python hljs">import numpy as np;
import cmath as m;
def compute_M(s):
    &quot;&quot;&quot;Compute the matrix M(s) for a given eigenvalue approximation&quot;&quot;&quot;
    A=np.matrix(&#39;1 2; 3 4&#39;);  B=np.matrix(&#39;0 0; 0 1&#39;);   C=np.matrix(&#39;1 1; 1 1&#39;);
    M=A+s*B+m.exp(s)*C
    return M

def compute_Mlincomb(s,X):
    &quot;&quot;&quot;Compute the linear combination of derivatives for value s&quot;&quot;&quot;
    A=np.matrix(&#39;1 2; 3 4&#39;);  B=np.matrix(&#39;0 0; 0 1&#39;);   C=np.matrix(&#39;1 1; 1 1&#39;);

    X=np.matrix(X) # Explicitly convert to matrix
    z=np.zeros((2,1));
    # Zeroth derivative
    z=z+A*X[:,0]
    z=z+B*(s*X[:,0])
    z=z+C*(m.exp(s)*X[:,0])

    # First derivative
    if (np.size(X,1)&gt;1):
        z=z+B*(X[:,1])+C*(m.exp(s)*X[:,1])
    # Higher derivatives
    if (np.size(X,1)&gt;1):
        for k in range(2,np.size(X,1)):
            z=z+C*(m.exp(s)*X[:,k])
    return z</code></pre><h2 id="Interfacing-Python-code"><a class="docs-heading-anchor" href="#Interfacing-Python-code">Interfacing Python code</a><a id="Interfacing-Python-code-1"></a><a class="docs-heading-anchor-permalink" href="#Interfacing-Python-code" title="Permalink"></a></h2><p>We first initiate <code>PyCall</code> as follows. Note that the <code>pushfirst!</code> command is needed, otherwise the module defined in the file <code>mynep.py</code> we gave above will not be found. (<code>PyCall</code> does not include the current directory in the module search path by default.)</p><pre><code class="language-julia hljs">using PyCall;
pushfirst!(PyVector(pyimport(&quot;sys&quot;).&quot;path&quot;), &quot;&quot;);
mynep = pyimport(&quot;mynep&quot;)</code></pre><p>This gives us direct access to the <code>compute_M</code> and <code>compute_Mlincomb</code> functions from python, e.g., if we want to evaluate <span>$M(3+3i)$</span> we run this code</p><pre><code class="language-julia-repl hljs">julia&gt; mynep.compute_M(3+3im)
2×2 Array{Complex{Float64},2}:
 -18.8845+2.83447im  -17.8845+2.83447im
 -16.8845+2.83447im  -12.8845+5.83447im</code></pre><h2 id="Implementation-in-NEP-PACK-(using-Mder_Mlincomb_NEP)"><a class="docs-heading-anchor" href="#Implementation-in-NEP-PACK-(using-Mder_Mlincomb_NEP)">Implementation in NEP-PACK (using <code>Mder_Mlincomb_NEP</code>)</a><a id="Implementation-in-NEP-PACK-(using-Mder_Mlincomb_NEP)-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-in-NEP-PACK-(using-Mder_Mlincomb_NEP)" title="Permalink"></a></h2><p>We can now use the Python interface to define a NEP in Julia. The type <a href="../compute_functions/#NonlinearEigenproblems.NEPTypes.Mder_Mlincomb_NEP"><code>Mder_Mlincomb_NEP</code></a> is a special type made for this situation. The required inputs are the size, called <code>n</code>; a function to compute <span>$M(λ)$</span>, called <code>fder</code>; and a function to compute <span>$\sum_{i=1}^kM^{(k)}(λ)x_i$</span>, called <code>flincomb</code>. The extra <code>0</code> passed in the definition defines that <span>$M(λ)$</span> is available, but no higher derivatives.</p><pre><code class="language-julia hljs">using NonlinearEigenproblems
n=2;
fder = (λ,der) -&gt; mynep.compute_M(complex(λ));
flincomb =  (λ,X) -&gt; mynep.compute_Mlincomb(complex(λ),complex(reshape(X,size(X,1),size(X,2))));
nep=Mder_Mlincomb_NEP(n,fder,0,flincomb);</code></pre><p>We can compare the Python call with the NEP-PACK call</p><pre><code class="language-julia-repl hljs">julia&gt; compute_Mder(nep,3+3im)
2×2 Array{Complex{Float64},2}:
 -18.8845+2.83447im  -17.8845+2.83447im
 -16.8845+2.83447im  -12.8845+5.83447im</code></pre><p>We continue by computing some eigenvalues of the the NEP using the Infinite Arnoldi method (<a href="../methods/#NonlinearEigenproblems.NEPSolver.iar"><code>iar</code></a>).</p><pre><code class="language-julia-repl hljs">julia&gt; (λ,v)=iar(nep,v=[1;1],σ=1,logger=0,neigs=3);
julia&gt; λ
3-element Array{Complex{Float64},1}:
  0.6748316143423988 + 7.336803319821954e-19im
 0.11742590291190791 - 3.649946317867008im    
 0.11742590291191168 + 3.6499463178670144im  </code></pre><p>We can verify that we actually computed solutions as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; norm(compute_Mlincomb(nep,λ[1],v[:,1]))
1.106424240899132e-15</code></pre><h2 id="Implementation-in-NEP-PACK-(using-new-type)"><a class="docs-heading-anchor" href="#Implementation-in-NEP-PACK-(using-new-type)">Implementation in NEP-PACK  (using new type)</a><a id="Implementation-in-NEP-PACK-(using-new-type)-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-in-NEP-PACK-(using-new-type)" title="Permalink"></a></h2><p>The previous implementation utilizes the convenience type <code>Mder_Mlincomb_NEP</code>, and solves the problem in a satisfactory way. Nevertheless, to illustrate more of the inner workings of NEP-PACK we solve the problem in a second way, by defining our own type. The first thing we need to do is to define the <code>size</code>-function, which is hard-coded in this example.</p><pre><code class="language-julia hljs">import NonlinearEigenproblems.size # We will overload these functions
import NonlinearEigenproblems.compute_Mlincomb;
import NonlinearEigenproblems.compute_Mder;
struct PyNEP &lt;: NEP # Set up a dummy type for our specific NEP
end
size(::PyNEP) = (2,2) # Trivial function definitions
size(::PyNEP,::Int) = 2</code></pre><p>As explained in <a href="../types/">NEPTypes</a>, a NEP is defined by its compute functions. Here is how you define two compute functions that call our python-defined NEP:</p><pre><code class="language-julia hljs">function compute_Mder(::PyNEP,s::Number,der::Integer=0)
    if (der&gt;0)
        error(&quot;Higher derivatives not implemented&quot;);
    end
    return mynep.compute_M(complex(s)); # Call python
end
function compute_Mlincomb(::PyNEP,s::Number,X::AbstractVecOrMat)
    XX=complex(reshape(X,size(X,1),size(X,2))) # Turn into a matrix
    return mynep.compute_Mlincomb(complex(s),XX); # Call python
end</code></pre><p>We now create an object of our newly created type and we can access the NEP with the NEP-PACK specific compute functions:</p><pre><code class="language-julia-repl hljs">julia&gt; pynep=PyNEP();
julia&gt; compute_Mder(pynep,3+3im)
2×2 Array{Complex{Float64},2}:
 -18.8845+2.83447im  -17.8845+2.83447im
 -16.8845+2.83447im  -12.8845+5.83447im</code></pre><p>The behavior is the same as above. Since a NEP-object is defined by its compute functions, we can now use many NEP-solvers to solve this problem. We again use <a href="../methods/#NonlinearEigenproblems.NEPSolver.iar"><code>iar</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; (λ2,v2)=iar(pynep,v=[1;1],σ=1,logger=0,neigs=3);
julia&gt; λ2
3-element Array{Complex{Float64},1}:
  0.6748316143423988 + 7.336803319821954e-19im
 0.11742590291190791 - 3.649946317867008im    
 0.11742590291191168 + 3.6499463178670144im   </code></pre><p>We can compare with the eigenvalues computed above and, again, verify that we actually computed solutions as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; norm(compute_Mlincomb(pynep,λ2[1],v2[:,1]))
1.106424240899132e-15</code></pre><p>Residual is almost zero, so we have a solution.</p><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_PYTHON1" alt="To the top"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../deflate_tutorial/">« Tutorial 4 (Deflation)</a><a class="docs-footer-nextpage" href="../tutorial_python_call/">Tutorial 6 (Python 2) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 2 October 2022 12:57">Sunday 2 October 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
