<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Projection · NEP-PACK</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NEP-PACK</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../methods/">NEP-Solvers</a></li><li><a class="tocitem" href="../types/">Types &amp; Data structures</a></li><li><a class="tocitem" href="../compute_functions/">Compute functions</a></li><li><a class="tocitem" href="../linsolvers/">Linear solvers</a></li><li class="is-active"><a class="tocitem" href>Projection</a><ul class="internal"><li><a class="tocitem" href="#Inner-solvers"><span>Inner solvers</span></a></li><li><a class="tocitem" href="#Inner-solvers:-Advanced-usage"><span>Inner solvers: Advanced usage</span></a></li><li><a class="tocitem" href="#Projection-2"><span>Projection</span></a></li><li><a class="tocitem" href="#Rayleigh-functional-computation"><span>Rayleigh functional computation</span></a></li></ul></li><li><a class="tocitem" href="../errmeasure/">Measuring the error</a></li><li><a class="tocitem" href="../logger/">Logger</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../deflation/">Deflation</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="tocitem" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="tocitem" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="tocitem" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="tocitem" href="../tutorial_call_python/">Tutorial 5 (Python 1)</a></li><li><a class="tocitem" href="../tutorial_python_call/">Tutorial 6 (Python 2)</a></li><li><a class="tocitem" href="../tutorial_matlab1/">Tutorial 7 (MATLAB)</a></li><li><a class="tocitem" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="tocitem" href="../tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="tocitem" href="../tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li><a class="tocitem" href="../tutorial_linsolve/">Tutorial 11 (Linear solvers)</a></li><li><a class="tocitem" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Projection</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Projection</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/innersolvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Projection"><a class="docs-heading-anchor" href="#Projection">Projection</a><a id="Projection-1"></a><a class="docs-heading-anchor-permalink" href="#Projection" title="Permalink"></a></h1><p>Many NEP-solvers are based on a computation of a solution to a projected problem, i.e., if <span>$V,W\in\mathbb{R}^{n\times p}$</span> we need to solve the (smaller) NEP</p><p class="math-container">\[W^HM(λ)Vz=0\]</p><p>This is sometimes called a nonlinear Rayleigh-Ritz procedure, or a direct projection. These are <em>inner solvers</em> for many NEP-solvers.</p><p>NEP-PACK provides a framework to handle projected problems and inner solves. This is implemented into two separate components:</p><ul><li><a href="#Projection-1">Projection</a>: As a user (or NEP-solver developer) you can create a new object corresponding to the projection. In NEP-PACK, the projection is again an object of with type inheriting from <a href="../types/#NonlinearEigenproblems.NEPCore.NEP"><code>NEP</code></a>. More precisely, it is a <a href="#NonlinearEigenproblems.NEPTypes.Proj_NEP"><code>Proj_NEP</code></a> which you normally create with the function <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP</code></a>.</li><li><a href="#Inner-solvers">Inner solvers</a>: Since the projected problem is again a <code>NEP</code>, in principle any of the NEP-solvers of this package can be used. This is handled by the <code>InnerSolver</code> objects which are wrappers for corresponding NEP-solvers such that we can pass appropriate parameters to the inner soler. The inner solver is controlled by the <code>inner_solver_method</code> keyword in many NEP-solvers. By default <a href="#NonlinearEigenproblems.NEPSolver.DefaultInnerSolver"><code>DefaultInnerSolver</code></a> is used.</li></ul><p>As a NEP-user, you often do not need to care about how the projection is handled, e.g., if you use the type <a href="../types/#NonlinearEigenproblems.NEPTypes.SPMF_NEP"><code>SPMF_NEP</code></a> with only a few terms. For instance, if you wish to use the infinite Arnoldi method (<a href="../methods/#NonlinearEigenproblems.NEPSolver.iar"><code>iar</code></a>) to handle the project solves in the nonlinear Arnoldi method (<a href="../methods/#NonlinearEigenproblems.NEPSolver.nlar"><code>nlar</code></a>), you can call <code>nlar</code> with the kwarg <code>inner_solver_method=</code><a href="#NonlinearEigenproblems.NEPSolver.IARInnerSolver"><code>IARInnerSolver</code></a><code>()</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0_tridiag&quot;);
julia&gt; λ,v=nlar(nep,neigs=1,inner_solver_method=IARInnerSolver(),logger=1);
Using inner solver IARInnerSolver(1.0e-13, 80, :ones, false, NonlinearEigenproblems.NEPSolver.iar)
iter 1 err:0.07075594099201046 λ=-0.09271600160844096 + 0.03235352263155604im
iter 2 err:0.03648528716335285 λ=0.1565592513189133 + 0.013613366856692472im
iter 3 err:0.026208926915836202 λ=-0.03227579276149921 - 0.02208846862836847im
iter 4 err:0.007172980379743359 λ=-0.05583493095814305 - 0.003087442900200613im
iter 5 err:0.006924911617556792 λ=-0.05401508521132263 + 0.001517986336058301im
iter 6 err:0.002090878656094346 λ=-0.05536501763852141 + 0.00024284078743963842im
iter 7 err:0.0006103719429985026 λ=-0.05575237680802954 - 0.00013474280139834488im
iter 8 err:0.0002665363571995074 λ=-0.05558344084437247 + 6.558335069789856e-6im
iter 9 err:0.023093036823993347 λ=-0.02304829345220316 + 0.0005911146839749534im
iter 10 err:1.092985097378946e-5 λ=-0.055653357185449566 - 2.575336159079228e-6im
iter 11 err:5.316449394914625e-7 λ=-0.05565515933487699 + 2.446717728666673e-7im
iter 12 err:0.016299715925824968 λ=0.023211712543947764 - 0.033813269858071315im
iter 13 err:4.899222816433482e-8 λ=-0.05565520569884035 - 2.0175841868490324e-8im
iter 14 err:4.320444084682331e-9 λ=-0.055655212526421895 + 1.2690665519371834e-9im
iter 15 err:7.639277885601529e-10 λ=-0.05565521363070881 + 3.971813908747728e-11im
iter 16 err:4.941632484271334e-11 λ=-0.055655213920101095 - 7.493472629149413e-12im
iter 17 err:0.010663980713333146 λ=0.008967322670902417 + 0.016345149953039387im
iter 18 err:3.2317477531099844e-12 λ=-0.05565521393097803 - 6.246051566770699e-13im
iter 19 err:2.3964655361108506e-13 λ=-0.05565521393184677 + 6.221189257479347e-14im
iter 20 err:1.1735483724254833e-13 λ=-0.055655213931828935 + 2.058434802154811e-15im
iter 21 err:8.164760090914088e-15 λ=-0.055655213931847865 + 7.498992677576017e-16im
****** 1 converged to eigenvalue: -0.055655213931847865 + 7.498992677576017e-16im errmeasure:8.164760090914088e-15</code></pre><p>The logging of the inner solver is controlled by the kwarg <code>inner_logger</code>, which follows the same framework as the standard <a href="../logger/">NEP-PACK Logger</a>. This produces very verbose output illustrating also the convergence of the inner solve:</p><pre><code class="language-julia-repl hljs">julia&gt; λ,v=nlar(nep,neigs=1,inner_solver_method=IARInnerSolver(),logger=1,inner_logger=1);

Using inner solver IARInnerSolver(1.0e-13, 80, :ones, false, NonlinearEigenproblems.NEPSolver.iar)
-
--
---
----
-----
------
=------
+-------
iter 1 err:0.06907648709827012 λ=-0.13302652304722704 + 0.0499583011875092im
-
--
---
----
-----
------
=------
+-------
iter 2 err:0.03702238592099922 λ=0.08696844790344242 + 0.010741310688729204im
-
--
---
----
-----
------
-------
=-------
+=-------
iter 3 err:0.029408773621139236 λ=0.0076466477038438325 - 0.07172981749577159im
-
--
---
----
-----
------
-------
--------
+--------
...</code></pre><p><a href="#Rayleigh-functional-computation">Rayleigh functional computation</a>, which corresponds to projection with <span>$p=1$</span>, is also handled with this framework.</p><h2 id="Inner-solvers"><a class="docs-heading-anchor" href="#Inner-solvers">Inner solvers</a><a id="Inner-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Inner-solvers" title="Permalink"></a></h2><p>The inner solvers inherit from <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>. The following inner solvers are available by default.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.NewtonInnerSolver" href="#NonlinearEigenproblems.NEPSolver.NewtonInnerSolver"><code>NonlinearEigenproblems.NEPSolver.NewtonInnerSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NewtonInnerSolver
function NewtonInnerSolver(;tol=1e-13,maxit=80,starting_vector=:Vk,
                           newton_function=augnewton)</code></pre><p>Uses a Newton-like method to solve the inner problem, with tolerance, and maximum number of iterations given by <code>tol</code> and <code>maxit</code>. The starting vector can be <code>:ones</code>, <code>:randn</code>, or <code>:Vk</code>. The value <code>:Vk</code> specifies the use of the outer NEP-solver keyword argument (<code>Vk</code>). This is typically the previous iterate in the outer method.</p><p>The kwarg <code>newton_function</code>, specifies a <code>Function</code> which is called. The type supports <a href="../methods/#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a>, <a href="../methods/#NonlinearEigenproblems.NEPSolver.newton"><code>newton</code></a>, <a href="../methods/#NonlinearEigenproblems.NEPSolver.resinv"><code>resinv</code></a> <a href="../methods/#NonlinearEigenproblems.NEPSolver.quasinewton"><code>quasinewton</code></a>, <a href="../methods/#NonlinearEigenproblems.NEPSolver.newtonqr"><code>newtonqr</code></a>. In principle it can be any method which takes the same keyword arguments as these methods.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/inner_solver.jl#L61-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.IARInnerSolver" href="#NonlinearEigenproblems.NEPSolver.IARInnerSolver"><code>NonlinearEigenproblems.NEPSolver.IARInnerSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IARInnerSolver
function IARInnerSolver(;tol=1e-13,maxit=80,
           starting_vector=:ones,normalize_DEPs=:auto,
           iar_function=iar)</code></pre><p>Uses <a href="../methods/#NonlinearEigenproblems.NEPSolver.iar"><code>iar</code></a>, <a href="../methods/#NonlinearEigenproblems.NEPSolver.tiar"><code>tiar</code></a> or <a href="../methods/#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> to solve the inner problem, with tolerance, and maximum number of iterations given by <code>tol</code> and <code>maxit</code>. The starting vector can be <code>:ones</code> or <code>:randn</code>. The <code>iar_function</code> can be <code>iar</code>, <code>tiar</code> or <code>iar_chebyshev</code> (or any function taking the same parameters as input). <code>normalize_DEPs</code> determines if the we should carry out precomputation and make sure the projection of a <a href="../types/#NonlinearEigenproblems.NEPTypes.DEP"><code>DEP</code></a>  is again a <code>DEP</code> (which can speed up performance). It can take the value <code>true</code>, <code>false</code> or <code>:auto</code>. <code>:auto</code> sets it to true if we use the <code>iar_chebyshev</code> solver.</p><p>The kwarg <code>iar_function</code>, specifies a <code>Function</code> which is called. Examples of functions are <code>iar</code> and <code>iar_chebyshev</code>. It can be any NEP-solver which takes the same keyword arguments as these methods.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/inner_solver.jl#L107-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.IARChebInnerSolver" href="#NonlinearEigenproblems.NEPSolver.IARChebInnerSolver"><code>NonlinearEigenproblems.NEPSolver.IARChebInnerSolver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function IARChebInnerSolver(;tol=1e-13,maxit=80,starting_vector=:ones,
                            normalize_DEPs=true)</code></pre><p>Uses <a href="../methods/#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> to solve the inner problem. See <a href="#NonlinearEigenproblems.NEPSolver.IARInnerSolver"><code>IARInnerSolver</code></a> for keyword argument documentation.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.IARInnerSolver"><code>IARInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/inner_solver.jl#L153-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.ContourBeynInnerSolver" href="#NonlinearEigenproblems.NEPSolver.ContourBeynInnerSolver"><code>NonlinearEigenproblems.NEPSolver.ContourBeynInnerSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ContourBeynInnerSolver &lt;: InnerSolver
function ContourBeynInnerSolver(;tol=sqrt(eps(real(Float64))),
                                radius=:auto,N=1000)</code></pre><p>Uses <a href="../methods/#NonlinearEigenproblems.NEPSolver.contour_beyn"><code>contour_beyn</code></a> to solve the inner problem, with radius and number of quadrature nodes, given by <code>radius</code> and <code>n</code>. If the variable <code>radius</code> is set to <code>:auto</code>, the integration radius will be automatically selected by using the eigenvalue approximations specified by the outer solver.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/inner_solver.jl#L181-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.PolyeigInnerSolver" href="#NonlinearEigenproblems.NEPSolver.PolyeigInnerSolver"><code>NonlinearEigenproblems.NEPSolver.PolyeigInnerSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PolyeigInnerSolver &lt;: InnerSolver
function PolyeigInnerSolver()</code></pre><p>Specifies the use of <a href="../methods/#NonlinearEigenproblems.NEPSolver.polyeig"><code>polyeig</code></a> to solve the inner problem. This is intended for NEPs of the type <a href="../types/#NonlinearEigenproblems.NEPTypes.PEP"><code>PEP</code></a>.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/inner_solver.jl#L95-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.SGIterInnerSolver" href="#NonlinearEigenproblems.NEPSolver.SGIterInnerSolver"><code>NonlinearEigenproblems.NEPSolver.SGIterInnerSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SGIterInnerSolver &lt;: InnerSolver</code></pre><p>Uses <a href="../methods/#NonlinearEigenproblems.NEPSolver.sgiter"><code>sgiter</code></a> to solve the inner problem.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/inner_solver.jl#L171-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.NleigsInnerSolver" href="#NonlinearEigenproblems.NEPSolver.NleigsInnerSolver"><code>NonlinearEigenproblems.NEPSolver.NleigsInnerSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NleigsInnerSolver &lt;: InnerSolver
function NleigsInnerSolver(;Σ= :auto,nodes =:auto, tol=1e-6 )</code></pre><p>Uses <a href="../methods/#NonlinearEigenproblems.NEPSolver.nleigs"><code>nleigs</code></a> to solve the inner problem, in the region <code>Σ</code> with shifts <code>nodes</code> and with tolerance <code>tol</code>. If the variable <code>Σ</code> is set to <code>:auto</code>, the region <code>Σ</code> will be set by using the eigenvalues approximations. See <a href="../methods/#NonlinearEigenproblems.NEPSolver.nleigs"><code>nleigs</code></a> for description of parameters.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/inner_solver.jl#L202-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.DefaultInnerSolver" href="#NonlinearEigenproblems.NEPSolver.DefaultInnerSolver"><code>NonlinearEigenproblems.NEPSolver.DefaultInnerSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DefaultInnerSolver &lt;: InnerSolver</code></pre><p>Dispatches a version of <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a> based on the type of the NEP provided. This function tries to automatically detect which solver is recommended.</p><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>InnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/inner_solver.jl#L49-L57">source</a></section></article><h2 id="Inner-solvers:-Advanced-usage"><a class="docs-heading-anchor" href="#Inner-solvers:-Advanced-usage">Inner solvers: Advanced usage</a><a id="Inner-solvers:-Advanced-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Inner-solvers:-Advanced-usage" title="Permalink"></a></h2><p>You can define your own inner solver by inheriting from <code>InnerSolver</code> and implementing the function <code>inner_solve</code>. Since the <code>inner_solve</code> obtains information from the solver via keyword arguments, you need to end your method signature with <code>kwargs...)</code>.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.InnerSolver" href="#NonlinearEigenproblems.NEPSolver.InnerSolver"><code>NonlinearEigenproblems.NEPSolver.InnerSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type InnerSolver</code></pre><p>Structs inheriting from this type are used to solve inner problems in an inner-outer iteration.</p><p>The <code>InnerSolver</code> objects are passed to the NEP-algorithms, which uses it to dispatch the correct version of the function <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a>. Utilizes existing implementations of NEP-solvers and <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a> acts as a wrapper to these.</p><p><strong>Example</strong></p><p>There is a <a href="#NonlinearEigenproblems.NEPSolver.DefaultInnerSolver"><code>DefaultInnerSolver</code></a> that dispatches an inner solver based on the provided NEP. However, this example shows how you can force <a href="../methods/#NonlinearEigenproblems.NEPSolver.nlar"><code>nlar</code></a> to use the <a href="#NonlinearEigenproblems.NEPSolver.IARInnerSolver"><code>IARInnerSolver</code></a> for a PEP.</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;pep0&quot;, 100);
julia&gt; λ,v = nlar(nep, inner_solver_method=NEPSolver.IARInnerSolver(), neigs=1, num_restart_ritz_vecs=1, maxit=70, tol=1e-8);
julia&gt; norm(compute_Mlincomb(nep,λ[1],vec(v)))
8.68118417430353e-9</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>inner_solve</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.DefaultInnerSolver"><code>DefaultInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.NewtonInnerSolver"><code>NewtonInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.PolyeigInnerSolver"><code>PolyeigInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.IARInnerSolver"><code>IARInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.IARChebInnerSolver"><code>IARChebInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.SGIterInnerSolver"><code>SGIterInnerSolver</code></a>, <a href="#NonlinearEigenproblems.NEPSolver.ContourBeynInnerSolver"><code>ContourBeynInnerSolver</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/inner_solver.jl#L18-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.inner_solve" href="#NonlinearEigenproblems.NEPSolver.inner_solve"><code>NonlinearEigenproblems.NEPSolver.inner_solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inner_solve(is::InnerSolver,T_arit,nep;kwargs...)</code></pre><p>Solves the projected linear problem with solver specied with <code>is</code>. This is to be used as an inner solver in an inner-outer iteration. T specifies which method to use. The most common choice is <a href="#NonlinearEigenproblems.NEPSolver.DefaultInnerSolver"><code>DefaultInnerSolver</code></a>. The function returns <code>(λv,V)</code> where <code>λv</code> is an array of eigenvalues and <code>V</code> a matrix with corresponding vectors. The struct <code>T_arit</code> defines the arithmetics used in the outer iteration and should prefereably also be used in the inner iteration.</p><p>Different inner_solve methods take different kwargs. These are standardized kwargs:</p><ul><li><code>neigs</code>: Number of wanted eigenvalues (but less or more may be returned)</li><li><code>σ</code>: target specifying where eigenvalues</li><li><code>λv</code>, <code>V</code>: Vector/matrix of guesses to be used as starting values</li><li><code>j</code>: the jth eigenvalue in a min-max characterization</li><li><code>tol</code>: Termination tolarance for inner solver</li><li><code>inner_logger</code>: Determines how the inner solves are logged. See <a href="../logger/#NonlinearEigenproblems.NEPCore.Logger"><code>Logger</code></a> for further references</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/inner_solver.jl#L223-L242">source</a></section></article><h2 id="Projection-2"><a class="docs-heading-anchor" href="#Projection-2">Projection</a><a class="docs-heading-anchor-permalink" href="#Projection-2" title="Permalink"></a></h2><p>The NEP-PACK functionality for projected problems are represented by <a href="#Projection-types-1">projection types</a>. Normally, the projection is created by <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP</code></a> from a standard NEP. After creating a projected NEP, you can set the projection subspace (represented by the matrices <code>V</code> and <code>W</code>) using <a href="#NonlinearEigenproblems.NEPTypes.set_projectmatrices!"><code>set_projectmatrices!</code></a> or <a href="#NonlinearEigenproblems.NEPTypes.expand_projectmatrices!"><code>expand_projectmatrices!</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; A=[1 0 0; 0 1.0 0; 0 0 1]; B=[1 2 3; 3 3 3 ; 4 -1 -1.0];
julia&gt; nep=SPMF_NEP([A, B], [s-&gt;s, s-&gt;s^5]);
julia&gt; pnep=create_proj_NEP(nep);
julia&gt; W=[4 1 ; 6 1  ; 6.0 2]; V=[3 3;3 4.0;4.0 -1];
julia&gt; set_projectmatrices!(pnep,W,V); # modifies pnep
julia&gt; λ=3.0+1im;
julia&gt; W&#39;*compute_Mder(nep,λ)*V
2×2 Array{Complex{Float64},2}:
 -3366.0+92958.0im  -2238.0+61334.0im
  -690.0+19290.0im   -513.0+13909.0im
julia&gt; compute_Mder(pnep,λ)
2×2 Array{Complex{Float64},2}:
 -3366.0+92958.0im  -2238.0+61334.0im
  -690.0+19290.0im   -513.0+13909.0im</code></pre><p>Effectively, the <code>Proj_NEP</code> creates <a href="../compute_functions/">compute functions</a>, which are designed to be as efficient as possible.</p><h3 id="Projection-functions"><a class="docs-heading-anchor" href="#Projection-functions">Projection functions</a><a id="Projection-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Projection-functions" title="Permalink"></a></h3><p>You can create a projected NEP with <code>create_proj_NEP</code>, and specify the projection space with <a href="#NonlinearEigenproblems.NEPTypes.set_projectmatrices!"><code>set_projectmatrices!</code></a> and <a href="#NonlinearEigenproblems.NEPTypes.expand_projectmatrices!"><code>expand_projectmatrices!</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.create_proj_NEP" href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>NonlinearEigenproblems.NEPTypes.create_proj_NEP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pnep=create_proj_NEP(orgnep::ProjectableNEP[,maxsize [,T]])</code></pre><p>Create a NEP representing a projected problem <span>$N(λ)=W^HM(λ)V$</span>,  where the base NEP is represented by <code>orgnep</code>. The optional parameter <code>maxsize::Int</code> determines how large the projected problem can be and <code>T</code> is the Number type used for the projection matrices (default <code>ComplexF64</code>). These are needed for memory preallocation reasons. Use <a href="#NonlinearEigenproblems.NEPTypes.set_projectmatrices!"><code>set_projectmatrices!</code></a> and <a href="#NonlinearEigenproblems.NEPTypes.expand_projectmatrices!"><code>expand_projectmatrices!</code></a>  to specify projection matrices <span>$V$</span> and <span>$W$</span>.</p><p><strong>Example:</strong></p><p>The following example illustrates that a projection of a <code>NEP</code> is also a <code>NEP</code> and we can for instance call <code>compute_Mder</code> on it:</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; V=Matrix(1.0*I,size(nep,1),2);
julia&gt; W=Matrix(1.0*I,size(nep,1),2);
julia&gt; pnep=create_proj_NEP(nep);
julia&gt; set_projectmatrices!(pnep,W,V);
julia&gt; compute_Mder(pnep,3.0)
2×2 Array{Complex{Float64},2}:
  6.08082+0.0im  -5.47481+0.0im
 0.986559+0.0im  -6.98165+0.0im
julia&gt; W&#39;*compute_Mder(nep,3.0)*V  # Gives the same result
2×2 Array{Float64,2}:
 6.08082   -5.47481
 0.986559  -6.98165</code></pre><p>If you know that you will only use real projection matrices, you can specify this in at the creation:</p><pre><code class="language-julia-repl hljs">julia&gt; pnep=create_proj_NEP(nep,2,Float64);
julia&gt; set_projectmatrices!(pnep,W,V);
julia&gt; compute_Mder(pnep,3.0)
2×2 Array{Float64,2}:
 6.08082   -5.47481
 0.986559  -6.98165</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/NEPTypes.jl#L593-L634">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.set_projectmatrices!" href="#NonlinearEigenproblems.NEPTypes.set_projectmatrices!"><code>NonlinearEigenproblems.NEPTypes.set_projectmatrices!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_projectmatrices!(pnep::Proj_NEP,W,V)</code></pre><p>Set the projection matrices for the NEP to <code>W</code> and <code>V</code>, i.e., corresponding the NEP: <span>$N(λ)=W^HM(λ)V$</span>. See also <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP</code></a>.</p><p><strong>Example</strong></p><p>This illustrates if <code>W</code> and <code>V</code> are vectors of ones, the projected problem becomes the sum of the rows and columns of the original NEP.</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; pnep=create_proj_NEP(nep);
julia&gt; V=ones(200,1);  W=ones(200,1);
julia&gt; set_projectmatrices!(pnep,W,V);
julia&gt; compute_Mder(pnep,0)
1×1 Array{Complex{Float64},2}:
 48.948104019482756 + 0.0im
julia&gt; sum(compute_Mder(nep,0),dims=[1,2])
1×1 Array{Float64,2}:
 48.948104019482955</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/NEPTypes.jl#L702-L723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.expand_projectmatrices!" href="#NonlinearEigenproblems.NEPTypes.expand_projectmatrices!"><code>NonlinearEigenproblems.NEPTypes.expand_projectmatrices!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expand_projectmatrices!(nep::Proj_SPMF_NEP, Wnew, Vnew)</code></pre><p>The projected NEP is updated by adding the last column of <code>Wnew</code> and <code>Vnew</code> to the basis. Note that <code>Wnew</code> and <code>Vnew</code> contain also the &quot;old&quot; basis vectors. See also <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP</code></a></p><p><strong>Example:</strong></p><p>In the following example you see that the expanded projected problem has one row and column more, and the leading subblock is the same as the smaller projected NEP.</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;pep0&quot;); n=size(nep,1);
julia&gt; V=Matrix(1.0*I,n,2); W=Matrix(1.0*I,n,2);
julia&gt; pnep=create_proj_NEP(nep);
julia&gt; set_projectmatrices!(pnep,W,V);
julia&gt; compute_Mder(pnep,0)
2×2 Array{Complex{Float64},2}:
 0.679107+0.0im   -0.50376+0.0im
 0.828413+0.0im  0.0646768+0.0im
julia&gt; Vnew=[V ones(n)]
julia&gt; Wnew=[W ones(n)]
julia&gt; expand_projectmatrices!(pnep,Wnew,Vnew);
julia&gt; compute_Mder(pnep,0)
3×3 Array{Complex{Float64},2}:
 0.679107+0.0im   -0.50376+0.0im  -12.1418+0.0im
 0.828413+0.0im  0.0646768+0.0im   16.3126+0.0im
 -17.1619+0.0im   -10.1628+0.0im   48.9481+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/NEPTypes.jl#L741-L772">source</a></section></article><h3 id="Projection-types"><a class="docs-heading-anchor" href="#Projection-types">Projection types</a><a id="Projection-types-1"></a><a class="docs-heading-anchor-permalink" href="#Projection-types" title="Permalink"></a></h3><p>NEPs for which this projection can be computed inherit from <code>ProjectableNEP</code>.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.ProjectableNEP" href="#NonlinearEigenproblems.NEPTypes.ProjectableNEP"><code>NonlinearEigenproblems.NEPTypes.ProjectableNEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract ProjectableNEP &lt;: NEP</code></pre><p>A ProjectableNEP is a NEP which can be projected, i.e., one can construct the problem <span>$W&#39;*M(λ)Vw=0$</span> with the <a href="#NonlinearEigenproblems.NEPTypes.Proj_NEP"><code>Proj_NEP</code></a>. A NEP which is of this must have the function <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP(orgnep::ProjectableNEP)</code></a> implemented. This function must return a <code>Proj_NEP</code>.</p><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.set_projectmatrices!"><code>set_projectmatrices!</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; typeof(nep)
DEP{Float64,Array{Float64,2}}
julia&gt; isa(nep,ProjectableNEP)
true
julia&gt; projnep=create_proj_NEP(nep);
julia&gt; e1 = Matrix(1.0*I,size(nep,1),1);
julia&gt; set_projectmatrices!(projnep,e1,e1);
julia&gt; compute_Mder(nep,3.0)[1,1]
-2.942777908030041
julia&gt; compute_Mder(projnep,3.0)
1×1 Array{Complex{Float64},2}:
 -2.942777908030041 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/NEPTypes.jl#L55-L80">source</a></section></article><p>The result of the projection is represented in a <code>Proj_NEP</code>.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.Proj_NEP" href="#NonlinearEigenproblems.NEPTypes.Proj_NEP"><code>NonlinearEigenproblems.NEPTypes.Proj_NEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Proj_NEP &lt;: NEP</code></pre><p><code>Proj_NEP</code> represents a projected <code>NEP</code>. The projection is defined as the NEP</p><p class="math-container">\[N(λ)=W^HM(λ)V\]</p><p>where <span>$M(λ)$</span> is a base NEP and <code>W</code> and <code>V</code> rectangular matrices representing a basis of the projection spaces. Instances are created with <code>create_proj_NEP</code>. See <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP</code></a> for examples.</p><p>Any <code>Proj_NEP</code> needs to implement two functions to manipulate the projection:</p><ul><li><a href="#NonlinearEigenproblems.NEPTypes.set_projectmatrices!"><code>set_projectmatrices!</code></a>: Set matrices <code>W</code> and <code>V</code></li><li><a href="#NonlinearEigenproblems.NEPTypes.expand_projectmatrices!"><code>expand_projectmatrices!</code></a>: Effectively expand the matrices <code>W</code> and <code>V</code> with one column.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/NEPTypes.jl#L572-L590">source</a></section></article><p>One explicit instance is the <code>Proj_SPMF_NEP</code>.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.Proj_SPMF_NEP" href="#NonlinearEigenproblems.NEPTypes.Proj_SPMF_NEP"><code>NonlinearEigenproblems.NEPTypes.Proj_SPMF_NEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Proj_SPMF_NEP &lt;: Proj_NEP</code></pre><p>This type represents the (generic) way to project NEPs which are <code>AbstractSPMF</code>. See examples in <a href="#NonlinearEigenproblems.NEPTypes.create_proj_NEP"><code>create_proj_NEP</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/NEPTypes.jl#L646-L651">source</a></section></article><h2 id="Rayleigh-functional-computation"><a class="docs-heading-anchor" href="#Rayleigh-functional-computation">Rayleigh functional computation</a><a id="Rayleigh-functional-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Rayleigh-functional-computation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.compute_rf" href="#NonlinearEigenproblems.NEPSolver.compute_rf"><code>NonlinearEigenproblems.NEPSolver.compute_rf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_rf(eltype::Type,nep::NEP,x,inner_solver::InnerSolver;
           y=x, target=zero(T), λ=target,TOL=eps(real(T))*1e3,max_iter=10)</code></pre><p>Computes the Rayleigh functional of the <code>nep</code>, i.e., computes a vector <span>$Λ$</span> of values <span>$λ$</span> such that <span>$y^TM(λ)x=0$</span>, using the procedure specified in <code>inner_solver</code>. The default behaviour consists of a scalar valued Newton-iteration, and the returned vector has only one element.</p><p>The given eltype&lt;:Number is the type of the returned vector.</p><p><strong>Example</strong></p><p>This uses <code>iar</code> to solve the (scalar) nonlinear problem.</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; x=ones(size(nep,1));
julia&gt; s=compute_rf(ComplexF64,nep,x,IARInnerSolver())[1] # Take just first element
-1.186623627962043 - 1.5085094961223182im
julia&gt; x&#39;*compute_Mlincomb(nep,s,x)
-8.881784197001252e-16 + 1.0880185641326534e-14im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/d97dcbbde56022679dae73822e5ce036beca890c/src/compute_rf_wrapper.jl#L57-L81">source</a></section></article><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_INNERSOLVE" alt="To the top"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linsolvers/">« Linear solvers</a><a class="docs-footer-nextpage" href="../errmeasure/">Measuring the error »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 2 October 2022 12:57">Sunday 2 October 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
