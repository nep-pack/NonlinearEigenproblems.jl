<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear solvers · NEP-PACK</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NEP-PACK</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../methods/">NEP-Solvers</a></li><li><a class="tocitem" href="../types/">Types &amp; Data structures</a></li><li><a class="tocitem" href="../compute_functions/">Compute functions</a></li><li class="is-active"><a class="tocitem" href>Linear solvers</a><ul class="internal"><li><a class="tocitem" href="#Linear-system-of-equations"><span>Linear system of equations</span></a></li><li><a class="tocitem" href="#Standard-eigenvalue-problems"><span>Standard eigenvalue problems</span></a></li></ul></li><li><a class="tocitem" href="../innersolvers/">Projection</a></li><li><a class="tocitem" href="../errmeasure/">Measuring the error</a></li><li><a class="tocitem" href="../logger/">Logger</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../deflation/">Deflation</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="tocitem" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="tocitem" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="tocitem" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="tocitem" href="../tutorial_call_python/">Tutorial 5 (Python 1)</a></li><li><a class="tocitem" href="../tutorial_python_call/">Tutorial 6 (Python 2)</a></li><li><a class="tocitem" href="../tutorial_matlab1/">Tutorial 7 (MATLAB)</a></li><li><a class="tocitem" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="tocitem" href="../tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="tocitem" href="../tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li><a class="tocitem" href="../tutorial_linsolve/">Tutorial 11 (Linear solvers)</a></li><li><a class="tocitem" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Linear solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/linsolvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-solvers"><a class="docs-heading-anchor" href="#Linear-solvers">Linear solvers</a><a id="Linear-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-solvers" title="Permalink"></a></h1><p>Most NEP-solvers require</p><ul><li><a href="#Linear-system-of-equations-1">the solution of linear system of equations</a>, or</li><li><a href="#Standard-eigenvalue-problems-1">the solution of a standard eigenvalue problem</a>.</li></ul><p>The user can specify which linear solver or eigenvalue solver he/she wants to use. It is also possible to use external or user-defined solvers.</p><h2 id="Linear-system-of-equations"><a class="docs-heading-anchor" href="#Linear-system-of-equations">Linear system of equations</a><a id="Linear-system-of-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-system-of-equations" title="Permalink"></a></h2><p>As a user, you can provide a creator object to many NEP-solvers via the keyword argument <code>linsolvercreator</code>. The creator object corresponds to one (or several) linear system solvers. By default, <a href="#NonlinearEigenproblems.LinSolvers.DefaultLinSolverCreator"><code>DefaultLinSolverCreator</code></a> is used which tries to determine an appropriate linear solver based on the NEP-type. In the next section, we list the default linear solvers.</p><p>If you wish to define your own linear solver, you need to define your own type inheriting from <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a> as well as a <code>LinSolverCreator</code>. See the documenation for <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a> and <a href="../tutorial_linsolve/">the tutorial on linear solvers</a>.</p><h3 id="LinSolver-objects-and-creators"><a class="docs-heading-anchor" href="#LinSolver-objects-and-creators"><code>LinSolver</code>-objects and creators</a><a id="LinSolver-objects-and-creators-1"></a><a class="docs-heading-anchor-permalink" href="#LinSolver-objects-and-creators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.FactorizeLinSolver" href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolver"><code>NonlinearEigenproblems.LinSolvers.FactorizeLinSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FactorizeLinSolver &lt;: LinSolver</code></pre><p>This represents the linear solver associated with julia <code>factorize()</code>. See <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a> and <a href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolverCreator"><code>FactorizeLinSolverCreator</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolvers.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.FactorizeLinSolverCreator" href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolverCreator"><code>NonlinearEigenproblems.LinSolvers.FactorizeLinSolverCreator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FactorizeLinSolverCreator(;umfpack_refinements,max_factorizations,nep,precomp_values)</code></pre><p><code>FactorizeLinSolverCreator</code>-objects can instantiate <code>FactorizeLinSolver</code> objects via the <code>create_linsolver</code> function.</p><p>The <code>FactorizeLinSolver</code> is based on <code>factorize</code>-calls. The time point of the call to <code>factorize</code> can be controlled by parameters to <code>FactorizeLinSolverCreator</code>:</p><ul><li><p>By default, the <code>factorize</code> call is carried out by the instantiation of the <code>FactorizeLinSolver</code>, i.e., when the NEP-solver calls <code>create_linsolver</code>.</p></li><li><p>You can also precompute the factorization, at the time point when you instantiate <code>FactorizeLinSolverCreator</code>. If you set <code>precomp_values::Vector{Number}</code> to a non-empty vector, and set <code>nep</code> kwarg, the factorization (of all λ-values in the <code>precomp_values</code>) will be computed  when the <code>FactorizeLinSolverCreator</code> is instantiated. If the NEP-solver calls a <code>create_linsolver</code> with a λ-value from that vector, the factorization will be used (otherwise it will be computed).</p></li></ul><p>Further recycling is possible. If the variable <code>max_factorizations</code> is set to a positive value, the object will store that many factorizations for possible reuse. Every <code>lin_solve</code>-call then computes a factorization, unless a <code>lin_solve</code>-call for that <code>λ</code> has been computed earlier. This procedure can at most store <code>max_factorization</code> (which can be set <code>Inf</code>).</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolver"><code>FactorizeLinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.create_linsolver"><code>create_linsolver</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolverCreators.jl#L39-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.BackslashLinSolver" href="#NonlinearEigenproblems.LinSolvers.BackslashLinSolver"><code>NonlinearEigenproblems.LinSolvers.BackslashLinSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BackslashLinSolver &lt;: LinSolver</code></pre><p>This represents a linear solver corresponding to the backslash operator (no pre-factorization).</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a> and <a href="#NonlinearEigenproblems.LinSolvers.BackslashLinSolverCreator"><code>BackslashLinSolverCreator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolvers.jl#L136-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.BackslashLinSolverCreator" href="#NonlinearEigenproblems.LinSolvers.BackslashLinSolverCreator"><code>NonlinearEigenproblems.LinSolvers.BackslashLinSolverCreator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BackslashLinSolverCreator &lt;: LinSolverCreator</code></pre><p>Creator to for the <code>BackslashLinSolver</code>, i.e., usage of backslash to make linear solves. Specify objects of this type if you want the solver to use backslash.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.BackslashLinSolver"><code>BackslashLinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.create_linsolver"><code>create_linsolver</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolverCreators.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.GMRESLinSolver" href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolver"><code>NonlinearEigenproblems.LinSolvers.GMRESLinSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GMRESLinSolver &lt;: LinSolver</code></pre><p>This represents a solver done with the julia GMRES implementation.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolverCreator"><code>GMRESLinSolverCreator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolvers.jl#L160-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.GMRESLinSolverCreator" href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolverCreator"><code>NonlinearEigenproblems.LinSolvers.GMRESLinSolverCreator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GMRESLinSolverCreator(;kwargs...)</code></pre><p>This is the creator for the GMRES-method. Instantiate this object if you want to use GMRES as your linear system solver. The <code>kwargs</code> are stored and used as keyword arguments in the call to gmres. See list of keyword in the <a href="https://juliamath.github.io/IterativeSolvers.jl/dev/linear_systems/gmres/">IterativeSolvers.jl manual</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolverCreators.jl#L128-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.DefaultLinSolverCreator" href="#NonlinearEigenproblems.LinSolvers.DefaultLinSolverCreator"><code>NonlinearEigenproblems.LinSolvers.DefaultLinSolverCreator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DefaultLinSolverCreator</code></pre><p>This is the default linear solver if no other is specified (for most methods). It is a <code>FactorizeLinSolverCreator</code>.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.create_linsolver"><code>create_linsolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.lin_solve"><code>lin_solve</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolverCreator"><code>FactorizeLinSolverCreator</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolver"><code>FactorizeLinSolver</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolverCreators.jl#L185-L195">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DeflatedNEPLinSolver</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.DeflatedNEPLinSolverCreator" href="#NonlinearEigenproblems.LinSolvers.DeflatedNEPLinSolverCreator"><code>NonlinearEigenproblems.LinSolvers.DeflatedNEPLinSolverCreator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeflatedNEPLinSolverCreator(orglinsolvercreator)</code></pre><p>This is the creator for case of a deflated NEP. The argument <code>orglinsolvercreator</code> is the <code>LinSolverCreator</code> for the original NEP. The extended linear system</p><p class="math-container">\[[M, U; X^T, 0][v1; v2] = [b1; b2]\]</p><p>is solved with a Schur complement strategy, recycling the linear solver of the original NEP. Hence, pre-computed entities such as, e.g., factorizations and preconditioners can be reused.</p><p>NB1: The implementation assumes minimality index = 1. NB2: The Schur complement is explicitly formed. Hence it is only efficient for a few deflated eigenvalues.</p><p>See also: <a href="@ref"><code>DeflatedNEPLinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.create_linsolver"><code>create_linsolver</code></a>, <a href="../deflation/#NonlinearEigenproblems.NEPTypes.deflate_eigpair"><code>deflate_eigpair</code></a></p><p><strong>References</strong></p><ul><li>C. Effenberger, Robust successive computation of eigenpairs for nonlinear eigenvalue problems. SIAM J. Matrix Anal. Appl. 34, 3 (2013), pp. 1231-1256.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolverCreators.jl#L148-L173">source</a></section></article><h3 id="Advanced-usage"><a class="docs-heading-anchor" href="#Advanced-usage">Advanced usage</a><a id="Advanced-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-usage" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.LinSolver" href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>NonlinearEigenproblems.LinSolvers.LinSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type LinSolver</code></pre><p>Structs inheriting from this type are able to solve linear systems associated with a NEP, for a specific <code>λ</code>-value. The most common are direct solvers such as <a href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolver"><code>FactorizeLinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.BackslashLinSolver"><code>BackslashLinSolver</code></a> and iterative solvers such as <a href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolver"><code>GMRESLinSolver</code></a>.</p><p>The LinSolver objects are usually created by the NEP-algorithms through creator functions, which are passed as parameters.</p><p><strong>Example</strong></p><p>The most common usecase is that you want to pass a <code>linsolvercreator</code>-function as a parameter to the NEP-algorithm. This example shows how you can use solvers based on backslash or <code>factorize()</code>. In the example, <code>BackslashLinSolver</code> does not exploit that the system matrix remains the same throughout the algorithm and is therefore slower.</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; using BenchmarkTools
julia&gt; v0=ones(size(nep,1));
julia&gt; @btime λ,v=quasinewton(nep,λ=-1,v=v0, linsolvercreator=DefaultLinSolverCreator());
  181.017 ms (3779 allocations: 58.61 MiB)
julia&gt; @btime λ,v=quasinewton(nep,λ=-1,v=v0, linsolvercreator=BackslashLinSolverCreator());
  2.040 s (4510 allocations: 553.24 MiB)</code></pre><p><strong>Example</strong></p><p>The <code>LinSolver</code>s are constructed for extendability. This example creates our own <code>LinSolver</code> which uses an explicit formula for the inverse if the NEP has dimension 2x2.</p><p>Create the types and a creator.</p><pre><code class="language-julia hljs">julia&gt; using LinearAlgebra
julia&gt; struct MyLinSolver &lt;: LinSolver
   M::Matrix{ComplexF64}
end
julia&gt; function my_linsolvercreator(nep,λ)
   M=compute_Mder(nep,λ);
   return MyLinSolver(M);
end</code></pre><p>Explicit import <code>lin_solve</code> to show how to solve a linear system.</p><pre><code class="language-julia-repl hljs">julia&gt; import NonlinearEigenproblems.LinSolvers.lin_solve;
julia&gt; function lin_solve(solver::MyLinSolver,b::AbstractVecOrMat;tol=0)
   M=solver.M;
   invM=(1/(det(M)))*[M[2,2] -M[1,2];-M[2,1] M[1,1]]
   return invM*b
end
julia&gt; nep=SPMF_NEP([[1.0 3.0; 4.0 5.0], [2.0 1.0; -1 2.0]], [S-&gt;S^2,S-&gt;exp(S)])
julia&gt; λ,v=quasinewton(nep,λ=-1,v=[1;1],linsolvercreator=my_linsolvercreator);</code></pre><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.lin_solve"><code>lin_solve</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolver"><code>FactorizeLinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.FactorizeLinSolver"><code>FactorizeLinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.DefaultLinSolverCreator"><code>DefaultLinSolverCreator</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.BackslashLinSolver"><code>BackslashLinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.BackslashLinSolverCreator"><code>BackslashLinSolverCreator</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolver"><code>GMRESLinSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.GMRESLinSolverCreator"><code>GMRESLinSolverCreator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolvers.jl#L32-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.lin_solve" href="#NonlinearEigenproblems.LinSolvers.lin_solve"><code>NonlinearEigenproblems.LinSolvers.lin_solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lin_solve(solver::LinSolver, b::AbstractVecOrMat; tol=0)</code></pre><p>This function solves the linear system represented in <code>solver::LinSolver</code> with a right-hand side <code>b</code>. The <code>tol</code> kwarg is controlling how accurate the linear system needs to be solved. A NEP-algorithm will call this solver every time a linear system associated with <code>M(λ)</code> needs to be solved.</p><p>This function must be overloaded if a user wants to define their own way of solving linear systems. See <a href="#NonlinearEigenproblems.LinSolvers.LinSolver"><code>LinSolver</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolvers.jl#L120-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.create_linsolver" href="#NonlinearEigenproblems.LinSolvers.create_linsolver"><code>NonlinearEigenproblems.LinSolvers.create_linsolver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_linsolver(creator::LinSovlerCreator,nep,λ)</code></pre><p>Creates a <code>LinSolver</code> instance for the <code>nep</code> corresponding which is evaluated in <code>λ</code>. The type of the output is decided by dispatch and the type of the <code>LinSolverCreator</code>.</p><p>See also: <code>LinSolver</code>, <code>FactorizeLinSolverCreator</code>, <code>BackslashLinSolverCreator</code>, <code>DefaultLinSolverCreator</code>, <code>GMRESLinSolverCreator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolverCreators.jl#L24-L34">source</a></section></article><h2 id="Standard-eigenvalue-problems"><a class="docs-heading-anchor" href="#Standard-eigenvalue-problems">Standard eigenvalue problems</a><a id="Standard-eigenvalue-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-eigenvalue-problems" title="Permalink"></a></h2><p>Some NEP-algorithms need to solve an associated linear eigenvalue problem, associated with <code>M(λ)</code>. We provide the possibility to use Julia-native eigenvalue solvers, and an interface which allows you to define your own solver. By default, <a href="#NonlinearEigenproblems.LinSolvers.DefaultEigSolver"><code>DefaultEigSolver</code></a> is specified, which tries to determine an appropriate eigenvalue solver based on the NEP-type.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The NEP-solvers <a href="../methods/#NonlinearEigenproblems.NEPSolver.mslp"><code>mslp</code></a> and <a href="../methods/#NonlinearEigenproblems.NEPSolver.sgiter"><code>sgiter</code></a> require eigenvalue solvers and take the keyword argument <code>eigsolver</code>.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.DefaultEigSolver" href="#NonlinearEigenproblems.LinSolvers.DefaultEigSolver"><code>NonlinearEigenproblems.LinSolvers.DefaultEigSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DefaultEigSolver &lt;: EigSolver</code></pre><p>A linear eigenvalueproblem solver that calls checks for sparsity and accordingly assigns an appropriate solver.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.EigenEigSolver"><code>EigenEigSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.ArnoldiEigSolver"><code>ArnoldiEigSolver</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolvers.jl#L354-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.EigenEigSolver" href="#NonlinearEigenproblems.LinSolvers.EigenEigSolver"><code>NonlinearEigenproblems.LinSolvers.EigenEigSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EigenEigSolver &lt;: EigSolver</code></pre><p>A linear eigenvalueproblem solver that calls Julia&#39;s in-built eigen()</p><p>Constructed as <code>EigenEigSolver(A, [B,])</code>, and solves the problem</p><p class="math-container">\[Ax = λBx\]</p><p>The paramter <code>B</code> is optional an default is indentity, for which a standard linear eigenproblem is solved.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a> and <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolvers.jl#L250-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.ArnoldiEigSolver" href="#NonlinearEigenproblems.LinSolvers.ArnoldiEigSolver"><code>NonlinearEigenproblems.LinSolvers.ArnoldiEigSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ArnoldiEigSolver &lt;: EigSolver</code></pre><p>A linear eigenproblem solver for large and sparse problems that calls the Arnoldi method implemented in the Julia package ArnoldiMethod.jl.</p><p>Constructed as <code>ArnoldiEigSolver(A, [B,])</code>, and solves the problem</p><p class="math-container">\[Ax = λBx\]</p><p>The paramter <code>B</code> is optional an default is indentity, for which a standard linear eigenproblem is solved.</p><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a> and <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolvers.jl#L294-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.EigSolver" href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>NonlinearEigenproblems.LinSolvers.EigSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type EigSolver</code></pre><p>Structs inheriting from this type are able to solve linear eigenvalue problems arising in certain methods, such as, e.g., <code>mslp</code>, <code>sgiter</code>, and <code>polyeig</code>.</p><p>The <code>EigSolver</code> objects are passed as types to the NEP-algorithms, which uses it to dispatch the correct version of the function <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a>.</p><p><strong>Example</strong></p><p>The most common usecase is that you do not want to specify anything in particular, since the <a href="#NonlinearEigenproblems.LinSolvers.DefaultEigSolver"><code>DefaultEigSolver</code></a> will use a dense or a sparse method depending on you problem. However, this example shows how you can force <code>mslp</code> to use the sparse solver.</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; λ,v = mslp(nep, eigsolvertype=ArnoldiEigSolver);
julia&gt; norm(compute_Mlincomb(nep,λ,v))
9.323110647141726e-16</code></pre><p><strong>Example</strong></p><p>The <code>EigSolver</code>s are constructed for extendability. As an illustartion this example creates a naive <code>EigSolver</code> which casts the problem to a standard linear eigenproblem and calls the built-in function to solve it.</p><p>Create the types and a creator.</p><pre><code class="language-julia-repl hljs">julia&gt; struct MyEigSolver &lt;: EigSolver
   A
   E
   function MyEigSolver(A,E)
      return new(A,E)
   end
end

julia&gt; import NonlinearEigenproblems.LinSolvers.eig_solve;
julia&gt; function eig_solve(solver::MyEigSolver;nev = 1, target = 0)
   M = solver.E \ solver.A
   eig = eigen(M)
   i = argmin(abs.(eig.values))
   return eig.values[i], eig.vectors[:,i]
end
julia&gt; nep=nep_gallery(&quot;dep0&quot;, 50);
julia&gt; λ,v = mslp(nep, eigsolvertype=MyEigSolver, tol=1e-5);
julia&gt; norm(compute_Mlincomb(nep,λ,v))
3.0777795031319117e-10</code></pre><p>See also: <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.DefaultEigSolver"><code>DefaultEigSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.EigenEigSolver"><code>EigenEigSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.ArnoldiEigSolver"><code>ArnoldiEigSolver</code></a>, <a href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolvers.jl#L190-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.LinSolvers.eig_solve" href="#NonlinearEigenproblems.LinSolvers.eig_solve"><code>NonlinearEigenproblems.LinSolvers.eig_solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eig_solve(solver::EigSolver; [nev,] [target,])</code></pre><p>This function solves the linear eigenvalue problem represented in <code>solver::EigSolver</code>. The <code>nev</code> kwarg is controlling the number of eigenvalues aimed for, and <code>target</code> specifies around which point the eigenvalues are computed. The former has a defalut value equalt to the seize of the problem, and the latter has a defalut value 0.</p><p>Return values are of the form (Vector, Matrix) where the former contains the eigenvalues and the latter the eigenvectors.</p><p>This function must be overloaded if a user wants to define their own way of solving linear eigenvalue problems. See <a href="#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9580d22413387168a78e4c57e2d5c0f1f4adba44/src/LinSolvers.jl#L386-L399">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../compute_functions/">« Compute functions</a><a class="docs-footer-nextpage" href="../innersolvers/">Projection »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 28 June 2023 11:41">Wednesday 28 June 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
