<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 2 (Contour) · NEP-PACK</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NEP-PACK</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../methods/">NEP-Solvers</a></li><li><a class="tocitem" href="../types/">Types &amp; Data structures</a></li><li><a class="tocitem" href="../compute_functions/">Compute functions</a></li><li><a class="tocitem" href="../linsolvers/">Linear solvers</a></li><li><a class="tocitem" href="../innersolvers/">Projection</a></li><li><a class="tocitem" href="../errmeasure/">Measuring the error</a></li><li><a class="tocitem" href="../logger/">Logger</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../deflation/">Deflation</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li class="is-active"><a class="tocitem" href>Tutorial 2 (Contour)</a><ul class="internal"><li><a class="tocitem" href="#Basic-usage"><span>Basic usage</span></a></li><li><a class="tocitem" href="#Your-own-quadrature-method"><span>Your own quadrature method</span></a></li><li><a class="tocitem" href="#Parallellized-quadrature-method"><span>Parallellized quadrature method</span></a></li></ul></li><li><a class="tocitem" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="tocitem" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="tocitem" href="../tutorial_call_python/">Tutorial 5 (Python 1)</a></li><li><a class="tocitem" href="../tutorial_python_call/">Tutorial 6 (Python 2)</a></li><li><a class="tocitem" href="../tutorial_matlab1/">Tutorial 7 (MATLAB)</a></li><li><a class="tocitem" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="tocitem" href="../tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="tocitem" href="../tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li><a class="tocitem" href="../tutorial_linsolve/">Tutorial 11 (Linear solvers)</a></li><li><a class="tocitem" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Tutorial 2 (Contour)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial 2 (Contour)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/tutorial_contour.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Contour-integral-tutorial"><a class="docs-heading-anchor" href="#Contour-integral-tutorial">Contour integral tutorial</a><a id="Contour-integral-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Contour-integral-tutorial" title="Permalink"></a></h1><p>NEP-PACK contains several implementations of methods in the family of approaches based on contour integration. Although they have been worked out and presented independently (in different research articles by different research groups), we have implemented them in a unified and extendible way.</p><p>Contour integral methods have one property which makes them attractive from the perspective of parallelization, which we will illustrate in the final example below.</p><h2 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h2><p>The most popular methods contour integral methods are Beyn&#39;s contour integral method (implemented in <a href="../methods/#NonlinearEigenproblems.NEPSolver.contour_beyn"><code>contour_beyn</code></a>) and the block SS method of Asakura and Sakurai (implemented in <a href="../methods/#NonlinearEigenproblems.NEPSolver.contour_block_SS"><code>contour_block_SS</code></a>). We illustrate both of them. First set up a large and sparse problem:</p><pre><code class="language-julia-repl hljs">julia&gt; using SparseArrays, LinearAlgebra;
julia&gt; n=1000;
julia&gt; A0=spdiagm(0 =&gt; ones(n))
julia&gt; A1=spdiagm(-2 =&gt; ones(n-2), 0 =&gt; 30*(n:-1:1)/n,  1 =&gt; 3*ones(n-1))/3
julia&gt; A2=spdiagm(-1 =&gt; ones(n-1), 0 =&gt; (1:n)/n, 1 =&gt; sin.(range(0,5,length=n-1)))/10
julia&gt; nep=SPMF_NEP([A0,A1,A2],[s-&gt;one(s), s-&gt;s, s-&gt;exp(-s)])</code></pre><p>and call the two integral solution methods:</p><pre><code class="language-julia-repl hljs">julia&gt; (λ,v)= contour_beyn(nep,radius=0.5,k=10);</code></pre><p>We can verify that we found some good solutions</p><pre><code class="language-julia-repl hljs">julia&gt; λ
2-element Array{Complex{Float64},1}:
 -0.4938003805961036 + 0.03369433628038132im
 -0.4984653501095431 - 0.013414744968396205im
julia&gt; norm(compute_Mlincomb(nep,λ[1],normalize(v[:,1])))
2.8693125572899838e-6
julia&gt; norm(compute_Mlincomb(nep,λ[2],normalize(v[:,2])))
3.0028543096707394e-6</code></pre><p>For comparison we also use <a href="../methods/#NonlinearEigenproblems.NEPSolver.contour_block_SS"><code>contour_block_SS</code></a></p><pre><code class="language-julia-repl hljs">julia&gt; (λ,v)= contour_block_SS(nep,radius=0.5,k=10);
julia&gt; julia&gt; λ
7-element Array{Complex{Float64},1}:
 -0.49789562317811836 + 0.029382625854591973im
  -0.5020899933123398 - 0.027308288264250524im
  -0.5006296180796399 + 0.011976675667372098im
  -0.5000287784310599 - 0.010301420892154335im
  -0.5044451294089868 - 0.0074606034247795975im
  -0.5001550771105308 - 0.00026147429323077303im
 -0.49957316937095864 + 0.003511006328045692im</code></pre><p>and the corresponding residual norms</p><pre><code class="language-julia-repl hljs">julia&gt; for j=1:7; @show norm(compute_Mlincomb(nep,λ[j],normalize(v[:,j]))); end
norm(compute_Mlincomb(nep, λ[j], normalize(v[:, j]))) = 2.8693125572899838e-6
norm(compute_Mlincomb(nep, λ[j], normalize(v[:, j]))) = 3.0028543096707394e-6
norm(compute_Mlincomb(nep, λ[j], normalize(v[:, j]))) = 1.1514402700870265e-7
norm(compute_Mlincomb(nep, λ[j], normalize(v[:, j]))) = 4.123810796391466e-8
norm(compute_Mlincomb(nep, λ[j], normalize(v[:, j]))) = 6.261761794674978e-8
norm(compute_Mlincomb(nep, λ[j], normalize(v[:, j]))) = 1.7269388863226059e-9
norm(compute_Mlincomb(nep, λ[j], normalize(v[:, j]))) = 2.994085882385125e-9</code></pre><p>The functions <a href="../methods/#NonlinearEigenproblems.NEPSolver.contour_beyn"><code>contour_beyn</code></a> and <a href="../methods/#NonlinearEigenproblems.NEPSolver.contour_block_SS"><code>contour_block_SS</code></a> have compatible keyword argumengs. The kwarg <code>radius=0.5</code>, means that we numerically integrate  a circle of radius <code>0.5</code>. The center of the circle is given by the <code>σ</code>, argument and by default <code>σ=0</code>. We should expect the method to find eigenvalues (hopefully all eigenvalues) within that disk. Our implementation also supports ellipses, by specifying <code>radius</code> as a length two vector with the two radii of the ellipse. The value <code>k=10</code> specifies how many columns the rectangular probe matrix has. In general, we do not obtain more <code>k</code> eigenvalues.</p><p>It seems that in this case <code>contour_block_SS</code> is better since it finds eigenvalues  which <code>contour_beyn</code> misses. However, a closer look reveals that the additional eigenvalues are outside the requested disc, and the call to  <code>contour_block_SS</code> also requires more computation time, making the comparison unfair.</p><h2 id="Your-own-quadrature-method"><a class="docs-heading-anchor" href="#Your-own-quadrature-method">Your own quadrature method</a><a id="Your-own-quadrature-method-1"></a><a class="docs-heading-anchor-permalink" href="#Your-own-quadrature-method" title="Permalink"></a></h2><p>The contour integral methods are based on numerical quadrature. There are many different ways to carry out quadrature, and NEP-PACK provides a way to use user-defined quadrature methods. The default behaviour is to use the trapezoidal rule. When we parameterize a circle (or ellipse) with a phase, the integrand is periodic and the trapezoidal rule works particularly well. It is however not the only option for quadrature and we can for instance implement a gauss quadrature, in this case by using the functionality in the package <code>QuadGK</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using Pkg
julia&gt; Pkg.add(&quot;QuadGK&quot;);
julia&gt; using QuadGK</code></pre><p>The function <code>(x,w)=gauss(N)</code> provides weights and quadrature points for a function to be integrated over the interval <code>[-1,1]</code> with <code>N</code> quadrature points.</p><p>Before implementing the method, let us first have a look at the documtation of <code>MatrixIntegrator</code>:</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.MatrixIntegrator" href="#NonlinearEigenproblems.NEPSolver.MatrixIntegrator"><code>NonlinearEigenproblems.NEPSolver.MatrixIntegrator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type MatrixIntegrator</code></pre><p>This type is used for integration of (matrix valued) functions with a particular structure. It is used in <code>contour_beyn</code> and <code>contour_block_SS</code>.</p><p>In order to specify your own way to do numerical quadrature you should inherit from this type</p><pre><code class="nohighlight hljs">julia&gt; abstract type MyIntegrator &lt;: MatrixIntegrator; end</code></pre><p>and implement the method <code>integrate_interval</code>:</p><pre><code class="nohighlight hljs">julia&gt; import NonlinearEigenproblems.NEPSolver.integrate_interval
julia&gt; function integrate_interval(ST::Type{MyType},::Type{T},f,gv,a,b,N,logger) where {T&lt;:Number}</code></pre><p>The function <code>integrate_interval</code> should integrate functions on the interval <code>[a,b]</code> with <code>N</code> quadrature points. Further parameters:</p><ul><li>The type <code>T</code> (typically <code>ComplexF64</code>) specifies what the target number type is.</li><li>The <code>logger::Logger</code> specifies if / how things should written to the log.</li><li><code>f::Function</code>, takes a scalar input (in the interval <code>[a,b]</code>) and returns a matrix or a vector.</li><li><code>gv::Vector{Function}</code> which takes scalar input (in the interval <code>[a,b]</code>)  and returns scalars.</li></ul><p>The function <code>integrate_interval</code> should return a tensor <code>I</code> where the last dimension is <code>m=length(gv)</code> and should contain the integrals. More precisely,  <code>I[:,:,1]</code>, ... <code>I[:,:,m]</code> should contain approximations of the product of <code>f(x)gv[1](x)</code>,...<code>f(x)gv[m](x)</code> over <code>[a,b]</code>, e.g., <code>I[:,:,j]</code> should contain an approximation of</p><p class="math-container">\[\int_a^b f(x)g_j(x)\,dx\]</p><p>Usually, <code>f(x)</code> is considerably more expensive to evaluate than <code>g_1(x),..,g_m(x)</code>.</p><p>See also: <code>contour_beyn</code>, <code>contour_block_SS</code>, <code>MatrixTrapezoidal</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/ace02cdd2ccfdab1285e913bde578f04bb854602/src/method_contour_common.jl#L7-L45">source</a></section></article><p>Let us now combine the Gauss method in an implementation of a numerical quadrature to be used in the quadrature methods.</p><pre><code class="language-julia-repl hljs">julia&gt; abstract type GaussIntegrator &lt;: MatrixIntegrator; end
julia&gt; import  NonlinearEigenproblems.NEPSolver.integrate_interval
julia&gt; function integrate_interval(ST::Type{GaussIntegrator},::Type{T},f,gv,a,b,N,logger) where {T&lt;:Number}
    x,w=gauss(N);        # Compute the Gauss weights
    w=w*(b-a)/2;         # Rescale w to interval [a,b]
    t=a .+ ((x .+ 1)/2)*(b-a); # Rescale t
    m=size(gv,1);
    # create the tensor and compute all quadratures
    S = zeros(T,size(f(t[1]))...,m)
    for i = 1:N
        ## Extra code goes here
        temp = f(t[i]) # Only computed once for all g-functions
        for j=1:m
            S[:,:,j] += temp*(gv[j](t[i])*w[i]);
        end
    end
    return S
end</code></pre><p>To specify this solver, you need to add the type you just created as a parameter in the call. This is an argument (not a keyword argument) after the argument <code>nep</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; (λ,v)= contour_block_SS(nep,GaussIntegrator,radius=0.5, k=10);
julia&gt; λ
6-element Array{Complex{Float64},1}:
  -0.5030050924478993 + 0.025867789190345332im
  -0.4998917126923037 - 0.014647029189145597im
 -0.49991828738335686 - 0.007092586236661307im
  -0.5000067107140442 - 0.0026614262456865663im
 -0.49903549969757116 + 0.0075397370638041255im
   -0.501620024772268 + 0.00393810326235837im</code></pre><p>Let&#39;s make it print some pretty decoration during the progress of the method. In the code where it currently says <code>## Extra code goes here</code> we will now insert</p><pre><code class="language-julia-repl hljs">if (mod(i,round(N/50))==1)
   print(&quot;.&quot;)
end</code></pre><p>and <code>println()</code> in the second code insertion. In this way, we will print a progress bar, which prints in total (approximately) 50 dots. You will see dots gradually appearing as a progress bar:</p><pre><code class="language-julia-repl hljs">julia&gt; (λ,v)= contour_beyn(nep,GaussIntegrator,radius=0.5,k=10);
..................................................</code></pre><h2 id="Parallellized-quadrature-method"><a class="docs-heading-anchor" href="#Parallellized-quadrature-method">Parallellized quadrature method</a><a id="Parallellized-quadrature-method-1"></a><a class="docs-heading-anchor-permalink" href="#Parallellized-quadrature-method" title="Permalink"></a></h2><p>The main computational effort of the contour integral methods lies in solving many linear systems. This is done in the call to <code>f</code> in the <code>integrate_interval</code>-function. Since they are completely independent operations in the for-loop, they can be easily parallelized.</p><p>Install the package <code>Distributed</code> and <code>BenchmarkTools</code> and include with</p><pre><code class="language-julia-repl hljs">julia&gt; using Distributed,BenchmarkTools</code></pre><p>Similar to the previous example we make a new type corresponding to our integrator and explicitly import that</p><pre><code class="language-julia-repl hljs">julia&gt; abstract type ParallelIntegrator &lt;: MatrixIntegrator; end
julia&gt; import  NonlinearEigenproblems.NEPSolver.integrate_interval</code></pre><p>and define a function which computes the main for-loop in parallel using the <code>@distributed</code> macro:</p><pre><code class="language-julia-repl hljs">julia&gt; function integrate_interval(ST::Type{ParallelIntegrator},::Type{T},f,gv,a,b,N,logger) where {T&lt;:Number}
    h = (b-a)/N
    t = range(a, stop = b-h, length = N)
    m = size(gv,1);
    S = @distributed (+) for i = 1:N
        temp = f(t[i])
        Z=zeros(T,size(temp,1),size(temp,2),m);
        for j=1:m
            Z[:,:,j]=temp*gv[j](t[i]);
        end
        Z
    end
    return S
end</code></pre><p>To use the parallelization you may need to start julia with command-line arguments to specify the number of parallel processes to be used, e.g., <code>-p 4</code>. The <code>@btime</code> macro provides a way to measure how much faster the parallel implementation is.</p><pre><code class="language-julia-repl hljs">julia&gt; @btime (λ,v)= contour_block_SS(nep,ParallelIntegrator,radius=0.5, k=10);
  863.420 ms (1385 allocations: 10.46 MiB)
julia&gt; @btime (λ,v)= contour_block_SS(nep,radius=0.5, k=10);
  2.990 s (321362 allocations: 5.84 GiB)</code></pre><p>This is a speed up of 3.4, with <code>p=4</code> processes.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../movebc_tutorial/">« Tutorial 1 (ABC)</a><a class="docs-footer-nextpage" href="../bemtutorial/">Tutorial 3 (BEM) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 28 June 2023 09:57">Wednesday 28 June 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
