<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types &amp; Data structures · NEP-PACK</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NEP-PACK</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../methods/">NEP-Solvers</a></li><li class="is-active"><a class="tocitem" href>Types &amp; Data structures</a><ul class="internal"><li><a class="tocitem" href="#Specific-types"><span>Specific types</span></a></li><li><a class="tocitem" href="#General-types"><span>General types</span></a></li><li><a class="tocitem" href="#SPMF"><span>SPMF</span></a></li><li><a class="tocitem" href="#CORK-data-types"><span>CORK data types</span></a></li><li><a class="tocitem" href="#Helper-types"><span>Helper types</span></a></li></ul></li><li><a class="tocitem" href="../compute_functions/">Compute functions</a></li><li><a class="tocitem" href="../linsolvers/">Linear solvers</a></li><li><a class="tocitem" href="../innersolvers/">Projection</a></li><li><a class="tocitem" href="../errmeasure/">Measuring the error</a></li><li><a class="tocitem" href="../logger/">Logger</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../deflation/">Deflation</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="tocitem" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="tocitem" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="tocitem" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="tocitem" href="../tutorial_call_python/">Tutorial 5 (Python 1)</a></li><li><a class="tocitem" href="../tutorial_python_call/">Tutorial 6 (Python 2)</a></li><li><a class="tocitem" href="../tutorial_matlab1/">Tutorial 7 (MATLAB)</a></li><li><a class="tocitem" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="tocitem" href="../tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="tocitem" href="../tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li><a class="tocitem" href="../tutorial_linsolve/">Tutorial 11 (Linear solvers)</a></li><li><a class="tocitem" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Types &amp; Data structures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types &amp; Data structures</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/types.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Types-and-Data-structures"><a class="docs-heading-anchor" href="#Types-and-Data-structures">Types &amp; Data structures</a><a id="Types-and-Data-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-Data-structures" title="Permalink"></a></h1><p>Nonlinear eigenvalue problems in NEP-PACK are represented by objects of the type <a href="#NonlinearEigenproblems.NEPCore.NEP"><code>NEP</code></a>. Each <code>NEP</code>-object needs to provide compute functions as we describe in <a href="../compute_functions/">the manual page on compute functions</a>. Efficient compute functions are already implemented for many common and several general types.</p><p>In the section <a href="#Specific-types-1">specific types</a> below, we list a number of common classes. As a user, first see if your problem fits to one of those classes, as NEP-PACK has very efficient compute functions for these classes. If your NEP does not fit into any of the specific types, we recommend that a user tries to specify the problem as an <a href="#NonlinearEigenproblems.NEPTypes.SPMF_NEP"><code>SPMF_NEP</code></a>, which is described in the section <a href="#General-types-1">general types</a>. If your problem can be phrased as a sum of two specific or general types, it is recommended that you use the <a href="#NonlinearEigenproblems.NEPTypes.SumNEP"><code>SumNEP</code></a>-type. NEP-PACK also supports efficient computation with low-rank NEPs via the <a href="#NonlinearEigenproblems.NEPTypes.LowRankFactorizedNEP"><code>LowRankFactorizedNEP</code></a>.</p><p>If your NEP is not easily expressed as an <a href="#NonlinearEigenproblems.NEPTypes.SPMF_NEP"><code>SPMF_NEP</code></a>, you may want to use the <a href="#Helper-types-1">helper types</a>. The data types associated with compact certain pencils are also supported, as described in the <a href="#CORK-data-types-1">CORK data types</a>.</p><p>The types also have a number of associated operations and transformation functions. The following example illustrates how you can resample a NEP (by interpolation with a Chebyshev polynomial basis in Chebyshev points provided by the <a href="#NonlinearEigenproblems.NEPTypes.ChebPEP"><code>ChebPEP</code></a> constructor) and apply a NEP-solver which requires many function evaluations, in this case <a href="../methods/#NonlinearEigenproblems.NEPSolver.contour_beyn"><code>contour_beyn</code></a>. The two-stage solution approach is much more efficient.</p><pre><code class="language-julia-repl hljs">julia&gt; nep_bem=nep_gallery(&quot;bem_fichera&quot;);
julia&gt; cheb_nep=ChebPEP(nep_bem,20,0,10); # resample the NEP with 20 cheb points
 32.651313 seconds (263.16 M allocations: 36.279 GiB, 17.19% gc time)
julia&gt; @time (λ1,v1)=contour_beyn(nep_bem,radius=[5 0.2],σ=5.0, N=100,k=10,);
180.329069 seconds (1.39 G allocations: 183.462 GiB, 13.01% gc time)
julia&gt; @time (λ2,v2)=contour_beyn(cheb_nep,radius=[5 0.2],σ=5.0, N=100,k=10,);
  4.319376 seconds (362.34 k allocations: 8.856 GiB, 12.42% gc time)</code></pre><p>Note that running the contour integral method on the <code>cheb_nep</code> is much faster, even if we take into account that the resampling takes some computational effort. The computed solutions are very similar</p><pre><code class="language-julia-repl hljs">julia&gt; λ1
2-element Array{Complex{Float64},1}:
 6.450968052414575 - 4.819767260258272e-5im
 8.105873440358572 - 0.00012794471501522612im
julia&gt; λ2
2-element Array{Complex{Float64},1}:
 6.450968052984224 - 4.819762104884087e-5im
 8.105873439472735 - 0.0001279450670266529im</code></pre><p>Moreover, if we want a very accurate solution, we can run a locally convergence iterative method on the original problem. It converges in very few iterations:</p><pre><code class="language-julia-repl hljs">julia&gt; (λ2_1,v1_1)=quasinewton(nep_bem,λ=λ2[1], v=v2[:,1],logger=1);
Precomputing linsolver
iter 1 err:3.638530108313503e-12 λ=6.450968052984224 - 4.819762104884087e-5im
iter 2 err:1.2789912958165988e-14 λ=6.450968052419756 - 4.819768321350077e-5im
julia&gt; (λ2_2,v1_2)=quasinewton(nep_bem,λ=λ2[2], v=v2[:,2],logger=1)
Precomputing linsolver
iter 1 err:3.4824421200567996e-12 λ=8.105873439472735 - 0.0001279450670266529im
iter 2 err:2.05407750614131e-14 λ=8.105873440343123 - 0.00012794469925178411im</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The use of of Chebyshev interpolation in combination with the boundary element method (but with a companion linearization approach) was presented in  <a href="https://doi.org/10.1007/s10543-012-0381-5">Effenberger and Kressner. &quot;Chebyshev interpolation for nonlinear eigenvalue problems.&quot; BIT Numerical Mathematics 52.4 (2012): 933-951</a>. See also <a href="../bemtutorial/">the tutorial on boundary element method</a>.</p></div></div><h2 id="Specific-types"><a class="docs-heading-anchor" href="#Specific-types">Specific types</a><a id="Specific-types-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.DEP" href="#NonlinearEigenproblems.NEPTypes.DEP"><code>NonlinearEigenproblems.NEPTypes.DEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">type DEP &lt;: AbstractSPMF
function DEP(AA::Vector{AbstractMatrix} [,tauv::Vector=[0,1.0]])</code></pre><p>A <code>DEP</code> (Delay Eigenvalue problem) is a problem defined by the sum</p><p class="math-container">\[M(λ)=-λI + Σ_i A_i exp(-τ_i λ)\]</p><p>where all of the matrices are of size <span>$n×n$</span>. This type of NEP describes the stability of time-delay systems.</p><p>The construction takes the system matrices <span>$A_i$</span>, and <code>tauv</code> is a vector of the values  <span>$τ_i$</span>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A0=randn(3,3); A1=randn(3,3);
julia&gt; tauv=[0,0.2] # Vector with delays
julia&gt; dep=DEP([A0,A1],tauv)
julia&gt; λ=3.0;
julia&gt; M1=compute_Mder(dep,λ)
julia&gt; M2=-λ*I+A0+A1*exp(-tauv[2]*λ)
julia&gt; norm(M1-M2)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/NEPTypes.jl#L401-L426">source</a></section></article><p>There are two types to represent PEPs natively in NEP-PACK. You can use a monomial basis with <code>PEP</code> or a Chebyshev basis with <code>ChebPEP</code>.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.PEP" href="#NonlinearEigenproblems.NEPTypes.PEP"><code>NonlinearEigenproblems.NEPTypes.PEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PEP &lt;: AbstractSPMF
function PEP(AA::Vector{AbstractMatrix})</code></pre><p>The type <code>PEP</code> defines a polynomial eigenvalue  problem via its monomial coefficients. A polynomial eigenvalue problem (PEP) is defined by the sum the</p><p class="math-container">\[Σ_i A_i λ^i,\]</p><p>where <span>$i = 0,1,2,$</span>, and  all of the matrices are of size <span>$n×n$</span>. The vector <code>AA</code> contains <span>$A_1,...$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A0=[1.0 3; 4 5]; A1=A0.+one(2); A2=ones(2,2);
julia&gt; pep=PEP([A0,A1,A2])
julia&gt; compute_Mder(pep,3)-(A0+A1*3+A2*9)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0</code></pre><p>See also <a href="../methods/#NonlinearEigenproblems.NEPSolver.polyeig"><code>polyeig</code></a>, <a href="../methods/#NonlinearEigenproblems.NEPSolver.companion"><code>companion</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.ChebPEP"><code>ChebPEP</code></a>, <a href="../transformations/#NonlinearEigenproblems.NEPTypes.interpolate"><code>interpolate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/types_poly.jl#L5-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.ChebPEP" href="#NonlinearEigenproblems.NEPTypes.ChebPEP"><code>NonlinearEigenproblems.NEPTypes.ChebPEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ChebPEP(orgnep::NEP,k,[a=-1,[b=1]] [,cosine_formula_cutoff=5])</code></pre><p>The type <code>ChebPEP&lt;:AbstractSPMF</code> represents a polynomial function where the function is stored using a Chebyshev basis scaled to the interval <code>[a,b]</code>, i.e.,</p><p class="math-container">\[M(λ)= B_0T_0(λ)+⋯+B_{k-1}T_{k-1}(λ)\]</p><p>where <span>$T_i$</span> are the scaled and shifted Chebyshev polynomials.</p><p>The constructor <code>ChebPEP</code> takes <code>nep::NEP</code> as an input and interpolates this NEP in <code>k</code> Chebyshev nodes, resulting in a polynomial of degree <code>k-1</code>, represented by its coefficients in the Chebyshev basis. Interpolation in Chebyshev nodes and representation with Chebyshev basis, is known to have attractive approximation properties, as well as robustness with respect to round-off errors.</p><p>The kwarg <code>cosine_formula_cutoff</code> decides how the Chebyshev polynomials should be computed. For larger degrees, it is better to use the cosine formula, whereas for low degrees the explicit monomial expression is more efficient. The explicit monomial expression will be used for degrees lower than <code>cosine_formula_cutoff</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; chebpep=ChebPEP(nep,9);
julia&gt; using LinearAlgebra;
julia&gt; norm(compute_Mder(nep,0.3)-compute_Mder(chebpep,0.3))
1.2881862971045282e-8
julia&gt; chebpep=ChebPEP(nep,19); # Better interpolation
julia&gt; norm(compute_Mder(nep,0.3)-compute_Mder(chebpep,0.3))
2.0312004517316714e-15</code></pre><p>See also: <a href="../methods/#NonlinearEigenproblems.NEPSolver.polyeig"><code>polyeig</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.PEP"><code>PEP</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/types_cheb_pep.jl#L151-L193">source</a></section></article><h3 id="REP"><a class="docs-heading-anchor" href="#REP">REP</a><a id="REP-1"></a><a class="docs-heading-anchor-permalink" href="#REP" title="Permalink"></a></h3><p>The Rational Eigenvalue Problem is described by:</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.REP" href="#NonlinearEigenproblems.NEPTypes.REP"><code>NonlinearEigenproblems.NEPTypes.REP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function REP(A,roots,poles)</code></pre><p>A <code>REP</code>-call creates a rational eigenvalue problem. The <code>REP</code> is defined by the sum <span>$Σ_i A_i s_i(λ)/q_i(λ)$</span>, where i = 0,1,2,..., all of the matrices are of size <span>$n×n$</span> and <span>$s_i$</span> and <span>$q_i$</span> are polynomials. The constructor takes the roots and poles as input of polynomials with normalized highest coefficient. The NEP is defined as</p><p class="math-container">\[-λI+A_0+A_1\frac{p(λ)}{q(λ)}\]</p><p>where <code>p</code> has the roots <code>roots</code> and <code>q</code> has the roots <code>poles</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A0=[1 2; 3 4]; A1=[3 4; 5 6];
julia&gt; nep=REP([A0,A1],[1,3], [4,5,6]);
julia&gt; compute_Mder(nep,3)
2×2 Array{Float64,2}:
 Inf  Inf
 Inf  Inf
julia&gt; (λ,x)=quasinewton(nep,v=[1;0])
(-0.3689603779201249 + 0.0im, Complex{Float64}[-2.51824+0.0im, 1.71283+0.0im])
julia&gt; -λ*x+A0*x+A1*x*(λ-1)*(λ-3)/((λ-4)*(λ-5)*(λ-6))
2-element Array{Complex{Float64},1}:
 -2.5055998942313806e-13 + 0.0im
   1.318944953254686e-13 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/NEPTypes.jl#L519-L547">source</a></section></article><h2 id="General-types"><a class="docs-heading-anchor" href="#General-types">General types</a><a id="General-types-1"></a><a class="docs-heading-anchor-permalink" href="#General-types" title="Permalink"></a></h2><p>The basic class is the abstract class <code>NEP</code> which represents a NEP. All other defined NEPs should inherit from <code>NEP</code>, or from a more specialized version; see, e.g., <a href="../transformations/#NonlinearEigenproblems.NEPTypes.ProjectableNEP"><code>ProjectableNEP</code></a> or <a href="#NonlinearEigenproblems.NEPTypes.AbstractSPMF"><code>AbstractSPMF</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.NEP" href="#NonlinearEigenproblems.NEPCore.NEP"><code>NonlinearEigenproblems.NEPCore.NEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract NEP</code></pre><p>A <code>NEP</code> object represents a nonlinear eigenvalue problem. All NEPs should implement</p><pre><code class="language-julia hljs">size(nep::NEP,d)</code></pre><p>and at least one of the following</p><ul><li>M = <a href="../compute_functions/#NonlinearEigenproblems.NEPCore.compute_Mder"><code>compute_Mder(nep::NEP,λ::Number,i::Integer=0)</code></a></li><li>V = <a href="../compute_functions/#NonlinearEigenproblems.NEPCore.compute_Mlincomb"><code>compute_Mlincomb(nep::NEP,λ::Number,V::AbstractVecOrMat,a::Vector)</code></a> (or <code>compute_Mlincomb!</code>)</li><li>MM = <a href="../compute_functions/#NonlinearEigenproblems.NEPCore.compute_MM"><code>compute_MM(nep::NEP,S,V)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/NEPCore.jl#L55-L69">source</a></section></article><p>Below we list the most common types built-in to NEP-PACK, and further down how you can <a href="#accessNEP">access the NEP</a>. However, the structure is made for extendability, and hence it is possible for you to extend with your own class of NEPs.</p><h2 id="SPMF"><a class="docs-heading-anchor" href="#SPMF">SPMF</a><a id="SPMF-1"></a><a class="docs-heading-anchor-permalink" href="#SPMF" title="Permalink"></a></h2><p>One of the most common problem types is the <code>SPMF_NEP</code>. SPMF is short for Sum of Products of Matrices and Functions and the NEP is described by</p><p class="math-container">\[M(λ) = \sum_{i} A_i f_i(λ).\]</p><p>The constructor of the <code>SPMF_NEP</code>, takes the the matrices and the functions, but also a number of other (optional) parameters which may increase performance or preserve underlying types.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.SPMF_NEP" href="#NonlinearEigenproblems.NEPTypes.SPMF_NEP"><code>NonlinearEigenproblems.NEPTypes.SPMF_NEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SPMF_NEP{T&lt;:AbstractMatrix,Ftype}  &lt;: AbstractSPMF{T}
function SPMF_NEP(AA, fii [,check_consistency=true] [,Schur_fact = false]
                  [,align_sparsity_patterns = false] [,Ftype=ComplexF64])</code></pre><p>An <code>SPMF_NEP</code> is a <code>NEP</code> defined by a <em>S</em>um of <em>P</em>roducts of <em>M</em>atrices and <em>F</em>unctions, i.e.,</p><p class="math-container">\[M(λ)=∑_i A_i f_i(λ).\]</p><p>All of the matrices <span>$A_0,...$</span> are of size <span>$n×n$</span> and <span>$f_i$</span> are a functions. The  functions <span>$f_i$</span> must be defined for matrices in the standard matrix function sense. The constructor creates a <code>SPMF_NEP</code> consisting of matrices <code>AA</code> and functions <code>fii</code>.</p><p><strong>Parameters</strong></p><ul><li><p><code>AA</code> is a <code>Vector</code> of matrices. The matrices have to be of the same type. If you need a NEP with different types you can use <a href="#NonlinearEigenproblems.NEPTypes.SumNEP"><code>SumNEP</code></a> to construct a sum of two <code>SPMF_NEP</code>.</p></li><li><p><code>fii</code> is a <code>Vector</code> of functions. Each function takes one parameter <code>S</code>. The functions must be available both as a scalar valid function and a matrix function. If <code>S</code> is a square matrix, <code>fii[k](S)</code> musst also be a square matrix. If <code>S</code> is a scalar <code>fii[k](S)</code> is a scalar.</p></li><li><p><code>check_consistency</code> (default <code>true</code>) determines if we should initiate by running tests to verify that the <code>fii</code> satisfies the conditions that every function is valid both for matrices and scalars. This is done by using <code>@code_typed</code> and the functions need to be type-stable in that sense.</p></li><li><p><code>align_sparsity_patterns</code> (default <code>false</code>) has effect only for sparse matrices (<code>SparseMatrixCSC</code>). If <code>align_sparsity_patterns=true</code> the <code>SparseMatrixCSC</code> matrices will be replaced by equivalent <code>SparseMatrixCSC</code> matrices where the <code>colptr</code> and <code>rowval</code> are identical. This increases the speed of some functions, e.g., <code>compute_Mder</code>. If <code>align_sparsity_patterns=true</code> the matrices in the NEP should be considered read only. If the sparsity patterns are completely or mostly distinct, it may be more efficient to set this flag to false.</p></li><li><p><code>Ftype</code> (default <code>ComplexF64</code>) determines an underlying type of the functions. The output of any function should be &quot;smaller&quot; than the promoted type of the input and <code>Ftype</code>. More precisely, if <code>F=fii[k]</code>, then the type logic is as follows <code>eltype(F(λ))=promote_type(eltype(λ),Ftype)</code>.</p></li><li><p><code>Schur_fact</code> (default <code>false</code>) determines if the <code>compute_MM</code> function should triangularize the matrix before carrying out the computation. This can be faster for large matrices.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A0=[1 3; 4 5]; A1=[3 4; 5 6];
julia&gt; id_op=S -&gt; one(S) # Note: We use one(S) to be valid both for matrices and scalars
julia&gt; exp_op=S -&gt; exp(S)
julia&gt; nep=SPMF_NEP([A0,A1],[id_op,exp_op]);
julia&gt; compute_Mder(nep,1)-(A0+A1*exp(1))
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/NEPTypes.jl#L115-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.AbstractSPMF" href="#NonlinearEigenproblems.NEPTypes.AbstractSPMF"><code>NonlinearEigenproblems.NEPTypes.AbstractSPMF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract  AbstractSPMF &lt;: ProjectableNEP</code></pre><p>An AbstractSPMF is an abstract class representing NEPs which can be represented as a sum of products of matrices and functions <span>$M(λ)=Σ_i A_i f_i(λ)$</span>, where i = 0,1,2,..., all of the matrices are of size <span>$n×n$</span> and <span>$f_i$</span> are functions.</p><p>Any AbstractSPMF has to have implementations of <a href="#NonlinearEigenproblems.NEPTypes.get_Av"><code>get_Av()</code></a> and <a href="#NonlinearEigenproblems.NEPTypes.get_fv"><code>get_fv()</code></a> which return the functions and matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/NEPTypes.jl#L86-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.get_Av" href="#NonlinearEigenproblems.NEPTypes.get_Av"><code>NonlinearEigenproblems.NEPTypes.get_Av</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_Av(nep::AbstractSPMF)</code></pre><p>Returns an array of matrices <span>$A_i$</span> in the AbstractSPMF: <span>$M(λ)=Σ_i A_i f_i(λ)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/NEPTypes.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.get_fv" href="#NonlinearEigenproblems.NEPTypes.get_fv"><code>NonlinearEigenproblems.NEPTypes.get_fv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_Av(nep::AbstractSPMF)</code></pre><p>Returns an Array of functions (that can be evaluated both as scalar and matrix functions) <span>$f_i$</span> in the AbstractSPMF: <span>$M(λ)=Σ_i A_i f_i(λ)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/NEPTypes.jl#L106-L110">source</a></section></article><h3 id="Projectable-NEP-types"><a class="docs-heading-anchor" href="#Projectable-NEP-types">Projectable NEP types</a><a id="Projectable-NEP-types-1"></a><a class="docs-heading-anchor-permalink" href="#Projectable-NEP-types" title="Permalink"></a></h3><p>There are also types associated with projection described on  <a href="../innersolvers/">the projection manual page</a>:</p><ul><li><a href="../innersolvers/#NonlinearEigenproblems.NEPTypes.ProjectableNEP"><code>ProjectableNEP</code></a></li><li><a href="../innersolvers/#NonlinearEigenproblems.NEPTypes.Proj_NEP"><code>Proj_NEP</code></a></li></ul><h3 id="SumNEP"><a class="docs-heading-anchor" href="#SumNEP">SumNEP</a><a id="SumNEP-1"></a><a class="docs-heading-anchor-permalink" href="#SumNEP" title="Permalink"></a></h3><p>It is also possible to consider NEPs that are sums of other NEPs. For such situations there are SumNEPs. Specifically <code>GenericSumNEP</code> and <code>SPMFSumNEP</code>. Both are constructed using the function <code>SumNEP</code>.</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.SumNEP" href="#NonlinearEigenproblems.NEPTypes.SumNEP"><code>NonlinearEigenproblems.NEPTypes.SumNEP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SumNEP{nep1::NEP,nep2::NEP}
SumNEP{nep1::AbstractSPMF,nep2::AbstractSPMF}</code></pre><p><code>SumNEP</code> is a function creating an object that corresponds to a sum of two NEPs, i.e., if nep is created by <code>SumNEP</code> it is defined by</p><p class="math-container">\[M(λ)=M_1(λ)+M_2(λ)\]</p><p>where <span>$M_1$</span> and <span>$M_2$</span> are defined by <code>nep1</code> and <code>nep2</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep1=DEP([ones(3,3),randn(3,3)])
julia&gt; nep2=PEP([ones(3,3),randn(3,3),randn(3,3)])
julia&gt; sumnep=SumNEP(nep1,nep2);
julia&gt; s=3.0;
julia&gt; M=compute_Mder(sumnep,s);
3×3 Array{Float64,2}:
  8.54014     6.71897   7.12007
 -0.943908  -13.0795   -0.621659
  6.03155    -7.26726  -6.42828
julia&gt; M1=compute_Mder(nep1,s);
julia&gt; M2=compute_Mder(nep2,s);
julia&gt; M1+M2  # Same as M
3×3 Array{Float64,2}:
  8.54014     6.71897   7.12007
 -0.943908  -13.0795   -0.621659
  6.03155    -7.26726  -6.42828</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.SPMFSumNEP"><code>SPMFSumNEP</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.GenericSumNEP"><code>GenericSumNEP</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/NEPTypes.jl#L848-L881">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.GenericSumNEP" href="#NonlinearEigenproblems.NEPTypes.GenericSumNEP"><code>NonlinearEigenproblems.NEPTypes.GenericSumNEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GenericSumNEP{NEP1&lt;:NEP,NEP2&lt;:NEP}  &lt;: NEP</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.SumNEP"><code>SumNEP</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.SPMFSumNEP"><code>SPMFSumNEP</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/NEPTypes.jl#L823-L827">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.SPMFSumNEP" href="#NonlinearEigenproblems.NEPTypes.SPMFSumNEP"><code>NonlinearEigenproblems.NEPTypes.SPMFSumNEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SPMFSumNEP{NEP1&lt;:AbstractSPMF,NEP2&lt;:AbstractSPMF}  &lt;: AbstractSPMF{AbstractMatrix}</code></pre><p>See also: <a href="#NonlinearEigenproblems.NEPTypes.SumNEP"><code>SumNEP</code></a>, <a href="#NonlinearEigenproblems.NEPTypes.GenericSumNEP"><code>GenericSumNEP</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/NEPTypes.jl#L833-L837">source</a></section></article><h3 id="Low-rank-NEPs"><a class="docs-heading-anchor" href="#Low-rank-NEPs">Low-rank NEPs</a><a id="Low-rank-NEPs-1"></a><a class="docs-heading-anchor-permalink" href="#Low-rank-NEPs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.LowRankFactorizedNEP" href="#NonlinearEigenproblems.NEPTypes.LowRankFactorizedNEP"><code>NonlinearEigenproblems.NEPTypes.LowRankFactorizedNEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LowRankFactorizedNEP &lt;: AbstractSPMF
function LowRankFactorizedNEP(L::Vector,U::Vector,f::Vector)
function LowRankFactorizedNEP(L::Vector,U::Vector,A::Vector, f::Vector)</code></pre><p>Representation of a <code>NEP</code> which has low rank in the sense that it is an <code>SPMF</code> where each of the terms are factorized: <code>A[i]=L[i]*U[i]&#39;</code>. The factorization is provided in the <code>L</code> and <code>U</code> vectors and the full matrix <code>A[i]</code> can be either provided (or is otherwise implicitly computed).</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; L=randn(5,1); U=randn(5,1);
julia&gt; f=S-&gt;exp(S)
julia&gt; nep=LowRankFactorizedNEP([L],[U],[f]);
julia&gt; X=randn(5,2);
julia&gt; norm(compute_Mlincomb(nep,0.0,X)-L*U&#39;*X*ones(2),1)
6.661338147750939e-16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/low_rank_nep.jl#L3-L24">source</a></section></article><h2 id="CORK-data-types"><a class="docs-heading-anchor" href="#CORK-data-types">CORK data types</a><a id="CORK-data-types-1"></a><a class="docs-heading-anchor-permalink" href="#CORK-data-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTransformations.CORKPencil" href="#NonlinearEigenproblems.NEPTransformations.CORKPencil"><code>NonlinearEigenproblems.NEPTransformations.CORKPencil</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CORKPencil
function CORKPencil(M,N,Av,Bv,Z);
function CORKPencil(nep,is)</code></pre><p>The struct <code>CORKPencil</code> represents a pencil with a particular structure, as given in the reference. The data can either be constructed directly via the first constructor, or from a NEP in the second constructor. The second constructor takes a <code>NEP</code> and  <code>is</code> which specifies a CORK-structure as well as an approximation method. This can be objects of the type <code>IarCorkLinearization</code> or <code>NleigsCorkLinearization</code>, which are the CORK-linearizations equivalent to (certain versions of) <a href="../methods/#NonlinearEigenproblems.NEPSolver.iar"><code>iar</code></a> and <a href="../methods/#NonlinearEigenproblems.NEPSolver.nleigs"><code>nleigs</code></a>.</p><p>See <a href="#NonlinearEigenproblems.NEPTransformations.buildPencil"><code>buildPencil</code></a> how to build standard pencil.</p><p><strong>Example:</strong></p><p>The following example constructs a  <code>CORKPencil</code> from a general NEP and then computes approximations of NEPs by the interpolation approach of <code>nleigs</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra
julia&gt; A=(1:4)*(1:4)&#39;+I; B=diagm(1 =&gt; [1,2,3]); C=ones(4,4);
julia&gt; f1= λ-&gt; one(λ);
julia&gt; f2= λ-&gt; λ;
julia&gt; f3= λ-&gt; exp(sin(λ/2));
julia&gt; nep=SPMF_NEP([A,B,C],[f1,f2,f3]);
julia&gt; cp=CORKPencil(nep,NleigsCorkLinearization());
julia&gt; (A,B)=buildPencil(cp) # Form the pencil
julia&gt; λv=eigen(A,B).values;
julia&gt; λ=λv[sortperm(abs.(λv))[1]]; # Smallest eigval
julia&gt; minimum(svdvals(compute_Mder(nep,λ))) # It&#39;s a solution
2.4364382475487156e-11</code></pre><p><strong>References:</strong></p><ul><li><p>Compact rational Krylov methods for nonlinear eigenvalue problems SIAM Journal on Matrix Analysis and Applications, 36 (2), 820-838, 2015.</p><pre><code class="nohighlight hljs"></code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/NEPTransformations.jl#L233-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTransformations.buildPencil" href="#NonlinearEigenproblems.NEPTransformations.buildPencil"><code>NonlinearEigenproblems.NEPTransformations.buildPencil</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(A,B)=buildPencil(cp)</code></pre><p>Constructs a pencil from a <code>CORKPencil</code> or <code>CORKPencilLR</code>. The returned matrices correspond to a generalized eigenvalue problem. See also <a href="#NonlinearEigenproblems.NEPTransformations.CORKPencil"><code>CORKPencil</code></a>, <a href="#NonlinearEigenproblems.NEPTransformations.CORKPencilLR"><code>CORKPencilLR</code></a>. See [<code>lowRankCompress</code>] for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/NEPTransformations.jl#L331-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTransformations.CORKPencilLR" href="#NonlinearEigenproblems.NEPTransformations.CORKPencilLR"><code>NonlinearEigenproblems.NEPTransformations.CORKPencilLR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CORKPencilLR
function CORKPencilLR(M,N,Av,AvLR,Bv,BvLR,Z);</code></pre><p>Represents / constructs a low-rank CORK-pencil. <code>AvLR</code>, <code>BvLR</code> and <code>Z</code> correspond to the low-rank factorization of terms <code>Av</code> and <code>Bv</code>. See <a href="#NonlinearEigenproblems.NEPTransformations.CORKPencil"><code>CORKPencil</code></a> and reference below.</p><p><strong>Example</strong></p><p>The example illustrate a low-rank linearization of a Taylor expansion of the NEP <span>$A0-λI+vv^Te^{-λ}$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; A0=[1.0 3.0; -1.0 2.0]/10;
julia&gt; v=reshape([-1.0 ; 1]/sqrt(2),n,1);

julia&gt; Av=[-A0-v*v&#39;]
julia&gt; Bv=[-one(A0)-v*v&#39;]
julia&gt; BvLR=[v/2, -v/3, v/4, -v/5, v/6, -v/7,  v/8, -v/9]
julia&gt; AvLR=zero.(BvLR);
julia&gt; Z=v;
julia&gt; d=9;
julia&gt; M=diagm( 0 =&gt;  ones(d) )[2:end,:]
julia&gt; N=diagm( -1 =&gt;  1 ./ (1:d-1) )[2:end,:]
julia&gt; cplr=CORKPencilLR(M,N,Av,AvLR,Bv,BvLR,Z);
julia&gt; (AA,BB)=buildPencil(cplr);
julia&gt; λ=eigen(AA,BB).values[end];
julia&gt; minimum(svdvals(A0-λ*I+v*v&#39;*exp(-λ)))
8.870165379112754e-13</code></pre><p><strong>References:</strong></p><ul><li>Section 7 in Compact rational Krylov methods for nonlinear eigenvalue problems SIAM Journal on Matrix Analysis and Applications, 36 (2), 820-838, 2015.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/NEPTransformations.jl#L347-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTransformations.lowRankCompress" href="#NonlinearEigenproblems.NEPTransformations.lowRankCompress"><code>NonlinearEigenproblems.NEPTransformations.lowRankCompress</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cplr=lowRankCompress(cp_org::CORKPencil,dtilde,rk)</code></pre><p>Constructs a <a href="#NonlinearEigenproblems.NEPTransformations.CORKPencilLR"><code>CORKPencilLR</code></a> from a <a href="#NonlinearEigenproblems.NEPTransformations.CORKPencil"><code>CORKPencil</code></a>. This is done by assuming that terms higher than <code>dtilde</code> are of low rank, with rank <code>rk</code>. More precisely, all <code>A[j]</code> and <code>B[j]</code> for <code>j&gt;dtilde</code> are assumed to be of the form <span>$C_jZ^T$</span>.</p><p><strong>Example</strong></p><p>This illustrates how to form a <code>CORKPencil</code> from a NEP, and subsequently form a smaller pencil using <code>CORKPencilLR</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; A0=[1.0 3.0; -1.0 2.0]/10;
julia&gt; v=[-1.0 ; 1]/sqrt(2);
julia&gt; nep=DEP([A0,v*v&#39;]);
julia&gt; cp_org=CORKPencil(nep,IarCorkLinearization(d=10));
julia&gt; cplr=lowRankCompress(cp_org::CORKPencil,1,1);
julia&gt; (AA,BB)=buildPencil(cplr);
julia&gt; λ=eigen(AA,BB).values[end];
julia&gt; minimum(svdvals(A0-λ*I+v*v&#39;*exp(-λ))) # Check if it is an eigval
2.7621446071952216e-14</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/345675a4bc696037c674a3272ee4eca96dcc0171/src/NEPTransformations.jl#L394-L419">source</a></section></article><h2 id="Helper-types"><a class="docs-heading-anchor" href="#Helper-types">Helper types</a><a id="Helper-types-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-types" title="Permalink"></a></h2><p>There are also the helper types <a href="../compute_functions/#NonlinearEigenproblems.NEPTypes.Mder_NEP"><code>Mder_NEP</code></a> and <a href="../compute_functions/#NonlinearEigenproblems.NEPTypes.Mder_Mlincomb_NEP"><code>Mder_Mlincomb_NEP</code></a>. These are further described in the section about <a href="../compute_functions/">Compute functions</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../methods/">« NEP-Solvers</a><a class="docs-footer-nextpage" href="../compute_functions/">Compute functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 2 October 2022 12:46">Sunday 2 October 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
