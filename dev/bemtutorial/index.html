<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 3 (BEM) · NEP-PACK</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NEP-PACK</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../methods/">NEP-Solvers</a></li><li><a class="tocitem" href="../types/">Types &amp; Data structures</a></li><li><a class="tocitem" href="../compute_functions/">Compute functions</a></li><li><a class="tocitem" href="../linsolvers/">Linear solvers</a></li><li><a class="tocitem" href="../innersolvers/">Projection</a></li><li><a class="tocitem" href="../errmeasure/">Measuring the error</a></li><li><a class="tocitem" href="../logger/">Logger</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../deflation/">Deflation</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="tocitem" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li class="is-active"><a class="tocitem" href>Tutorial 3 (BEM)</a><ul class="internal"><li><a class="tocitem" href="#Boundary-element-method"><span>Boundary element method</span></a></li><li><a class="tocitem" href="#Manual-implementation-in-NEP-PACK"><span>Manual implementation in NEP-PACK</span></a></li><li><a class="tocitem" href="#Solving-the-NEP"><span>Solving the NEP</span></a></li><li><a class="tocitem" href="#Implementation-in-NEP-PACK-using-the-Mder_NEP-type"><span>Implementation in NEP-PACK using the <code>Mder_NEP</code> type</span></a></li></ul></li><li><a class="tocitem" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="tocitem" href="../tutorial_call_python/">Tutorial 5 (Python 1)</a></li><li><a class="tocitem" href="../tutorial_python_call/">Tutorial 6 (Python 2)</a></li><li><a class="tocitem" href="../tutorial_matlab1/">Tutorial 7 (MATLAB)</a></li><li><a class="tocitem" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="tocitem" href="../tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="tocitem" href="../tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li><a class="tocitem" href="../tutorial_linsolve/">Tutorial 11 (Linear solvers)</a></li><li><a class="tocitem" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Tutorial 3 (BEM)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial 3 (BEM)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/bemtutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial:-User-defined-matrices-boundary-element-method"><a class="docs-heading-anchor" href="#Tutorial:-User-defined-matrices-boundary-element-method">Tutorial: User-defined matrices - boundary element method</a><a id="Tutorial:-User-defined-matrices-boundary-element-method-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial:-User-defined-matrices-boundary-element-method" title="Permalink"></a></h1><p>Suppose you have a new type of NEP, which does not naturally fit into the standard types in NEP-PACK. This tutorial shows how you can define a NEP where the only way to access the NEP is a function to compute <span>$M^{(k)}(λ)$</span>. We first show the manual way to do it, as it illustrates some of the workings of NEP-PACK. However, the use case is common enough to have native support in NEP-PACK. Hence, we also show how to use a special NEP-type called <a href="../compute_functions/#NonlinearEigenproblems.NEPTypes.Mder_NEP"><code>Mder_NEP</code></a>.</p><p>For this example we use a <a href="https://en.wikipedia.org/wiki/Boundary_element_method">boundary element method</a> approach for computation of resonances. The complete code is available in <code>gallery_extra/bem_hardcoded</code>. The example is also available as a gallery problem: <code>nep=nep_gallery(&quot;bem_fichera&quot;)</code>.</p><h2 id="Boundary-element-method"><a class="docs-heading-anchor" href="#Boundary-element-method">Boundary element method</a><a id="Boundary-element-method-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-element-method" title="Permalink"></a></h2><p>The boundary element method applied to Helmholtz eigenvalue problem can be described by the matrix consisting of elements</p><p class="math-container">\[[M(λ)]_{ij}=\frac{1}{4\pi}\int_{\Delta_i}\int_{\Delta_j}\frac{e^{\iota\lambda\|\xi-\eta\|}}{\|\xi-\eta\|}dS(\eta)dS(\xi)\]</p><p>where <span>$\Delta_i$</span>, <span>$i=1,\ldots,n$</span> are boundary elements. The boundary element approach is available through three functions: <code>gen_ficheramesh</code> to compute the mesh, <code>precompute_quad!</code> to precompute the quadrature coeeficients, and <code>assemble_BEM</code> to compute the matrix consisting of all the integrals corresponding to <code>λ</code>. These functions are based on the model (and inspired by some of the code) in <a href="http://sma.epfl.ch/~anchpcommon/students/steinlechner.pdf">&quot;A boundary element method for solving PDE eigenvalue problems&quot;, Steinlechner, bachelor thesis, ETH Zürich, 2010</a> and also used in the simulations in <a href="https://link.springer.com/article/10.1007/s10543-012-0381-5">&quot;Chebyshev interpolation for nonlinear eigenvalue problems&quot;, Effenberger, Kressner, BIT Numerical Mathematics, 2012, Volume 52, Issue 4, pp 933–951</a>.</p><p>To get access to the helper functions you need either to work in the <code>gallery_extra/bem_hardcoded</code>-directory, or copy the files in there to your current working directory. The code can also be found <a href="https://github.com/nep-pack/NonlinearEigenproblems.jl/tree/master/src/gallery_extra/bem_hardcoded">directly on github</a>. We start by loading the necessary code:</p><pre><code class="language-julia-repl hljs">julia&gt; using NonlinearEigenproblems;
julia&gt; include(&quot;triangle.jl&quot;);
julia&gt; include(&quot;genmesh.jl&quot;);
julia&gt; include(&quot;assemble_BEM.jl&quot;);</code></pre><h2 id="Manual-implementation-in-NEP-PACK"><a class="docs-heading-anchor" href="#Manual-implementation-in-NEP-PACK">Manual implementation in NEP-PACK</a><a id="Manual-implementation-in-NEP-PACK-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-implementation-in-NEP-PACK" title="Permalink"></a></h2><p>In order to define your new NEP you need to define a new NEP-type</p><pre><code class="language-julia-repl hljs">julia&gt; struct BEM_NEP &lt;: NEP
    mesh::Vector{Triangle}
    n::Int
    gauss_order::Int
    function BEM_NEP(mesh,gauss_order)
        return new(mesh,length(mesh),gauss_order)
    end
end</code></pre><p>The <code>mesh</code> variable is a vector of triangle objects defining the domain, <code>n</code> is the size of the mesh and <code>gauss_order</code> the quadrature order. All NEPs have to define <code>size()</code> functions</p><pre><code class="language-julia-repl hljs">julia&gt; import Base.size; # Import from Base explicitly since we overload

julia&gt; function size(nep::BEM_NEP)
    return (nep.n,nep.n);
end
size (generic function with 142 methods)
julia&gt; function size(nep::BEM_NEP,dim)
    return nep.n;
end
size (generic function with 143 methods)</code></pre><p>The function <code>assemble_BEM</code> computes the matrix defined by the integrals. Hence, we need to call this function for every call to <a href="../compute_functions/#NonlinearEigenproblems.NEPCore.compute_Mder"><code>compute_Mder</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; import NonlinearEigenproblems.NEPCore.compute_Mder # We overload the function
julia&gt; function compute_Mder(nep::BEM_NEP,λ::Number,der::Int=0)
    return assemble_BEM(λ, nep.mesh, nep.gauss_order, der)[:,:,1];
end
compute_Mder (generic function with 42 methods)</code></pre><p>In order to make other compute functions available to the methods, we can use the conversion functions. In particular, the <a href="../compute_functions/#NonlinearEigenproblems.NEPCore.compute_Mlincomb"><code>compute_Mlincomb</code></a> function can be implemented by making several calls in <code>compute_Mder</code>. This is done in the NEP-PACK-provided helper function <code>compute_Mlincomb_from_Mder</code>. We make this the default behaviour for this NEP:</p><pre><code class="language-julia-repl hljs">julia&gt; import NonlinearEigenproblems.NEPCore.compute_Mlincomb # Since we overload
# Delegate the compute Mlincomb functions. This can be quite inefficient.
julia&gt; compute_Mlincomb(nep::BEM_NEP,λ::Number,V::AbstractVecOrMat, a::Vector) =
      compute_Mlincomb_from_Mder(nep,λ,V,a)
compute_Mlincomb (generic function with 36 methods)
julia&gt; compute_Mlincomb(nep::BEM_NEP,λ::Number,V::AbstractVecOrMat) =
      compute_Mlincomb(nep,λ,V, ones(eltype(V),size(V,2)))
compute_Mlincomb (generic function with 37 methods)</code></pre><p>We can now create a <code>BEM_NEP</code> as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; gauss_order=3; N=5;
julia&gt; mymesh=gen_ficheramesh(N);
julia&gt; precompute_quad!(mymesh,gauss_order);
julia&gt; nep=BEM_NEP(mymesh,gauss_order);</code></pre><h2 id="Solving-the-NEP"><a class="docs-heading-anchor" href="#Solving-the-NEP">Solving the NEP</a><a id="Solving-the-NEP-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-NEP" title="Permalink"></a></h2><p>After creating the NEP, you can try to solve the problem with methods in the package, e.g., <a href="../methods/#NonlinearEigenproblems.NEPSolver.mslp"><code>mslp</code></a> works quite well for this problem:</p><pre><code class="language-julia-repl hljs">julia&gt; (λ,v)=mslp(nep,λ=8,logger=1);
iter 1 err:4.122635537095191e-6 λ=8.128272919317748 + 0.007584851218213724im
iter 2 err:1.787963303966838e-8 λ=8.132181234599429 - 1.952792817333862e-5im
iter 3 err:3.2884911876526185e-13 λ=8.132145310156645 - 1.2648247030082216e-5im
iter 4 err:4.417989064002117e-18 λ=8.132145310195458 - 1.264891803723658e-5im</code></pre><p>This is the computed solution:</p><br>
<img src="https://user-images.githubusercontent.com/11163595/49595409-324b7d80-f978-11e8-818d-eeeaf9441505.png" height=450><p>The plotting was done with the following code (by using internals of the BEM-implementation):</p><pre><code class="language-julia-repl hljs">julia&gt; using PyPlot
julia&gt; v=v./maximum(abs.(v));
julia&gt; for k=1:size(nep.mesh,1);
    tri=nep.mesh[k];
    col=[1-abs.(v)[k];0;0]; # plot abslolute value
    X=[tri.P1[1] tri.P2[1]; tri.P3[1] tri.P3[1]];
    Y=[tri.P1[2] tri.P2[2]; tri.P3[2] tri.P3[2]];
    Z=[tri.P1[3] tri.P2[3]; tri.P3[3] tri.P3[3]];
    plot_surface(X,Y,Z,color=col,alpha=0.8);
    plot_wireframe(X,Y,Z,color=[0;0;0],linewidth=1,alpha=0.5,);
end</code></pre><h2 id="Implementation-in-NEP-PACK-using-the-Mder_NEP-type"><a class="docs-heading-anchor" href="#Implementation-in-NEP-PACK-using-the-Mder_NEP-type">Implementation in NEP-PACK using the <code>Mder_NEP</code> type</a><a id="Implementation-in-NEP-PACK-using-the-Mder_NEP-type-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-in-NEP-PACK-using-the-Mder_NEP-type" title="Permalink"></a></h2><p>Some of the manual implementation can be avoided by using the <code>Mder_NEP</code> type. We only need to pass the size of the NEP and a function to compute <span>$M^{(k)}(λ)$</span>, i.e., <code>(λf,derf) -&gt; assemble_BEM(λf, mymesh, gauss_order, derf)[:,:,1]</code>, to the <code>Mder_NEP</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; n = length(mymesh);
julia&gt; mdernep = Mder_NEP(n, (λf,derf) -&gt; assemble_BEM(λf, mymesh, gauss_order, derf)[:,:,1]);
julia&gt; (mderλ,mderv)=mslp(mdernep,λ=8,logger=1);
iter 1 err:4.122635537095191e-6 λ=8.128272919317748 + 0.007584851218213724im
iter 2 err:1.787963303966838e-8 λ=8.132181234599429 - 1.952792817333862e-5im
iter 3 err:3.2884911876526185e-13 λ=8.132145310156645 - 1.2648247030082216e-5im
iter 4 err:4.417989064002117e-18 λ=8.132145310195458 - 1.264891803723658e-5im
julia&gt; λ-mderλ
0.0 + 0.0im</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The above code executes under the assumption that the following code had been run:</p><pre><code class="language-julia hljs">precompute_quad!(mymesh,gauss_order);</code></pre></div></div><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_BEMTUTORIAL" alt="To the top"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial_contour/">« Tutorial 2 (Contour)</a><a class="docs-footer-nextpage" href="../deflate_tutorial/">Tutorial 4 (Deflation) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 28 June 2023 13:04">Wednesday 28 June 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
