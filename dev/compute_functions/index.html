<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Compute functions · NEP-PACK</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NEP-PACK</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../methods/">NEP-Solvers</a></li><li><a class="tocitem" href="../types/">Types &amp; Data structures</a></li><li class="is-active"><a class="tocitem" href>Compute functions</a><ul class="internal"><li><a class="tocitem" href="#Compute-functions-documentation"><span>Compute-functions documentation</span></a></li><li><a class="tocitem" href="#Type-helpers"><span>Type helpers</span></a></li></ul></li><li><a class="tocitem" href="../linsolvers/">Linear solvers</a></li><li><a class="tocitem" href="../innersolvers/">Projection</a></li><li><a class="tocitem" href="../errmeasure/">Measuring the error</a></li><li><a class="tocitem" href="../logger/">Logger</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../deflation/">Deflation</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="tocitem" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="tocitem" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="tocitem" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="tocitem" href="../tutorial_call_python/">Tutorial 5 (Python 1)</a></li><li><a class="tocitem" href="../tutorial_python_call/">Tutorial 6 (Python 2)</a></li><li><a class="tocitem" href="../tutorial_matlab1/">Tutorial 7 (MATLAB)</a></li><li><a class="tocitem" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="tocitem" href="../tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="tocitem" href="../tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li><a class="tocitem" href="../tutorial_linsolve/">Tutorial 11 (Linear solvers)</a></li><li><a class="tocitem" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Compute functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Compute functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/compute_functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Compute-functions"><a class="docs-heading-anchor" href="#Compute-functions">Compute functions</a><a id="Compute-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-functions" title="Permalink"></a></h1><p>The nonlinear eigenvalue problems in NEP-PACK are defined by the data stored in the corresponding NEP-class. The advised way NEP-solvers access the data is to do it through three main functions, which take the NEP-object as input.</p><ul><li><a href="#NonlinearEigenproblems.NEPCore.compute_Mder"><code>compute_Mder</code></a>: Computes a given derivative of the matrix function <span>$M(λ)$</span>.</li><li><a href="#NonlinearEigenproblems.NEPCore.compute_Mlincomb"><code>compute_Mlincomb</code></a> (or <code>compute_Mlincomb!</code>, with same documentation): Computes a linear combination of derivatives <span>$M(λ)$</span></li><li><a href="#NonlinearEigenproblems.NEPCore.compute_MM"><code>compute_MM</code></a>: Computes the block residual.</li></ul><p>The choice of these functions as the fundamental way to access a NEP is a balancing between what applications can provide and NEP-solvers need.</p><p>A user who needs a new class of NEPs (which is not available in among the standard types) is advised to use the helper functions <a href="#NonlinearEigenproblems.NEPTypes.Mder_NEP"><code>Mder_NEP</code></a> and/or <a href="#NonlinearEigenproblems.NEPTypes.Mder_Mlincomb_NEP"><code>Mder_Mlincomb_NEP</code></a> rather than reimplementing the compute-functions, since the helper types are more user friendly. Implementation of your own NEP-type is only advised if needed for efficiency reasons.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Examples of usage of <code>Mder_NEP</code> and/or <code>Mder_Mlincomb_NEP</code> are available in tutorials on <a href="../bemtutorial/">boundary element method</a>, <a href="../tutorial_call_python/">python</a>, <a href="../tutorial_matlab1/">matlab</a>, and <a href="../tutorial_fortran1/">fortran</a>.</p></div></div><p>As a NEP-solver developer, <code>compute_Mlincomb</code>-calls are preferred over <code>compute_Mder</code>-calls, for the same reasons that algorithms that only require matrix vector products can be easier to use in a given application than an iterative algorithm using only matrix vector products. It is in general also more efficient although they produce the same result up to round-off errors:</p><pre><code class="language-julia-repl hljs">julia&gt; using BenchmarkTools;
julia&gt; n=1000; p=10;
julia&gt; nep=DEP([randn(n,n), randn(n,n)];
julia&gt; V=randn(n,p);
julia&gt; @btime compute_Mlincomb(nep,1.0,V);
  478.316 μs (19 allocations: 80.78 KiB)
julia&gt; @btime for k=1:p; z[:]+=compute_Mder(nep,1.0,k)*V[:,k]; end
  78.510 ms (183 allocations: 465.71 MiB)</code></pre><p>The <code>compute_Mlincomb</code>-function exist in two variants, where <code>compute_Mlincomb!</code> may modify the <code>V</code>-matrix, but in general require less memory allocations.</p><p>For a type where only <code>compute_Mder</code> is implemented, the <code>compute_Mlincomb</code>-functionality can be provided by delegating using the function <a href="#NonlinearEigenproblems.NEPCore.compute_Mlincomb_from_Mder"><code>compute_Mlincomb_from_Mder</code></a>, such that methods which require <code>compute_Mlincomb</code> can be used.</p><h2 id="Compute-functions-documentation"><a class="docs-heading-anchor" href="#Compute-functions-documentation">Compute-functions documentation</a><a id="Compute-functions-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-functions-documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_Mder" href="#NonlinearEigenproblems.NEPCore.compute_Mder"><code>NonlinearEigenproblems.NEPCore.compute_Mder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_Mder(nep::NEP,λ::Number [,i::Integer=0])</code></pre><p>Computes the ith derivative of <code>nep</code> evaluated in <code>λ</code>.</p><p><strong>Example</strong></p><p>This example shows that <code>compute_Mder(nep,λ,1)</code> gives the first derivative.</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; ϵ=1e-5; λ=2.25;
julia&gt; Aminus=compute_Mder(nep,λ-ϵ);
julia&gt; Aplus=compute_Mder(nep,λ+ϵ);
julia&gt; opnorm((Aplus-Aminus)/(2ϵ)-compute_Mder(nep,λ,1))
1.8783432885257602e-11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/95cff7631684e52a550fa93956f7c7c6e84e6712/src/NEPCore.jl#L73-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_Mlincomb" href="#NonlinearEigenproblems.NEPCore.compute_Mlincomb"><code>NonlinearEigenproblems.NEPCore.compute_Mlincomb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_Mlincomb(nep::NEP,λ::Number,V, a::Vector=ones(size(V,2)), startder=0)
compute_Mlincomb!(nep::NEP,λ::Number,V, a::Vector=ones(size(V,2)), startder=0)</code></pre><p>Computes the linear combination of derivatives<br/><span>$Σ_i a_i M^{(i)}(λ) v_i$</span> starting from derivative <code>startder</code>. The function <code>compute_Mlincomb!</code> does the same but may modify the <code>V</code> matrix/array.</p><p><strong>Example</strong></p><p>This example shows that <code>compute_Mder</code> gives a result consistent with <code>compute_Mlincomb</code>. Note that <code>compute_Mlincomb</code> is in general faster since no matrix needs to be constructed.</p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; v=ones(size(nep,1)); λ=-1+1im;
julia&gt; norm(compute_Mder(nep,λ,1)*v-compute_Mlincomb(nep,λ,hcat(v,v),[0,1]))
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/95cff7631684e52a550fa93956f7c7c6e84e6712/src/NEPCore.jl#L94-L110">source</a></section><section><div><pre><code class="nohighlight hljs">compute_Mlincomb(nep::NEP,λ::Number,V,a::Array,startder::Integer)</code></pre><p>Computes linear combination starting with derivative startder, i.e., <span>$Σ_i a_i M^{(i+startder)}(λ) v_i$</span></p><p>The default implementation of this can be slow. Overload for specific NEP if you want efficiency, e.g., in  <code>augnewton</code>, <code>iar</code>, and others.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/95cff7631684e52a550fa93956f7c7c6e84e6712/src/NEPCore.jl#L147-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_MM" href="#NonlinearEigenproblems.NEPCore.compute_MM"><code>NonlinearEigenproblems.NEPCore.compute_MM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_MM(nep::NEP,S,V)</code></pre><p>Computes the sum <span>$Σ_i M_i V f_i(S)$</span> for a NEP, where <span>$S$</span> and <span>$V$</span> are matrices, and the NEP satisfies <span>$M(λ)=Σ_i M_i f_i(λ)$</span>.</p><p><strong>Example</strong></p><p>This example shows that for diagonal <code>S</code>, the result of <code>compute_MM</code> can also be computed with <code>compute_Mlincomb</code></p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; D=diagm(0 =&gt; [1,2])
2×2 Array{Int64,2}:
 1  0
 0  2
julia&gt; V=ones(size(nep,1),2);
julia&gt; W=compute_MM(nep,D,V);
julia&gt; norm(W[:,1]-compute_Mlincomb(nep,D[1,1],V[:,1]))
0.0
julia&gt; norm(W[:,2]-compute_Mlincomb(nep,D[2,2],V[:,2]))
4.440892098500626e-16</code></pre><p><strong>Reference</strong></p><p>Properties of the quantity <span>$Σ_i M_i V f_i(S)$</span> for non-polynomial nonlinear eigenvalue problems were extensively used in:</p><ul><li>D. Kressner A block Newton method for nonlinear eigenvalue problems, Numer. Math., 114 (2) (2009), pp. 355-372</li><li>C. Effenberger, Robust solution methods for nonlinear eigenvalue problems, PhD thesis, 2013, EPF Lausanne</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/95cff7631684e52a550fa93956f7c7c6e84e6712/src/NEPCore.jl#L162-L191">source</a></section></article><h2 id="Type-helpers"><a class="docs-heading-anchor" href="#Type-helpers">Type helpers</a><a id="Type-helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Type-helpers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.Mder_NEP" href="#NonlinearEigenproblems.NEPTypes.Mder_NEP"><code>NonlinearEigenproblems.NEPTypes.Mder_NEP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Mder_NEP(n,Mder_fun; maxder=max)</code></pre><p>Creates a <code>NEP</code> from its <code>compute_Mder</code> function defined by the function handle <code>Mder_fun</code>. The <code>Mder_fun(λ,der)</code> takes two parameters a scalar <code>λ::Number</code>, derivative number  <code>der</code>. The size <code>n::Int</code> must also be specified. The function <code>Mder_fun(λ,der)</code> should return the n x n matrix corresponding to the  <code>der</code>th derivatve. If only a limited number of derivatives are available, <code>maxder</code> should be set, e.g., if not derivatives are implemented, set <code>maxder=0</code>. The function <code>compute_Mlicomb</code> is automatically available by (delegation) to <code>compute_Mlincomb_from_Mder</code>.</p><p>Note: This is a convenience function it is not recommended for high performance computations, since, e.g., it will not maintain type stability.</p><p><strong>Example</strong></p><p>The following example defines a linear eigenvalue problem <code>A0+λA1</code> defined in an external function.</p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra; # For the I function
julia&gt; function my_Mder(s,der)
    A0=ones(Float64,3,3)-I; A0[1,1]=-1;
    A1=ones(Float64,3,3)*3; A1[2,3]=0;
    if (der==0)
       return A0+A1*s;
    elseif (der==1)
       return A1;
    else
       return zero(A0);
    end
end
julia&gt; nep=Mder_NEP(3,my_Mder);
julia&gt; (λ,v)=augnewton(nep,v=ones(3));
julia&gt; norm(compute_Mder(nep,λ)*v)
5.551115123125783e-17</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/95cff7631684e52a550fa93956f7c7c6e84e6712/src/nep_type_helpers.jl#L13-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.Mder_Mlincomb_NEP" href="#NonlinearEigenproblems.NEPTypes.Mder_Mlincomb_NEP"><code>NonlinearEigenproblems.NEPTypes.Mder_Mlincomb_NEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Mder_Mlincomb_NEP(n,Mder_fun, [maxder_Mder,] Mlincomb_fun, [maxder_Mlincomb])</code></pre><p>Creates a <code>NEP</code> from its <code>compute_Mder</code> and <code>compute_Mlincomb</code>functions  defined by the function handles <code>Mder_fun</code> and <code>Mlincomb_fun</code>. The <code>Mlincomb_fun(λ,X)</code> takes two parameters a scalar <code>λ::Number</code> and a matrix <code>X</code>.  The size <code>n::Int</code> must also be specified. The function <code>Mlincomb_fun(λ,X)</code> should return a vector corresponding of the linear combination of derivatives multiplied with the vectors in X. If only a limited number of derivatives are implemented, <code>maxder_Mder</code> or <code>maxder_Mlincomb</code> should be set, e.g., if not derivatives are implemented, set <code>maxder=0</code>.</p><p>See also <code>Mder_NEP</code>.</p><p>Note: This is a convenience function it is not recommended for high performance computations, since, e.g., it will not maintain type stability.</p><p><strong>Example</strong></p><p>The following example defines a linear eigenvalue problem <code>A0+λA1</code> defined in an external function.</p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra; # For the I function
julia&gt; function my_Mder(s,der)
    A0=ones(Float64,3,3)-I; A0[1,1]=-1;
    A1=ones(Float64,3,3)*3; A1[2,3]=0;
    if (der==0)
       return A0+A1*s;
    elseif (der==1)
       return A1;
    else
       return zero(A0);
    end
end
julia&gt; function my_Mlincomb(s,X) # Compute linear comb of derivatives
    A0=ones(Float64,3,3)-I; A0[1,1]=-1;
    A1=ones(Float64,3,3)*3; A1[2,3]=0;
    if (size(X,2) &lt;= 1)
       return A0*X[:,1]+s*A1*X[:,1]
    else # This means: size(X,2) =&gt; 2
       return A0*X[:,1]+A1*(s*X[:,1]+X[:,2]);
    end
end
julia&gt; nep=Mder_Mlincomb_NEP(3,my_Mder,my_Mlincomb);
julia&gt; (λ,v)=augnewton(nep,v=[1.0; 2.3; 0.0])
julia&gt; norm(compute_Mder(nep,λ)*v)
6.798699777552591e-17</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/95cff7631684e52a550fa93956f7c7c6e84e6712/src/nep_type_helpers.jl#L59-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_Mlincomb_from_Mder" href="#NonlinearEigenproblems.NEPCore.compute_Mlincomb_from_Mder"><code>NonlinearEigenproblems.NEPCore.compute_Mlincomb_from_Mder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_Mlincomb_from_Mder(nep::NEP,λ::Number,V,a)</code></pre><p>The function computes <code>Mlincomb</code> by a call to <code>compute_Mder</code>. This function is slow since it requires the construction of the matrices. Usage normally by overloading in this way</p><pre><code class="language-julia hljs">    compute_Mlincomb(nep::MyNEP,λ::Number,V,a)=compute_Mlincomb_from_Mder(nep,λ,V,a)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/95cff7631684e52a550fa93956f7c7c6e84e6712/src/NEPCore.jl#L229-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPCore.compute_Mlincomb_from_MM" href="#NonlinearEigenproblems.NEPCore.compute_Mlincomb_from_MM"><code>NonlinearEigenproblems.NEPCore.compute_Mlincomb_from_MM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_Mlincomb_from_MM(nep::NEP,λ::Number,V,a)</code></pre><p>This function provides a <code>compute_Mlincomb</code>-function call  by invoking a call to <code>compute_MM</code>. The underlying mathematical relationship  is described in github issue #2 and #3.</p><p>The standard usage is by the following command:</p><pre><code class="language-julia hljs">compute_Mlincomb(nep::MyNEP,λ::Number,V,a)=compute_Mlincomb_from_MM(nep,λ,V,a)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/95cff7631684e52a550fa93956f7c7c6e84e6712/src/NEPCore.jl#L200-L211">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types &amp; Data structures</a><a class="docs-footer-nextpage" href="../linsolvers/">Linear solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 28 June 2023 12:32">Wednesday 28 June 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
