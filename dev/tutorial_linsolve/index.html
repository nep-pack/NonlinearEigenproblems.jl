<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 11 (Linear solvers) · NEP-PACK</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NEP-PACK</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../methods/">NEP-Solvers</a></li><li><a class="tocitem" href="../types/">Types &amp; Data structures</a></li><li><a class="tocitem" href="../compute_functions/">Compute functions</a></li><li><a class="tocitem" href="../linsolvers/">Linear solvers</a></li><li><a class="tocitem" href="../innersolvers/">Projection</a></li><li><a class="tocitem" href="../errmeasure/">Measuring the error</a></li><li><a class="tocitem" href="../logger/">Logger</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../deflation/">Deflation</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="tocitem" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="tocitem" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="tocitem" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="tocitem" href="../tutorial_call_python/">Tutorial 5 (Python 1)</a></li><li><a class="tocitem" href="../tutorial_python_call/">Tutorial 6 (Python 2)</a></li><li><a class="tocitem" href="../tutorial_matlab1/">Tutorial 7 (MATLAB)</a></li><li><a class="tocitem" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="tocitem" href="../tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="tocitem" href="../tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li class="is-active"><a class="tocitem" href>Tutorial 11 (Linear solvers)</a><ul class="internal"><li><a class="tocitem" href="#Built-in-linear-solvers"><span>Built-in linear solvers</span></a></li><li><a class="tocitem" href="#Your-own-linear-solver"><span>Your own linear solver</span></a></li></ul></li><li><a class="tocitem" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Tutorial 11 (Linear solvers)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial 11 (Linear solvers)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/tutorial_linsolve.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial:-Specifying-linear-solvers"><a class="docs-heading-anchor" href="#Tutorial:-Specifying-linear-solvers">Tutorial: Specifying linear solvers</a><a id="Tutorial:-Specifying-linear-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial:-Specifying-linear-solvers" title="Permalink"></a></h1><p>Many of the NEP-solvers are based on solving linear systems of the type</p><p class="math-container">\[M(λ)x=b.\]</p><p>In some methods the linear system matrices are the same, i.e., <span>$λ$</span> does not change. You can specify which numerical methods should be used to solve the linear system when you call a NEP-solver. This tutorial illustrates this functionality, and finally shows how you can specify your own method for linear systems.</p><h2 id="Built-in-linear-solvers"><a class="docs-heading-anchor" href="#Built-in-linear-solvers">Built-in linear solvers</a><a id="Built-in-linear-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-linear-solvers" title="Permalink"></a></h2><p>The linear solver is specified with the <code>linsolvercreator</code> keyword argument in most NEP-solvers. Let us contruct an example which we will solve with several methods. The matrix <span>$M(λ)$</span> is sparse, and the nonlinearity is an exponential term:</p><pre><code class="language-julia hljs">using NonlinearEigenproblems, SparseArrays, LinearAlgebra;
n=100;
α=0.01;
A=spdiagm(0=&gt;ones(n),1=&gt;α*ones(n-1),-3=&gt;α*ones(n-3));
B=spdiagm(0=&gt;ones(n));
C=spdiagm(0=&gt;(1:n)/n);
nep= SPMF_NEP([A,B,C],[s-&gt;one(s),s-&gt;s,s-&gt;exp(s)],align_sparsity_patterns=true);
λ0=-1.3; # Starting guess</code></pre><p>Let us first solve it with the  <a href="../methods/#NonlinearEigenproblems.NEPSolver.resinv"><code>resinv</code></a> method, using the default solver for the linear system:</p><pre><code class="language-julia-repl hljs">julia&gt; (λ,x)=resinv(nep,λ=λ0,v=ones(n),logger=1,tol=1e-16);
Precomputing linsolver
iter 1 err:0.0066371687626530325 λ=-1.3 + 0.0im
iter 2 err:0.005517924619612248 λ=-1.175478914232863 + 0.0im
iter 3 err:0.002478390282482615 λ=-1.237914206446667 + 0.0im
iter 4 err:0.0007175125397164684 λ=-1.2715354474842264 + 0.0im
...
iter 68 err:1.9815836266850424e-16 λ=-1.2845622481786096 + 0.0im
iter 69 err:1.2398848173585647e-16 λ=-1.28456224817861 + 0.0im
iter 70 err:8.341032972349128e-17 λ=-1.2845622481786103 + 0.0im
</code></pre><p>We will carry out some timing experiments, so let&#39;s use the <a href="https://github.com/JuliaCI/BenchmarkTools.jl"><code>BenchmarkTools</code></a>-package and switch off printouts in the NEP-solver:</p><pre><code class="language-julia-repl hljs">julia&gt; using BenchmarkTools
julia&gt; @btime (λ,x)=resinv(nep,λ=λ0,v=ones(n),tol=1e-16);
  8.170 ms (32457 allocations: 10.99 MiB)</code></pre><p>The linear system that has to be solved in every iteration in <code>resinv</code> has a constant system matrix, and therefore a prefactorization (typically an LU-factorization) is useful. This is done with the <a href="../linsolvers/#NonlinearEigenproblems.LinSolvers.FactorizeLinSolverCreator"><code>FactorizeLinSolverCreator</code></a>, which is actually the default behaviour, so we get no substantial difference when we specify a creator if the type <code>FactorizeLinSolverCreator</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; creator=FactorizeLinSolverCreator();
julia&gt; @btime (λ,x)=resinv(nep,λ=λ0,v=ones(n),maxit=100,linsolvercreator=creator,tol=1e-16);
  8.104 ms (32447 allocations: 10.98 MiB)</code></pre><p>If we do not want to use a prefactorization, you can specify <a href="../linsolvers/#NonlinearEigenproblems.LinSolvers.BackslashLinSolverCreator"><code>BackslashLinSolverCreator</code></a> as your creator object.</p><pre><code class="language-julia-repl hljs">julia&gt; creator=BackslashLinSolverCreator();
julia&gt; @btime (λ,x)=resinv(nep,λ=λ0,v=ones(n),maxit=100,linsolvercreator=creator,tol=1e-16);
  19.985 ms (36932 allocations: 22.31 MiB)</code></pre><p>This does not use a prefactorization and is therefore slower.</p><p>The above approach corresponded to direct methods for linear systems. You can also use iterative methods, e.g., the GMRES-method. The GMRES-method is available in the <a href="../linsolvers/#NonlinearEigenproblems.LinSolvers.GMRESLinSolverCreator"><code>GMRESLinSolverCreator</code></a> function. Iterative methods in general need <a href="https://en.wikipedia.org/wiki/Preconditioner">preconditioners</a>. We continue the example and use a diagonal preconditioner:</p><pre><code class="language-julia-repl hljs">julia&gt; D0=(Diagonal(compute_Mder(nep,λ0))); # Preconditioner
julia&gt; creator=GMRESLinSolverCreator(Pl=D0, tol=1e-2);</code></pre><p>All the keyword arguments in the call <code>GMRESLinSolverCreator</code> are passed to <a href="https://juliamath.github.io/IterativeSolvers.jl/stable/linear_systems/gmres/"><code>gmres!</code></a>. Hence, the <code>tol</code> here  specifies a termination criteria for the GMRES-method, and <code>Pl</code> specifies the left preconditioner, in this case just a diagonal matrix.</p><pre><code class="language-julia-repl hljs">julia&gt; (λ,x)=resinv(nep,λ=λ0,v=ones(n),maxit=100,linsolvercreator=creator,logger=1,tol=1e-16);
Precomputing linsolver
iter 1 err:0.0066371687626530325 λ=-1.3 + 0.0im
iter 2 err:0.005516840431746622 λ=-1.175478914232863 + 0.0im
iter 3 err:0.002478456565315529 λ=-1.2379013065364441 + 0.0im
iter 4 err:0.0007137260829914206 λ=-1.271604846382212 + 0.0im
...
iter 69 err:1.4948517196633335e-16 λ=-1.2845622481786099 + 0.0im
iter 70 err:1.0136830543996086e-16 λ=-1.28456224817861 + 0.0im
iter 71 err:6.468407765141646e-17 λ=-1.2845622481786103 + 0.0im
</code></pre><p>The printout reveals that we need one more more iteration, than with a direct method. In terms of computation time, this approach can however still be competitive:</p><pre><code class="language-julia-repl hljs">julia&gt; @btime (λ,x)=resinv(nep,λ=λ0,v=ones(n),maxit=100,linsolvercreator=creator,tol=1e-16);
  10.912 ms (49183 allocations: 18.95 MiB)</code></pre><h2 id="Your-own-linear-solver"><a class="docs-heading-anchor" href="#Your-own-linear-solver">Your own linear solver</a><a id="Your-own-linear-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Your-own-linear-solver" title="Permalink"></a></h2><p>There are many ways to solve linear systems in Julia, e.g., by using package such as <a href="https://github.com/Jutho/KrylovKit.jl">KrylovKit.jl</a>, <a href="https://github.com/JuliaSparse/Pardiso.jl">Pardiso.jl</a> or <a href="https://github.com/JuliaInv/KrylovMethods.jl">KrylovMethods.jl</a>. These are not natively supported by NEP-PACK, but due to the extendability of the <code>LinSolverCreator</code>-objects specified above, you can still use them. We illustrate the extendability by creating a linear solver based on solving a <a href="https://en.wikipedia.org/wiki/Schur_complement">Schur complement</a>. The following helper-function for the Schur complement solve will be used later.</p><pre><code class="language-julia hljs">function schur_complement_lin_solve(AA,b,n0)
  A=AA[1:n0,1:n0];
  B=AA[1:n0,(n0+1):end];
  C=AA[(n0+1):end,1:n0];
  D=AA[(n0+1):end,(n0+1):end];
  S=D-C*(A\B); # Schur complement
  b1=b[1:n0]; b2=b[(n0+1):end];
  Ainvb1=A\b1; Sinvb2=S\b2;
  # Formula for the linear solve:
  x1=A\(b1+(B*(S\(C*(Ainvb1)))))-A\(B*(Sinvb2))
  x2=-S\(C*(Ainvb1))+Sinvb2;
  return [x1;x2];
end</code></pre><p>Julia&#39;s efficiency stems partially from the extensive use of types. We need to define new types to specify our own linear solver and integrate it with NEP-PACK.</p><pre><code class="language-julia hljs">struct MyLinSolverCreator &lt;: LinSolverCreator; end
struct MyLinSolver &lt;: LinSolver;
  mynep
  myλ
end</code></pre><p>NEP-solvers call the function <a href="../linsolvers/#NonlinearEigenproblems.LinSolvers.create_linsolver"><code>create_linsolver</code></a>(creator,nep,λ), which should return a linear solver. We need to overload this function for our own creator-type. In general, this is to allow precomputation. However, in this example we do not have any precomputations and thus just return an instance of <code>MyLinSolver</code>.</p><pre><code class="language-julia hljs">import NonlinearEigenproblems.create_linsolver # Needed since we want overload it
function create_linsolver(::MyLinSolverCreator,nep,λ)
   return MyLinSolver(nep,λ);
end</code></pre><p>The rest of the implementation of the solver goes into the function <code>lin_solve</code>, where we utilize our function <code>schur_complement_lin_solve</code> from above.</p><pre><code class="language-julia hljs">import NonlinearEigenproblems.LinSolvers.lin_solve # Needed since we want overload it
function lin_solve(solver::MyLinSolver,b::Vector;tol=eps())
   n0=10;
   return schur_complement_lin_solve(compute_Mder(solver.mynep,solver.myλ),b,n0)
end</code></pre><p>You can now solve the problem by passing a creator object <code>MyLinSolverCreator()</code> to a NEP-solver, e.g., <a href="../methods/#NonlinearEigenproblems.NEPSolver.augnewton"><code>augnewton</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; dep=nep_gallery(&quot;dep0&quot;,50);
julia&gt; creator=MyLinSolverCreator();
julia&gt; augnewton(dep,λ=1,v=ones(size(dep,1)),logger=1,linsolvercreator=creator);
iter 1 err:0.10615052208736536 λ=1.0 + 0.0im
iter 2 err:0.04682362994161844 λ=3.004830719411172 + 0.0im
iter 3 err:0.08148964717804698 λ=0.213140384062811 + 0.0im
iter 4 err:0.03955381142282053 λ=0.47667949368248896 + 0.0im
iter 5 err:0.06584371583464586 λ=2.985447356041631 + 0.0im
iter 6 err:0.02262384918568079 λ=3.722422057973499 + 0.0im
iter 7 err:0.0036373167693678717 λ=3.389502913018821 + 0.0im
iter 8 err:0.00704620404184537 λ=3.2745554693864496 + 0.0im
iter 9 err:0.0009450496517445758 λ=3.1652287152386758 + 0.0im
iter 10 err:2.138372017573122e-5 λ=3.187725547526568 + 0.0im
iter 11 err:1.0100960591678548e-8 λ=3.188230946035159 + 0.0im
iter 12 err:2.801564990446382e-15 λ=3.1882313460682705 + 0.0im</code></pre><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_LINSOLVE" alt="To the top"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial_newmethod/">« Tutorial 10 (New solver)</a><a class="docs-footer-nextpage" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 4 July 2022 15:34">Monday 4 July 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
