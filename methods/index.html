<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>NEP Methods · NEP-PACK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NEP-PACK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>NEP Methods</a><ul class="internal"><li><a class="toctext" href="#Newton-type-methods-1">Newton type methods</a></li><li><a class="toctext" href="#Projection-methods-1">Projection methods</a></li><li><a class="toctext" href="#Arnoldi-and-Krylov-based-methods-1">Arnoldi and Krylov based methods</a></li><li><a class="toctext" href="#Class-specific-methods-1">Class specific methods</a></li></ul></li><li><a class="toctext" href="../types/">NEP Types</a></li><li><a class="toctext" href="../linsolvers/">LinSolver</a></li><li><a class="toctext" href="../transformations/">NEP Transformations</a></li><li><a class="toctext" href="../gallery/">NEP Gallery</a></li><li><a class="toctext" href="../bemtutorial/">Tutorial 1 (BEM)</a></li><li><a class="toctext" href="../movebc_tutorial/">Tutorial 2 (ABC)</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>NEP Methods</a></li></ul><a class="edit-page" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/methods.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>NEP Methods</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="NEP-Methods-1" href="#NEP-Methods-1">NEP Methods</a></h1><p>The NEP solver methods implemented in NEP-PACK, are accessed by the functions below. The functions all return <span>$λ,v,w$</span> where <span>$λ$</span> is either a number (eigenvalue) a vector of eigenvalues <span>$v$</span> is either a vector containing an eigenvector or a matrix whose columns corresponding to the eigenvectors.</p><p>The first parameter optional parameter in all NEP solver methods is a type. This type specifies which arithmetic should be used for the algorithm.</p><p>Example:</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;)
julia&gt; λ,v=augnewton(Complex128,nep,v=ones(5))
(0.8347353572199425 + 0.0im, Complex{Float64}[0.480386+0.0im, 0.0631636+0.0im, -0.136405+0.0im, 0.214274+0.0im, 0.378581+0.0im])
julia&gt; typeof(λ)
Complex{Float64}
julia&gt; λ,v=augnewton(Float16,nep,v=ones(5))
(Float16(0.8223), Float16[0.47388, 0.063904, -0.13843, 0.21692, 0.38306])
julia&gt; typeof(λ)
Float16</code></pre><h2><a class="nav-anchor" id="Newton-type-methods-1" href="#Newton-type-methods-1">Newton type methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.newton" href="#NonlinearEigenproblems.NEPSolver.newton"><code>NonlinearEigenproblems.NEPSolver.newton</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">λ,v = newton([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max])</code></pre><p>Applies Newton-Raphsons method on the system of nonlinear equations with <code>n+1</code> unknowns:</p><div>\[M(λ)v=0\]</div><div>\[c^Hv-1=0\]</div><p>The kwarg <code>errmeasure</code> is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). The iteration is continued until <code>errmeasure</code> is less than <code>tol</code>. <code>λ</code> and <code>v</code> are starting approximations. <code>c</code> is the orthogonalization vector.  If <code>c=0</code> the current approximation will be used for the orthogonalization. <code>armijo_factor</code> specifies if an Armijo rule should be applied, and its value specifies the scaling factor of the step length (per reduction step). The variable <code>armijo_max</code> specifies the maximum number of step length reductions.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; λ,v=newton(nep);
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
1.6066157878930876e-16</code></pre><p><strong>References</strong></p><ul><li>Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.</li><li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_newton.jl#L17-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.augnewton" href="#NonlinearEigenproblems.NEPSolver.augnewton"><code>NonlinearEigenproblems.NEPSolver.augnewton</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">augnewton([eltype], nep::NEP; [errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel,][linsolvercreator,][armijo_factor,][armijo_max])</code></pre><p>Run the augmented Newton method. The method is equivalent to <code>newton()</code> in exact arithmetic,  but works only with operations on vectors of length <code>n</code>. The <code>linsolvecreator</code> is used to initiate linear solvers. See <code>newton()</code> for other parameters.</p><p><strong>Example</strong></p><p>This illustrates the equivalence between <code>newton</code> and <code>augnewton</code>.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep1&quot;)
julia&gt; λ1,v1=newton(nep,maxit=20,v=ones(size(nep,1)),λ=0)
julia&gt; λ2,v2=augnewton(nep,maxit=20,v=ones(size(nep,1)),λ=0)
julia&gt; λ1-λ2
0.0 + 0.0im</code></pre><p><strong>References</strong></p><ul><li>Nichtlineare Behandlung von Eigenwertaufgaben, Z. Angew. Math. Mech. 30 (1950) 281-282.</li><li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_newton.jl#L258-L278">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.resinv" href="#NonlinearEigenproblems.NEPSolver.resinv"><code>NonlinearEigenproblems.NEPSolver.resinv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">λ,v = resinv([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel,][armijo_factor=1,][armijo_max,][linsolvecreator])</code></pre><p>Applies residual inverse iteration method for nonlinear eigenvalue problems. The kwarg <code>linsolvecreator</code> is a function which specifies how the linear system is created. The function calls <code>compute_rf</code> for the computation of the Rayleigh functional. See <code>newton()</code> for other parameters.</p><p><strong>Example</strong></p><p>The example shows how to specify if the method should run in real or complex mode (or any other <code>Number</code> type).</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;qdep0&quot;);
julia&gt; λ,v=resinv(nep,λ=-2,v=ones(size(nep,1)))
julia&gt; typeof(λ)
Complex{Float64}
julia&gt; norm(compute_Mlincomb(nep,λ,v))
1.817030659827106e-14
julia&gt; λ,v=resinv(Float64,nep,λ=-2,v=ones(size(nep,1)))
julia&gt; typeof(λ)
Float64
julia&gt; norm(compute_Mlincomb(nep,λ,v))
1.817030659827106e-14</code></pre><p><strong>References</strong></p><ul><li>A. Neumaier, Residual inverse iteration for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 22 (1985) 914-923</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_newton.jl#L125-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.quasinewton" href="#NonlinearEigenproblems.NEPSolver.quasinewton"><code>NonlinearEigenproblems.NEPSolver.quasinewton</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">quasinewton([T=ComplexF64],nep,[errmeasure,][tol,][maxit,][λ,][v][ws][displaylevel][linsolvercreator,][armijo_factor,][armijo_max])</code></pre><p>An implementation of the quasi-Newton approach referred to as quasi-Newton 2 in the reference. The method involves one linear system solve per iteration corresponding with the matrix <span>$M(λ)$</span>, where <span>$λ$</span> is constant. The vector <code>ws</code> is a representation of the normalization, in the sense that <span>$c^T=w_s^TM(λ)$</span>, where all iterates satisfy <span>$c^Tx_i=1$</span>. See <code>newton()</code> for other parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; λ,v=quasinewton(nep,v=ones(size(nep,1)));
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v)
6.301479387102376e-15</code></pre><p><strong>References</strong></p><ul><li>Jarlebring, Koskela, Mele, Disguised and new Quasi-Newton methods for nonlinear eigenvalue problems, Numer. Algorithms, 79:311-335, 2018. <a href="https://arxiv.org/abs/1702.08492">preprint</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_newton.jl#L364-L383">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.mslp" href="#NonlinearEigenproblems.NEPSolver.mslp"><code>NonlinearEigenproblems.NEPSolver.mslp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none"> mslp([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][displaylevel,][eigsolvertype::Type][armijo_factor=1,][armijo_max])</code></pre><p>Runs the method of successive linear problems. The  method requires the solution of a generalized eigenvalue problem in every iteration. The method used for the eigenvalue computation is specified in eigsolvertype. See <code>newton</code> for other parameters.</p><p><strong>Example</strong></p><p>Create a rational NEP with SPMFs.</p><pre><code class="language-julia-repl">julia&gt; Av=[ones(3,3),eye(3,3),triu(ones(3,3))];
julia&gt; fv=[S-&gt; S, S -&gt; S^2, S::AbstractArray -&gt; inv(Matrix(S)-eye(S)*10)]
julia&gt; nep=SPMF_NEP(Av,fv)
julia&gt; (λ,v)=mslp(nep)
julia&gt; compute_Mlincomb(nep,λ,v)
3-element Array{Complex{Float64},1}:
 -1.38778e-17+1.65715e-18im
 -5.55112e-17+1.30633e-17im
 -4.16334e-17-1.54436e-17im</code></pre><p><strong>References</strong></p><ul><li>A. Ruhe, Algorithms for the nonlinear eigenvalue problem, SIAM J. Numer. Anal. 10 (1973) 674-689</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_mslp.jl#L7-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.rfi" href="#NonlinearEigenproblems.NEPSolver.rfi"><code>NonlinearEigenproblems.NEPSolver.rfi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rfi(nep,nept,[λ=0,][errmeasure=default_errmeasure,][tol=eps()*100,][maxit=100,][v=randn,][u=randn,][displaylevel=0,][linsolvecreator=default_linsolvecreator,])</code></pre><p>This is an implementation of the two-sided Rayleigh functional Iteration (RFI) to compute an eigentriplet of the problem specified by <code>nep</code>. This method requires the transpose of the NEP, specified in <code>nept</code>. <code>λ</code>, <code>u</code> and <code>v</code> are initial guesses for the eigenvalue, the right eigenvector and the left eigenvector respectively. A <code>NoConvergenceException</code> is thrown if an eigentriplet is not found in <code>maxit</code> iterations.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; nept=DEP([nep.A[1]&#39;,nep.A[2]&#39;])
julia&gt; λ,v,u=rfi_b(nep,nept)
julia&gt; compute_resnorm(nep,λ,v) % v is a right eigenvector
4.347204570675246e-16
julia&gt; compute_resnorm(nept,λ,u) % u is a left eigenvector
7.173081573164097e-16</code></pre><p><strong>Reference</strong></p><ul><li>Algorithm 4 in  Schreiber, Nonlinear Eigenvalue Problems: Newton-type Methods and Nonlinear Rayleigh Functionals, PhD thesis, TU Berlin, 2008.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_rfi.jl#L7-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.blocknewton" href="#NonlinearEigenproblems.NEPSolver.blocknewton"><code>NonlinearEigenproblems.NEPSolver.blocknewton</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(S,X)=blocknewton(nep [S,] [X,] [errmeasure,] [tol,] [maxit,] [armijo_factor,] [armijo_max,] [displaylevel])</code></pre><p>Applies the block Newton method to <code>nep::AbstractSPMF</code>. The method computes an invariant pair <code>(S,X)</code> using the block Newton approach of Kressner. The variables <code>S</code>,<code>X</code> correspond to starting approximations. The function <code>errmeasure</code> shoule be defined for errmeasure(S,X) and meausures the error in the pair <code>(S,X)</code>. See <code>newton()</code> for the other parameters.</p><p><strong>Example</strong></p><p>The example shows that <code>compute_MM()</code> becomes zero when a solution has been computed.</p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;,3);
julia&gt; (S,X)= blocknewton(nep)
julia&gt; compute_MM(nep,S,X)
3×2 Array{Complex{Float64},2}:
 -2.22045e-16-1.0842e-19im  -2.08167e-17+0.0im
  1.94289e-16-1.0842e-19im  -5.55112e-17-6.77626e-20im
  7.63278e-17-1.0842e-19im   2.77556e-17-2.71051e-20im</code></pre><p>This example solves the <code>gun</code> problem from the Berlin-Manchester collection</p><pre><code class="language-julia-repl">julia&gt; using NonlinearEigenproblems.Gallery
julia&gt; nep=nep_gallery(&quot;nlevp_native_gun&quot;);
julia&gt; II=[1.0 0; 0 1]; S=150^2*II; V=[II;zeros(size(nep,1)-2,2)];
julia&gt; (Z,X)=blocknewton(nep,S=S,X=V,displaylevel=1,armijo_factor=0.5,maxit=20)
Iteration 1: Error: 6.081316e+03
Iteration 2: Error: 1.701970e-02 Armijo scaling=0.031250
Iteration 3: Error: 1.814887e-02 Armijo scaling=0.250000
...
Iteration 13: Error: 6.257442e-09
Iteration 14: Error: 2.525942e-15</code></pre><p><strong>References</strong></p><ul><li>D. Kressner A block Newton method for nonlinear eigenvalue problems, Numer. Math., 114 (2) (2009), pp. 355-372</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_blocknewton.jl#L7-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.newtonqr" href="#NonlinearEigenproblems.NEPSolver.newtonqr"><code>NonlinearEigenproblems.NEPSolver.newtonqr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">λ,v = newtonqr([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel])</code></pre><p>This function implements the Newton-QR method as formulated in the reference. The method ivolves the computation of a rank-revealing QR factorization of <span>$M(λ)$</span>, with the idea that on convergence the the last diagonal element <span>$R[n,n]$</span> of the upper-triangular matrix <span>$R$</span> becomes zero as a result of <span>$M(λ)$</span> becoming singular. Since the computation of a QR factorization is expensive, it is advisable to use this method for problems of small size or problems with a certain structure that makes the QR computation less expensive. See <a href="#NonlinearEigenproblems.NEPSolver.newton"><code>newton</code></a> for description of the function arguements.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; λ,v=newtonqr(nep,v=ones(size(nep,1)));
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v)
1.0442559980785471e-14</code></pre><p><strong>References</strong></p><ul><li>Kublanovskaya, V. N., (1970).  On an approach to the solution of the generalized latent value problem for λ-matrices, SIAM J. Numer. Anal. 7, 532–537</li><li>Güttel, S., &amp; Tisseur, F. (2017). The nonlinear eigenvalue problem. Acta Numerica, 26, 1-94. doi:10.1017/S0962492917000034</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_newton.jl#L470-L489">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.implicitdet" href="#NonlinearEigenproblems.NEPSolver.implicitdet"><code>NonlinearEigenproblems.NEPSolver.implicitdet</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">λ,v = implicitdet([eltype],nep::NEP;[errmeasure,][tol,][maxit,][λ,][v,][c,][displaylevel])</code></pre><p>This function implements the Implicit determinant method as formulated Algorithm 4.3 in the reference. The method applies Newton-Raphson to the equation <span>$det(M(λ))/det(G(λ)) = 0$</span>, where <span>$G(λ)$</span> is a saddle point matrix with <span>$M(λ)$</span> in the (1,1) block. The (2,1) and (1,2) blocks of <span>$G(λ)$</span> are set to <span>$c^H$</span> and <span>$c$</span> respectively. Note that <span>$G(λ)$</span> can be non-singular even when <span>$M(λ)$</span> is singular. See reference for more information. See <a href="#NonlinearEigenproblems.NEPSolver.newton"><code>newton</code></a> for description of the function arguements.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;pep0&quot;)
julia&gt; λ,v=implicitdet(nep,v=ones(size(nep,1)));
julia&gt; norm(compute_Mlincomb(nep,λ,v))/norm(v)
3.75723275262885e-14</code></pre><p><strong>References</strong></p><ul><li>Spence, A., &amp; Poulton, C. (2005). Photonic band structure calculations using nonlinear eigenvalue techniques, J. Comput. Phys., 204 (2005), pp. 65–8</li><li>Güttel, S., &amp; Tisseur, F. (2017). The nonlinear eigenvalue problem. Acta Numerica, 26, 1-94. doi:10.1017/S0962492917000034</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_newton.jl#L556-L576">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.broyden" href="#NonlinearEigenproblems.NEPSolver.broyden"><code>NonlinearEigenproblems.NEPSolver.broyden</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">S,V = broyden([eltype,]nep::NEP[,approxnep::NEP];kwargs)</code></pre><p>Runs Broydens method (with deflation) for the nonlinear eigenvalue problem defined by nep. An approximate nep can be provided which is used as an initialization of starting matrix/vectors.</p><p>The method computes an invariant pair and can therefore find several eigenvalues. The retured value is (S,V) is an invariant pair and the eigenvalues are on the diagonal of S.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; S,V=broyden(nep);
julia&gt; λ=S[1,1]
-0.3587189459686267 - 3.0010731412746105e-31im
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
1.6066157878930856e-16
julia&gt; λ=S[2,2]
-0.04093521177097334 + 1.486011530941621im
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
4.159109513753696e-16
julia&gt; λ=S[3,3]
0.8347353572199486 + 1.5032076225139986e-14im
julia&gt; minimum(svdvals(compute_Mder(nep,λ)))
1.296144276122994e-14
julia&gt; broyden(nep,displaylevel=2,check_error_every=1);  % Prints out a lot more convergence info</code></pre><p><strong>References</strong></p><ul><li>Jarlebring, Broyden’s method for nonlinear eigenproblems, 2018, https://arxiv.org/pdf/1802.07322</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_broyden.jl#L520-L554">source</a></section><h2><a class="nav-anchor" id="Projection-methods-1" href="#Projection-methods-1">Projection methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.nlar" href="#NonlinearEigenproblems.NEPSolver.nlar"><code>NonlinearEigenproblems.NEPSolver.nlar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function nlar([eltype],nep::ProjectableNEP,[orthmethod=ModifiedGramSchmidt],[neigs=10],[errmeasure=default_errmeasure],[tol=eps(real(T))*100],[maxit=100],[λ0=0],[v0=randn(T,size(nep,1))],[displaylevel=0],[linsolvercreator=default_linsolvercreator],[R=0.01],[eigval_sorter=residual_eigval_sorter],[qrfact_orth=false],[max_subspace=100],[num_restart_ritz_vecs=8],[inner_solver_method=DefaultInnerSolver])</code></pre><p>The function implements the Nonlinear Arnoldi method, which finds <code>neigs</code> eigenpairs(or throws a <code>NoConvergenceException</code>) by projecting the problem to a subspace that is expanded in the course  of the algorithm. The basis is orthogonalized either by using the QR method if <code>qrfact_orth</code> is <code>true</code> or else by an orthogonalization method <code>orthmethod</code>). This entails solving a smaller projected problem using a method specified by <code>inner_solver_method</code>. (<code>λ0</code>,<code>v0</code>) is the initial guess for the eigenpair. <code>linsolvercreator</code> specifies how the linear system is created and solved. <code>R</code> is a parameter used by the function specified by <code>eigval_sorter</code> to reject those ritz values that are within a distance <code>R</code> from any of the converged eigenvalues, so that repeated convergence to the same eigenpair can be avoided. <code>max_subspace</code> is the maximum allowable size of the basis befor the algorithm restarts using a basis made of <code>num_restart_ritz_vecs</code> ritz vectors and the eigenvectors that the algorithm has converged to.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0_tridiag&quot;);
julia&gt; λ,v=nlar(nep,tol=1e-5,neigs=1,maxit=50);
julia&gt; norm(compute_Mlincomb(nep,λ[1],v))
7.722757003764154e-7</code></pre><p><strong>References</strong></p><ul><li>H. Voss, An Arnoldi method for nonlinear eigenvalue problems. BIT. Numer. Math. 44: 387-401, 2004.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_nlar.jl#L12-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.jd_betcke" href="#NonlinearEigenproblems.NEPSolver.jd_betcke"><code>NonlinearEigenproblems.NEPSolver.jd_betcke</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">jd_betcke([eltype]], nep::ProjectableNEP; [Neig=1], [tol=eps(real(T))*100], [maxit=100], [λ=zero(T)], [orthmethod=DGKS],  [errmeasure=default_errmeasure], [linsolvercreator=default_linsolvercreator], [v = randn(size(nep,1))], [displaylevel=0], [inner_solver_method=DefaultInnerSolver], [projtype=:PetrovGalerkin], [target=zero(T)])</code></pre><p>The function computes eigenvalues using Jacobi-Davidson method, which is a projection method. The projected problems are solved using a solver spcified through the type <code>inner_solver_method</code>. For numerical stability the basis is kept orthogonal, and the method for orthogonalization is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The function tries to compute <code>Neig</code> number of eigenvalues, and throws a <code>NoConvergenceException</code> if it cannot. The value <code>λ</code> and the vector <code>v</code> are initial guesses for an eigenpair. <code>linsolvercreator</code> is a function which specifies how the linear system is created and solved. The <code>target</code> is the center around which eiganvlues are computed. <code>errmeasure</code> is a function handle which can be used to specify how the error is measured. By default the method uses a Petrov-Galerkin framework, with a trial (left) and test (right) space, hence <span>$W^H T(λ) V$</span> is the projection considered. By specifying  <code>projtype</code> to be <code>:Galerkin</code> then <code>W=V</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;,50);
julia&gt; λ,v=jd_betcke(nep,tol=1e-5,maxit=20);
julia&gt; norm(compute_Mlincomb(nep,λ[1],v[:,1]))
1.2277391762692744e-8</code></pre><p><strong>References</strong></p><ul><li>T. Betcke and H. Voss, A Jacobi-Davidson-type projection method for nonlinear eigenvalue problems. Future Gener. Comput. Syst. 20, 3 (2004), pp. 363-372.</li><li>H. Voss, A Jacobi–Davidson method for nonlinear eigenproblems. In: International Conference on Computational Science. Springer, Berlin, Heidelberg, 2004. pp. 34-41.</li></ul><p>See also</p><ul><li>C. Effenberger, Robust successive computation of eigenpairs for nonlinear eigenvalue problems. SIAM J. Matrix Anal. Appl. 34, 3 (2013), pp. 1231-1256.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_jd.jl#L27-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.jd_effenberger" href="#NonlinearEigenproblems.NEPSolver.jd_effenberger"><code>NonlinearEigenproblems.NEPSolver.jd_effenberger</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">jd_effenberger([eltype]], nep::ProjectableNEP; [maxit=100], [Neig=1], [inner_solver_method=DefaultInnerSolver], [orthmethod=DGKS], [linsolvercreator=default_linsolvercreator], [tol=eps(real(T))*100], [λ=zero(T)], [v = rand(T,size(nep,1))], [target=zero(T)],  [displaylevel=0])</code></pre><p>The function computes eigenvalues using the Jacobi-Davidson method, which is a projection method. Repreated eigenvalues are avoided by using deflation, as presented in the reference by Effenberger. The projected problems are solved using a solver spcified through the type <code>inner_solver_method</code>. For numerical stability the basis is kept orthogonal, and the method for orthogonalization is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The function tries to compute <code>Neig</code> number of eigenvalues, and throws a <code>NoConvergenceException</code> if it cannot. The value <code>λ</code> and the vector <code>v</code> are initial guesses for an eigenpair. <code>linsolvercreator</code> is a function which specifies how the linear system is created and solved. The <code>target</code> is the center around which eiganvalues are computed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; λ,v=jd_effenberger(nep,maxit=30,v=ones(size(nep,1)),λ=0);
julia&gt; norm(compute_Mlincomb(nep,λ[1],v[:,1]))
1.902783771915309e-14</code></pre><p><strong>References</strong></p><ul><li>C. Effenberger, Robust successive computation of eigenpairs for nonlinear eigenvalue problems. SIAM J. Matrix Anal. Appl. 34, 3 (2013), pp. 1231-1256.</li></ul><p>See also</p><ul><li>T. Betcke and H. Voss, A Jacobi-Davidson-type projection method for nonlinear eigenvalue problems. Future Gener. Comput. Syst. 20, 3 (2004), pp. 363-372.</li><li>H. Voss, A Jacobi–Davidson method for nonlinear eigenproblems. In: International Conference on Computational Science. Springer, Berlin, Heidelberg, 2004. pp. 34-41.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_jd.jl#L181-L204">source</a></section><h2><a class="nav-anchor" id="Arnoldi-and-Krylov-based-methods-1" href="#Arnoldi-and-Krylov-based-methods-1">Arnoldi and Krylov based methods</a></h2><h3><a class="nav-anchor" id="IAR-1" href="#IAR-1">IAR</a></h3><p>The Infinite ARnoldi method.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.iar" href="#NonlinearEigenproblems.NEPSolver.iar"><code>NonlinearEigenproblems.NEPSolver.iar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">iar(nep,[maxit=30,][σ=0,][γ=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])</code></pre><p>Run the infinite Arnoldi method on the nonlinear eigenvalue problem stored in <code>nep</code>.</p><p>The target <code>σ</code> is the center around which eiganvalues are computed. The kwarg <code>errmeasure</code> is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). A Ritz pair <code>λ</code> and <code>v</code> is flagged a as converged (to an eigenpair) if <code>errmeasure</code> is less than <code>tol</code>. The vector <code>v</code> is the starting vector for constructing the Krylov space. The orthogonalization method, used in contructing the orthogonal basis of the Krylov space, is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The iteration is continued until <code>Neig</code> Ritz pairs converge. This function throws a <code>NoConvergenceException</code> if the wanted eigenpairs are not computed after <code>maxit</code> iterations. The <code>linsolvercreator</code> is a function which specifies how the linear system is created and solved.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using NonlinearEigenproblems, LinearAlgebra
julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; v0=ones(size(nep,1));
julia&gt; λ,v=iar(nep;v=v0,tol=1e-5,Neig=3);
julia&gt; norm(compute_Mlincomb!(nep,λ[1],v[:,1])) # Is it an eigenvalue?
julia&gt; λ    # print the computed eigenvalues
3-element Array{Complex{Float64},1}:
 -0.15606211475666945 - 0.12273439802763578im
 -0.15606211475666862 + 0.12273439802763489im
  0.23169243065648365 - 9.464790582509696e-17im</code></pre><p><strong>References</strong></p><ul><li>Algorithm 2 in Jarlebring, Michiels Meerbergen, A linear eigenvalue algorithm for the nonlinear eigenvalue problem, Numer. Math, 2012</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_iar.jl#L8-L34">source</a></section><h3><a class="nav-anchor" id="IAR-Chebyshev-1" href="#IAR-Chebyshev-1">IAR Chebyshev</a></h3><p>A Chebyshev version of the IAR method.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.iar_chebyshev" href="#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>NonlinearEigenproblems.NEPSolver.iar_chebyshev</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">iar_chebyshev(nep,[maxit=30,][σ=0,][γ=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS][a=-1,][b=1,][compute_y0_method=ComputeY0ChebAuto])</code></pre><p>Run the infinite Arnoldi method (Chebyshev version) on the nonlinear eigenvalue problem stored in <code>nep</code>.</p><p>The target <code>σ</code> is the center around which eiganvalues are computed. The kwarg <code>errmeasure</code> is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). A Ritz pair <code>λ</code> and <code>v</code> is flagged a as converged (to an eigenpair) if <code>errmeasure</code> is less than <code>tol</code>. The vector <code>v</code> is the starting vector for constructing the Krylov space. The orthogonalization method, used in contructing the orthogonal basis of the Krylov space, is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The iteration is continued until <code>Neig</code> Ritz pairs converge. This function throws a <code>NoConvergenceException</code> if the wanted eigenpairs are not computed after <code>maxit</code> iterations. The <code>linsolvercreator</code> is a function which specifies how the linear system is created and solved. The kwarg <code>compute_y0_method</code> specifying how the next vector of the Krylov space (in Chebyshev format) can be computed. See <a href="#NonlinearEigenproblems.NEPSolver.compute_y0_cheb"><code>compute_y0_cheb</code></a> in the module NEPSolver with the command <code>?NEPSolver.compute_y0_cheb</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using NonlinearEigenproblems, LinearAlgebra
julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; v0=ones(size(nep,1));
julia&gt; λ,v=iar_chebyshev(nep;v=v0,tol=1e-5,Neig=3);
julia&gt; norm(compute_Mlincomb!(nep,λ[1],v[:,1])) # Is it an eigenvalue?
julia&gt; λ    # print the computed eigenvalues
3-element Array{Complex{Float64},1}:
  -0.1560621117389876 - 0.12273439561483537im
 -0.15606211173898707 + 0.12273439561483517im
  0.23169252042880578 - 7.86196165647416e-17im</code></pre><p><strong>References</strong></p><ul><li>Algorithm 2 in Jarlebring, Michiels Meerbergen, A linear eigenvalue algorithm for the nonlinear eigenvalue problem, Numer. Math, 2012</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_iar_chebyshev.jl#L33-L59">source</a></section><p>For the <code>iar_chebyshev</code> the following <code>compute_y0_cheb</code> method is needed, in order to avoid explicit conversions between the Chebyshev basis and the monimial basis.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.compute_y0_cheb" href="#NonlinearEigenproblems.NEPSolver.compute_y0_cheb"><code>NonlinearEigenproblems.NEPSolver.compute_y0_cheb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">y0 = compute_y0_cheb([eltype],nep::NEPTypes.DEP,::Type{ComputeY0ChebPEP},X,Y,M0inv,precomp::AbstractPrecomputeData)</code></pre><p>Computes the vector y0 used in <a href="#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> given by</p><div>\[ y_0 = \sum_{i=1}^N T_{i-1}(γ) x_i - \sum_{j=1}^m A_j \left( \sum_{i=1}^{N+1} T_{i-1}(-ρ \tau_j+γ) y_i \right )\]</div><p>where T(c) is the vector containing <span>$T_i(c)$</span> as coefficients, where <span>$T_i$</span> is the i-th Chebyshev polynomial of the first kind.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_iar_chebyshev.jl#L276-L284">source</a><div><div><pre><code class="language-none">y0 = compute_y0_cheb([eltype],nep::NEPTypes.PEP,::Type{ComputeY0ChebPEP},X,Y,M0inv,precomp::AbstractPrecomputeData)</code></pre><p>Computes the vector y0 used in <a href="#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> given by</p><div>\[ y_0 = \sum_{j=0}^{d-1} A_{j+1} x D^j T(c) - y T(c)\]</div><p>where T(c) is the vector containing <span>$T_i(c)$</span> as coefficients, where <span>$T_i$</span> is the i-th Chebyshev polynomial of the first kind and <span>$D$</span> is the derivation matrix in Chebyshev basis.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_iar_chebyshev.jl#L298-L306">source</a><div><div><pre><code class="language-none">y0 = compute_y0_cheb([eltype],nep::NEPTypes.SPMF_NEP,::Type{ComputeY0ChebPEP},X,Y,M0inv,precomp::AbstractPrecomputeData)</code></pre><p>Computes the vector y0 used in <a href="#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> given by</p><div>\[ y_0= \sum_{j=0}^{m} M^{(j)}(\mu) X b_j \left( D_N \right) T_N(c) - Y T_N(c)\]</div><p>where T(c) is the vector containing <span>$T_i(c)$</span> as coefficients, where <span>$T_i$</span> is the i-th Chebyshev polynomial of the first kind and <span>$b_j(\lambda)=(f_j(0)-f_j(\lambda))/\lambda=f[\lambda,0]$</span> are divided differences.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_iar_chebyshev.jl#L322-L330">source</a><div><div><pre><code class="language-none">y0 = compute_y0_cheb([eltype],nep::NEPTypes.NEP,::Type{ComputeY0ChebNEP},X,Y,M0inv,precomp::AbstractPrecomputeData)</code></pre><p>Computes the vector y0 used in <a href="#NonlinearEigenproblems.NEPSolver.iar_chebyshev"><code>iar_chebyshev</code></a> defined as</p><div>\[ y_0 =\left( \sum_{i=0}^{N-1} B \left( \frac{d}{d \theta} \right) \hat T_i(\theta) x_i \right)(0) - \sum_{i=0}^{N} T_i(c) y_i\]</div><p>where <span>$T_i$</span> is the i-th Chebyshev polynomial of the first kind, $ \ hat T_i$ is the i-th Chebyshev polynomial of the first kind for the interval [a,b]. For a generic <code>nep</code>, this quantity is computed by converting polynomials in monomial basis. This procedure may be numerical unstable if many iterations are required. If for the specific <code>nep</code> a closed formula is available, we suggest to overload this function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_iar_chebyshev.jl#L344-L352">source</a></section><h3><a class="nav-anchor" id="TIAR-1" href="#TIAR-1">TIAR</a></h3><p>The Tensor Infinite ARnoldi method.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.tiar" href="#NonlinearEigenproblems.NEPSolver.tiar"><code>NonlinearEigenproblems.NEPSolver.tiar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tiar(nep,[maxit=30,][σ=0,][γ=1,][linsolvecreator=default_linsolvecreator,][tolerance=eps()*10000,][Neig=6,][errmeasure=default_errmeasure,][v=rand(size(nep,1),1),][displaylevel=0,][check_error_every=1,][orthmethod=DGKS])</code></pre><p>Run the tensor infinite Arnoldi method on the nonlinear eigenvalue problem stored in <code>nep</code>.</p><p>The target <code>σ</code> is the center around which eiganvalues are computed. The kwarg <code>errmeasure</code> is a function handle which can be used to specify how the error is measured to be used in termination (default is absolute residual norm). A Ritz pair <code>λ</code> and <code>v</code> is flagged a as converged (to an eigenpair) if <code>errmeasure</code> is less than <code>tol</code>. The vector <code>v</code> is the starting vector for constructing the Krylov space. The orthogonalization method, used in contructing the orthogonal basis of the Krylov space, is specified by <code>orthmethod</code>, see the package <code>IterativeSolvers.jl</code>. The iteration is continued until <code>Neig</code> Ritz pairs converge. This function throws a <code>NoConvergenceException</code> if the wanted eigenpairs are not computed after <code>maxit</code> iterations. The <code>linsolvercreator</code> is a function which specifies how the linear system is created and solved.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using NonlinearEigenproblems, LinearAlgebra
julia&gt; nep=nep_gallery(&quot;dep0&quot;,100);
julia&gt; v0=ones(size(nep,1));
julia&gt; λ,v=tiar(nep;v=v0,tol=1e-5,Neig=3);
julia&gt; norm(compute_Mlincomb!(nep,λ[1],v[:,1])) # Is it an eigenvalue?
julia&gt; λ    # print the computed eigenvalues
3-element Array{Complex{Float64},1}:
 -0.1560621147566685 + 0.12273439802763504im
 -0.1560621147566693 - 0.1227343980276357im
 0.23169243065648332 - 4.699260229885766e-17im
</code></pre><p><strong>References</strong></p><ul><li>Algorithm 2 in Jarlebring, Mele, Runborg, The Waveguide Eigenvalue Problem and the Tensor Infinite Arnoldi Method, SIAM J. Scient. computing, 39 (3), A1062-A1088, 2017</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_tiar.jl#L7-L34">source</a></section><h3><a class="nav-anchor" id="Infbilanczos-1" href="#Infbilanczos-1">Infbilanczos</a></h3><p>The Infinite Bi-Lanczos method.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.infbilanczos" href="#NonlinearEigenproblems.NEPSolver.infbilanczos"><code>NonlinearEigenproblems.NEPSolver.infbilanczos</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">λv,V,U=infbilanczos([eltype],nep, nept,[linsolvecreator,][linsolvertcreator,][v,][u,][σ,][γ,][tol,][Neig,][errmeasure,][displaylevel,][maxit,][check_error_every])</code></pre><p>Executes the Infinite Bi-Lanczos method on the problem defined by <code>nep::NEP</code> and <code>nept::NEP</code>. <code>nep:NEP</code> is the original nonlinear eigenvalue problem and <code>nept::NEP</code> is its (hermitian) transpose: <span>$M(λ^*)^H$</span>.  <code>v</code> and <code>u</code> are starting vectors, <code>σ</code> is the shift and <code>γ</code> the scaling.  See <code>newton()</code> for other parameters.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; A=get_Av(nep); fv=get_fv(nep);
julia&gt; At=[copy(A[1]&#39;),copy(A[2]&#39;),copy(A[3]&#39;)]
julia&gt; nept=SPMF_NEP(At,fv); # Create the transposed NEP
julia&gt; λv,V=infbilanczos(nep,nept,Neig=3)
julia&gt; norm(compute_Mlincomb(nep,λv[1],V[:,1]))</code></pre><p><strong>References:</strong></p><ul><li>The infinite bi-Lanczos method for nonlinear eigenvalue problems, S. W. Gaaf and E. Jarlebring, SIAM J. Sci. Comput. 39:S898-S919, 2017, <a href="https://arxiv.org/abs/1607.03454">preprint</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_infbilanczos.jl#L5-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.nleigs" href="#NonlinearEigenproblems.NEPSolver.nleigs"><code>NonlinearEigenproblems.NEPSolver.nleigs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nleigs(nep::NEP, Σ::AbstractVector{Complex{T}})</code></pre><p>Find a few eigenvalues and eigenvectors of a nonlinear eigenvalue problem.</p><p><strong>Arguments</strong></p><ul><li><code>nep</code>: An instance of a nonlinear eigenvalue problem.</li><li><code>Σ</code>: A vector containing the points of a polygonal target set in the complex plane.</li><li><code>Ξ</code>: A vector containing a discretization of the singularity set.</li><li><code>displaylevel</code>: Level of display (0, 1, 2).</li><li><code>maxdgr</code>: Max degree of approximation.</li><li><code>minit</code>: Min number of iterations after linearization is converged.</li><li><code>maxit</code>: Max number of total iterations.</li><li><code>tol</code>: Tolerance for residual.</li><li><code>tollin</code>: Tolerance for convergence of linearization.</li><li><code>v</code>: Starting vector.</li><li><code>errmeasure</code>: Function for error measure (residual norm). Called with arguments (λ,v).</li><li><code>isfunm</code> : Whether to use matrix functions.</li><li><code>static</code>: Whether to use static version of NLEIGS.</li><li><code>leja</code>: Use of Leja-Bagby points (0 = no, 1 = only in expansion phase, 2 = always).</li><li><code>nodes</code>: Prefixed interpolation nodes (only when leja is 0 or 1).</li><li><code>reusefact</code>: Reuse of matrix factorizations (0 = no, 1 = only after converged linearization, 2 = always).</li><li><code>blksize</code>: Block size for pre-allocation.</li><li><code>return_details</code>: Whether to return solution details (see NleigsSolutionDetails).</li><li><code>check_error_every</code>: Check for convergence / termination every this number of iterations.</li></ul><p><strong>Return values</strong></p><ul><li><code>λ</code>: Vector of eigenvalues of the nonlinear eigenvalue problem NLEP inside the target set Σ.</li><li><code>X</code>: Corresponding matrix of eigenvectors.</li><li><code>res</code>: Corresponding residuals.</li><li><code>details</code>: Solution details, if requested (see NleigsSolutionDetails).</li></ul><p><strong>References</strong></p><ul><li>S. Guettel, R. Van Beeumen, K. Meerbergen, and W. Michiels. NLEIGS: A class of fully rational Krylov methods for nonlinear eigenvalue problems. SIAM J. Sci. Comput., 36(6), A2842-A2864, 2014.</li><li><a href="http://twr.cs.kuleuven.be/research/software/nleps/nleigs.php">NLEIGS Matlab toolbox</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_nleigs.jl#L7-L44">source</a></section><h2><a class="nav-anchor" id="Class-specific-methods-1" href="#Class-specific-methods-1">Class specific methods</a></h2><h3><a class="nav-anchor" id="Companion-linearizations-1" href="#Companion-linearizations-1">Companion linearizations</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.companion" href="#NonlinearEigenproblems.NEPSolver.companion"><code>NonlinearEigenproblems.NEPSolver.companion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">E,A = companion(nep::Pep);</code></pre><p>Linearizes a  polynomial eigenvalue problem (PEP) a to the companion form, as in the paper by Mehrmann and Voss. More precisely, for a k-th degree PEP with n-by-n coefficient matrices, this returns matrices E and A, both kn-by-kn, corresponding to the linearized problem</p><div>\[Ax = λEx\]</div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; pep = nep_gallery(&quot;pep0&quot;);
julia&gt; E,A = companion(pep);
julia&gt; λ, V = eigen(A,E);
julia&gt; minimum(svd(compute_Mder(pep,λ[1])).S)
2.703104679937224e-12</code></pre><p><strong>References</strong></p><ul><li>V. Mehrmann and H. Voss, Non-linear eigenvalue problems, a challenge for modern eigenvalue methods, GAMM‐Mitteilungen (2004)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_companion.jl#L8-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearEigenproblems.NEPSolver.polyeig" href="#NonlinearEigenproblems.NEPSolver.polyeig"><code>NonlinearEigenproblems.NEPSolver.polyeig</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">λ,v = polyeig([eltype],nep::PEP,[eigsolvertype,])</code></pre><p>Linearizes a  polynomial eigenvalue problem (PEP) a to the companion form and solves the corresponding linear eigenvalue problem; see <a href="#NonlinearEigenproblems.NEPSolver.companion"><code>companion</code></a>. The <code>eigsolvertype</code> is optinal can be used to specify how the linear problem is solved; see <a href="../linsolvers/#NonlinearEigenproblems.LinSolvers.eig_solve"><code>eig_solve</code></a>, and <a href="../linsolvers/#NonlinearEigenproblems.LinSolvers.EigSolver"><code>EigSolver</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; pep = nep_gallery(&quot;pep0&quot;);
julia&gt; λ,V = polyeig(pep);
julia&gt; minimum(svd(compute_Mder(pep,λ[1])).S)
2.1724582040065456e-14
julia&gt; norm(compute_Mlincomb(pep,λ[2],vec(V[:,2])))
1.2210363164200074e-12</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/9d1612d9b6810647aeb21c8bb713cfd941771e43/src/method_companion.jl#L68-L85">source</a></section><h3><a class="nav-anchor" id="Rational-?-1" href="#Rational-?-1">Rational ?</a></h3><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../types/"><span class="direction">Next</span><span class="title">NEP Types</span></a></footer></article></body></html>
