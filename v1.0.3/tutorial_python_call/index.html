<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 6 (Python 2) · NEP-PACK</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NEP-PACK</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../methods/">NEP-Solvers</a></li><li><a class="tocitem" href="../types/">Types &amp; Data structures</a></li><li><a class="tocitem" href="../compute_functions/">Compute functions</a></li><li><a class="tocitem" href="../linsolvers/">Linear solvers</a></li><li><a class="tocitem" href="../innersolvers/">Projection</a></li><li><a class="tocitem" href="../errmeasure/">Measuring the error</a></li><li><a class="tocitem" href="../logger/">Logger</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../deflation/">Deflation</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="tocitem" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="tocitem" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="tocitem" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="tocitem" href="../tutorial_call_python/">Tutorial 5 (Python 1)</a></li><li class="is-active"><a class="tocitem" href>Tutorial 6 (Python 2)</a><ul class="internal"><li><a class="tocitem" href="#PyJulia"><span>PyJulia</span></a></li><li><a class="tocitem" href="#Using-PyJulia-and-NEP-PACK"><span>Using PyJulia and NEP-PACK</span></a></li></ul></li><li><a class="tocitem" href="../tutorial_matlab1/">Tutorial 7 (MATLAB)</a></li><li><a class="tocitem" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="tocitem" href="../tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="tocitem" href="../tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li><a class="tocitem" href="../tutorial_linsolve/">Tutorial 11 (Linear solvers)</a></li><li><a class="tocitem" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Tutorial 6 (Python 2)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial 6 (Python 2)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/tutorial_python_call.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial:-Using-NEP-PACK-from-python"><a class="docs-heading-anchor" href="#Tutorial:-Using-NEP-PACK-from-python">Tutorial: Using NEP-PACK from python</a><a id="Tutorial:-Using-NEP-PACK-from-python-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial:-Using-NEP-PACK-from-python" title="Permalink"></a></h1><h2 id="PyJulia"><a class="docs-heading-anchor" href="#PyJulia">PyJulia</a><a id="PyJulia-1"></a><a class="docs-heading-anchor-permalink" href="#PyJulia" title="Permalink"></a></h2><p>The previous tutorial illustrated how a NEP defined in python code can be solved with NEP-PACK. Python is currently a more mature language than Julia, and there are considerable packages and features in python not present in Julia. If you need these features, it may be more convenient to call NEP-PACK from  python, rather than calling python code from julia.</p><p>The python package <a href="https://github.com/JuliaPy/pyjulia">PyJulia</a> gives us that possibility. The installation of PyJulia on Ubuntu linux is simple:</p><pre><code class="nohighlight hljs">$ python3 -m pip install julia # Only necessary first time you run it
...
$ python3
&gt;&gt;&gt; from julia.api import Julia
&gt;&gt;&gt; jl = Julia(compiled_modules=False) # compilation flag necessary on ubuntu
&gt;&gt;&gt; julia.install()               # Only necessary first time you run it
&gt;&gt;&gt; from julia import Base
&gt;&gt;&gt; Base.MathConstants.golden  # Julia&#39;s definition of golden ratio
1.618033988749895</code></pre><h2 id="Using-PyJulia-and-NEP-PACK"><a class="docs-heading-anchor" href="#Using-PyJulia-and-NEP-PACK">Using PyJulia and NEP-PACK</a><a id="Using-PyJulia-and-NEP-PACK-1"></a><a class="docs-heading-anchor-permalink" href="#Using-PyJulia-and-NEP-PACK" title="Permalink"></a></h2><p>The <a href="../compute_functions/#NonlinearEigenproblems.NEPTypes.Mder_NEP"><code>Mder_NEP</code></a>-function provides a convenient way to define NEPs by only using a function that computes the matrix <span>$M(λ)$</span> and its derivatives. Let us first define a function which does that in python. We consider the problem</p><p class="math-container">\[M(λ)=\begin{bmatrix}3&amp;2\newline3&amp;-1\end{bmatrix}+
λ\begin{bmatrix}0&amp;2\newline0&amp;1\end{bmatrix}+
e^{0.5 λ}\begin{bmatrix}1&amp;1\newline1&amp;1\end{bmatrix}\]</p><p>and implement it with this python code:</p><pre><code class="language-python hljs">import numpy as np;
import cmath as m;
def my_compute_M(s,der):
    &quot;&quot;&quot;Compute the matrix M^{(k)}(s) for a given eigenvalue approximation and derivative k&quot;&quot;&quot;
    A=np.matrix(&#39;3 2; 3 -1&#39;);  B=np.matrix(&#39;0 2; 0 1&#39;);   C=np.matrix(&#39;1 1; 1 1&#39;);
    tau=0.5;
    M=pow(tau,der)*m.exp(tau*s)*C
    if (der==0):
        M=M+A+s*B;
    elif (der==1):
        M=M+B;
    return M</code></pre><p>An evaluation of the matrix function can be done by the call:</p><pre><code class="nohighlight hljs">&gt;&gt;&gt; my_compute_M(0.3,0)
matrix([[4.16183424+0.j, 3.76183424+0.j],
        [4.16183424+0.j, 0.46183424+0.j]])</code></pre><p>We instantiate a new NEP based with <code>Mder_NEP</code> which first must be imported</p><pre><code class="nohighlight hljs">&gt;&gt;&gt; from julia.NonlinearEigenproblems import Mder_NEP
&gt;&gt;&gt; n=2; # Size of the problem
&gt;&gt;&gt; nep=Mder_NEP(2,my_compute_M);</code></pre><p>and we can apply most of our solvers to this problem by first importing the corresponding function, in this case we use <a href="../methods/#NonlinearEigenproblems.NEPSolver.contour_beyn"><code>contour_beyn</code></a>.</p><pre><code class="nohighlight hljs">&gt;&gt;&gt; from julia.NonlinearEigenproblems import contour_beyn;
&gt;&gt;&gt; sol=contour_beyn(nep,logger=1,neigs=1,radius=3)
Computing integrals
NonlinearEigenproblems.NEPSolver.MatrixTrapezoidal: computing G...
NonlinearEigenproblems.NEPSolver.MatrixTrapezoidal: summing terms........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
Computing SVD prepare for eigenvalue extraction  p=1
Computing eigenvalues
Computing eigenvectors
&gt;&gt;&gt;</code></pre><p>We can verify that we computed a solution as follows</p><pre><code class="nohighlight hljs">&gt;&gt;&gt; s=sol[0][0]; v=sol[1]
&gt;&gt;&gt; my_compute_M(s,0)*v
matrix([[1.71634841e-17-1.59872116e-14j],
        [9.55210099e-17-3.99680289e-15j]])
&gt;&gt;&gt; from numpy.linalg import norm
&gt;&gt;&gt; norm(my_compute_M(s,0)*v)
1.6479526251408437e-14</code></pre><p>Note that in order to obtain better efficiency for large-scale problems, and reduce overhead, you may want to use <a href="../compute_functions/#NonlinearEigenproblems.NEPTypes.Mder_Mlincomb_NEP"><code>Mder_Mlincomb_NEP</code></a>, as described in the <a href="../tutorial_call_python/">previous tutorial</a>.</p><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_PYTHON2" alt="To the top"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial_call_python/">« Tutorial 5 (Python 1)</a><a class="docs-footer-nextpage" href="../tutorial_matlab1/">Tutorial 7 (MATLAB) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 4 July 2022 18:11">Monday 4 July 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
