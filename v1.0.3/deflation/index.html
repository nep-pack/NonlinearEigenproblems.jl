<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Deflation · NEP-PACK</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NEP-PACK</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../methods/">NEP-Solvers</a></li><li><a class="tocitem" href="../types/">Types &amp; Data structures</a></li><li><a class="tocitem" href="../compute_functions/">Compute functions</a></li><li><a class="tocitem" href="../linsolvers/">Linear solvers</a></li><li><a class="tocitem" href="../innersolvers/">Projection</a></li><li><a class="tocitem" href="../errmeasure/">Measuring the error</a></li><li><a class="tocitem" href="../logger/">Logger</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li class="is-active"><a class="tocitem" href>Deflation</a><ul class="internal"><li><a class="tocitem" href="#Theory"><span>Theory</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li><li><a class="tocitem" href="../gallery/">Gallery</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../movebc_tutorial/">Tutorial 1 (ABC)</a></li><li><a class="tocitem" href="../tutorial_contour/">Tutorial 2 (Contour)</a></li><li><a class="tocitem" href="../bemtutorial/">Tutorial 3 (BEM)</a></li><li><a class="tocitem" href="../deflate_tutorial/">Tutorial 4 (Deflation)</a></li><li><a class="tocitem" href="../tutorial_call_python/">Tutorial 5 (Python 1)</a></li><li><a class="tocitem" href="../tutorial_python_call/">Tutorial 6 (Python 2)</a></li><li><a class="tocitem" href="../tutorial_matlab1/">Tutorial 7 (MATLAB)</a></li><li><a class="tocitem" href="../tutorial_fortran1/">Tutorial 8 (FORTRAN)</a></li><li><a class="tocitem" href="../tutorial_nano1/">Tutorial 9 (gmsh + nanophotonics)</a></li><li><a class="tocitem" href="../tutorial_newmethod/">Tutorial 10 (New solver)</a></li><li><a class="tocitem" href="../tutorial_linsolve/">Tutorial 11 (Linear solvers)</a></li><li><a class="tocitem" href="../hydrotutorial/">Tutorial 12 (Orr–Somerfeld)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Deflation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Deflation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/master/docs/src/deflation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Deflation"><a class="docs-heading-anchor" href="#Deflation">Deflation</a><a id="Deflation-1"></a><a class="docs-heading-anchor-permalink" href="#Deflation" title="Permalink"></a></h1><p>Several NEP-algorithms are able to find one eigenvalue, but may have difficulties finding several eigenvalues. Deflation is a transformation technique which can transform a NEP by effectively removing computed eigenvalues, and allowing several eigenvalues to be computed by repeated application of the same NEP-algorithm.</p><p>NEP-PACK provides a solver-independent implementation of deflation which can be combined (essentially) with any NEP-solver.  NEP-PACK also has some NEP-solver deflation techniques and reconvergence avoidance techniques  incoprorated directly in the solver, e.g., in the nonlinear Arnoldi method (<a href="../methods/#NonlinearEigenproblems.NEPSolver.nlar"><code>nlar</code></a>), the Jacobi-Davidson method (<a href="../methods/#NonlinearEigenproblems.NEPSolver.jd_betcke"><code>jd_betcke</code></a>) and Broyden&#39;s method (<a href="../methods/#NonlinearEigenproblems.NEPSolver.broyden"><code>broyden</code></a>).</p><p>The technique takes a NEP and a solution and creates a bigger NEP with one dimension larger but where the eigenvalue is removed from the solution set. Due to the abstraction of NEP-objects in NEP-PACK, the deflated NEP is again a NEP and we can apply the NEP-solver to the deflated NEP.</p><ul><li>Given a NEP (which can be a deflated NEP) <code>nep</code> and an eigenpair <code>(λ,v)</code> you can compute a deflated NEP by calling <code>dnep=</code><a href="#NonlinearEigenproblems.NEPTypes.deflate_eigpair"><code>deflate_eigpair</code></a><code>(nep,λ,v)</code> and <code>dnep</code> will essentially have the same eigenvalues as <code>nep</code>, except <code>λ</code>.</li><li>The transformation changes the eigenvectors such that the eigenvectors of <code>nep</code> and <code>dnep</code> will be different. To extract the eigenvectors (and the eigenvalues) you can call <a href="#NonlinearEigenproblems.NEPTypes.get_deflated_eigpairs"><code>get_deflated_eigpairs</code></a><code>(dnep)</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>More elaborate deflation examples can be found in <a href="../deflate_tutorial/">the tutorial on deflation</a>.</p></div></div><h2 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h2><p>The theory follows the presentation of the technique in <a href="http://sma.epfl.ch/~anchpcommon/students/effenberger.pdf">the PhD thesis of Cedric Effenberger</a>. It can be summarized as follows, in a somewhat simplified form (for the index one case). The deflation is based on a theory for NEPs essentially stating that if <span>$(s,x)$</span> is an eigenpair, then under certain general conditions (which we implicitly assume are satisfied),  the extended nonlinear eigenvalue problem</p><p class="math-container">\[T(λ):=\begin{bmatrix}M(λ)&amp;M(λ)x(s-λ)^{-1}\\ x^T &amp; 0\end{bmatrix}\]</p><p>has the same eigenvalues as the original problem except for the eigenvalue <span>$s$</span> which is no longer part of the solution set. We have effectively removed (i.e. deflated) the eigenpair <code>(s,x)</code>. More eigenpairs can be deflated with techniques of partial Schur factorizations, which the user does not need to be aware of, due to the abstraction provided by the functions below. When we create a deflated NEP, we create the NEP <span>$T$</span>.</p><p>There are several ways to represent the <span>$T$</span>, which is why deflation has several modes. If you run</p><pre><code class="language-julia hljs">julia&gt; dnep=deflate_eigpair(nep,λ1,v1,mode=:SPMF)</code></pre><p>the <code>dnep</code> will be of the type <a href="../types/#NonlinearEigenproblems.NEPTypes.AbstractSPMF"><code>AbstractSPMF</code></a>. More precisely, if</p><p class="math-container">\[M(λ)=A_1f_1(λ)+\cdots+A_mf_m(λ)\]</p><p>the deflated NEP will be</p><p class="math-container">\[T(λ)=
\begin{bmatrix}A_1&amp;0\\0 &amp; 0\end{bmatrix}f_1(λ)+\cdots+
\begin{bmatrix}A_m&amp;0\\0 &amp; 0\end{bmatrix}f_m(λ)+\]</p><p class="math-container">\[\begin{bmatrix}0&amp;A_1x\\0 &amp; 0\end{bmatrix}\frac{f_1(λ)}{s-λ}+\cdots+
\begin{bmatrix}0&amp;A_mx\\0 &amp; 0\end{bmatrix}\frac{f_m(λ)}{s-λ}+
\begin{bmatrix}0&amp;0\\x^T &amp; 0\end{bmatrix}\]</p><p>Clearly, the deflated NEP has more SPMF-terms than the original <code>NEP</code>. When the parameter <code>mode=:SPMF</code> is set, the deflation method will explicitly construct an <a href="../types/#NonlinearEigenproblems.NEPTypes.SPMF_NEP"><code>SPMF_NEP</code></a>. This is not recommended if you have many SPMF-terms in the original problem, but can be efficient when you only have a few terms. (Some additional exploitation is however implemented, since we can use the fact that the introduced terms are of low rank, and therefore naturally represented as a <code>LowRankFactorizedNEP</code>.)</p><p>If you select <code>mode=:Generic</code>, the compute functions are implemented without the use of SPMF, and can be more efficient if the NEP has many SPMF-terms. When <code>mode=:MM</code> the compute-functions are all implemented by calls to <code>compute_MM</code>. This will not be efficient if <code>compute_Mder(nep,λ,der)</code> where  <code>der&gt;0</code> is needed.</p><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.deflate_eigpair" href="#NonlinearEigenproblems.NEPTypes.deflate_eigpair"><code>NonlinearEigenproblems.NEPTypes.deflate_eigpair</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dnep=deflate_eigpair(orgnep::NEP,λ,v,[mode=:Auto])</code></pre><p>This function creates a deflated NEP based on <span>$(λ,v)$</span>, which are assumed to an eigenpair of <code>nep</code>. Effectively, the function will return <code>dnep::NEP</code> which has the same solutions as orgnep, except those corresponding to <span>$(λ,v)$</span>. Deflation is typically used to avoid reconvergence.</p><p>If <code>orgnep</code> is a <code>DeflatedNEP</code>, the <code>orgnep</code> the deflation in <code>orgnep</code> will be updated.</p><p>The <code>mode</code> kwarg can be <code>:Auto</code>, <code>:Generic</code>, <code>:SPMF</code>, <code>:MM</code>. This specifies how the deflated NEP should be represented. Which mode is the most efficient depends on many problem properties. If the original NEP is an <code>AbstractSPMF</code> with only a few terms, <code>mode=:SPMF</code> may be efficient. The SPMF-mode is based on a diagonalization of the deflated invariant pair and is not necessarily robust when you deflate eigenvalues near to each other. When <code>mode=:MM</code> is used, all compute functions are implemented via calls to the <code>compute_MM</code>. This can work well for small dense problems. The <code>:Generic</code> is based on an explicit derivation of the problem (via binomial expansion) which can be efficient if low order derivates are needed. If <code>:Auto</code> is selected, NEP-PACK tries to determine which one is the most efficient based on the <code>orgnep</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nep=nep_gallery(&quot;dep0&quot;);
julia&gt; (λ,v)=newton(nep,v=ones(size(nep,1)));
julia&gt; dnep=deflate_eigpair(nep,λ,v)
julia&gt; (λ2,v2)=augnewton(dnep,v=ones(size(dnep,1)));  # this converges to different eigval
julia&gt; using LinearAlgebra;
julia&gt; minimum(svdvals(compute_Mder(nep,λ2)))
2.5161012836775824e-17</code></pre><p>The function <a href="#NonlinearEigenproblems.NEPTypes.get_deflated_eigpairs"><code>get_deflated_eigpairs()</code></a> extracts the eigenpairs that have been deflated. The returned pairs are eigenpairs of the original NEP:</p><pre><code class="language-julia-repl hljs">julia&gt; dnep=deflate_eigpair(dnep,λ2,v2);
julia&gt; (D,V)=get_deflated_eigpairs(dnep)
julia&gt; norm(compute_Mlincomb(nep,D[1],V[:,1]))
2.3970746442479104e-16
julia&gt; norm(compute_Mlincomb(nep,D[2],V[:,2]))
8.101585801848734e-16</code></pre><p><strong>References</strong></p><ul><li>C. Effenberger, Robust solution methods for nonlinear eigenvalue problems, PhD thesis, 2013, EPF Lausanne</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/7640f6d395cdcf9a5f2c59fb98c4247fa21305eb/src/nep_deflation.jl#L315-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearEigenproblems.NEPTypes.get_deflated_eigpairs" href="#NonlinearEigenproblems.NEPTypes.get_deflated_eigpairs"><code>NonlinearEigenproblems.NEPTypes.get_deflated_eigpairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(D,V)=get_deflated_eigpairs(S,V,n)
(D,V)=get_deflated_eigpairs(dnep::DeflatedNEP [λ,v])</code></pre><p>Returns a vector of eigenvalues <code>D</code> and a matrix with corresponding eigenvectors <code>V</code> of the invariant pair <code>S,V</code>. The eigenpairs correspond to the original problem, underlying the <code>DeflatedNEP</code>. The optional parameters <code>λ,v</code> allows the inclusion of an additional eigpair. Essentially, the optional parameters are the expanding the deflation and the running <code>get_deflated_eigpairs</code>  with kwarg, i.e.,</p><pre><code class="language-julia hljs">(D,V)=get_deflated_eigpairs(deflate_eigpair(dnep,λ,v))`</code></pre><p>See example in <a href="#NonlinearEigenproblems.NEPTypes.deflate_eigpair"><code>deflate_eigpair</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nep-pack/NonlinearEigenproblems.jl/blob/7640f6d395cdcf9a5f2c59fb98c4247fa21305eb/src/nep_deflation.jl#L417-L432">source</a></section></article><p><img src="http://jarlebring.se/onepixel.png?NEPPACKDOC_DEFLATIONM" alt="To the top"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../transformations/">« Transformations</a><a class="docs-footer-nextpage" href="../gallery/">Gallery »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 4 July 2022 18:12">Monday 4 July 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
